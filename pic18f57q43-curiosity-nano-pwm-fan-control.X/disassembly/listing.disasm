Disassembly Listing for Q43_MCC_Test
Generated From:
C:/Users/C15552/Desktop/Q43_MCC_Test.X/dist/default/production/Q43_MCC_Test.X.production.elf
Jul 3, 2019 2:13:36 PM

---  C:/Users/C15552/Desktop/Q43_MCC_Test.X/mcc_generated_files/uart1.c  --------------------------------
1:             /**
2:               UART1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 uart1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the UART1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for UART1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.4.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.00 and above
21:                    MPLAB             :  MPLAB X 5.10
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            #include <xc.h>
51:            #include "uart1.h"
52:            
53:            static volatile uart1_status_t uart1RxLastError;
54:            
55:            /**
56:              Section: UART1 APIs
57:            */
58:            void (*UART1_FramingErrorHandler)(void);
59:            void (*UART1_OverrunErrorHandler)(void);
60:            void (*UART1_ErrorHandler)(void);
61:            
62:            void UART1_DefaultFramingErrorHandler(void);
63:            void UART1_DefaultOverrunErrorHandler(void);
64:            void UART1_DefaultErrorHandler(void);
65:            
66:            void UART1_Initialize(void)
67:            {
68:                // Disable interrupts before changing states
69:            
70:                // Set the UART1 module to the options selected in the user interface.
71:            
72:                // P1L 0; 
73:                U1P1L = 0x00;
7E22  0E00     MOVLW 0x0
7E24  0102     MOVLB 0x2
7E26  6FA5     MOVWF 0xA5, BANKED
74:            
75:                // P1H 0; 
76:                U1P1H = 0x00;
7E28  0E00     MOVLW 0x0
7E2A  6FA6     MOVWF 0xA6, BANKED
77:            
78:                // P2L 0; 
79:                U1P2L = 0x00;
7E2C  0E00     MOVLW 0x0
7E2E  6FA7     MOVWF 0xA7, BANKED
80:            
81:                // P2H 0; 
82:                U1P2H = 0x00;
7E30  0E00     MOVLW 0x0
7E32  6FA8     MOVWF 0xA8, BANKED
83:            
84:                // P3L 0; 
85:                U1P3L = 0x00;
7E34  0E00     MOVLW 0x0
7E36  6FA9     MOVWF 0xA9, BANKED
86:            
87:                // P3H 0; 
88:                U1P3H = 0x00;
7E38  0E00     MOVLW 0x0
7E3A  6FAA     MOVWF 0xAA, BANKED
89:            
90:                // BRGS high speed; MODE Asynchronous 8-bit mode; RXEN disabled; TXEN enabled; ABDEN disabled; 
91:                U1CON0 = 0xA0;
7E3C  0EA0     MOVLW 0xA0
7E3E  6FAB     MOVWF 0xAB, BANKED
92:            
93:                // RXBIMD Set RXBKIF on rising RX input; BRKOVR disabled; WUE disabled; SENDB disabled; ON enabled; 
94:                U1CON1 = 0x80;
7E40  0E80     MOVLW 0x80
7E42  6FAC     MOVWF ACTCON, BANKED
95:            
96:                // TXPOL not inverted; FLO off; C0EN Checksum Mode 0; RXPOL not inverted; RUNOVF RX input shifter stops all activity; STP Transmit 1Stop bit, receiver verifies first Stop bit; 
97:                U1CON2 = 0x00;
7E44  0E00     MOVLW 0x0
7E46  6FAD     MOVWF OSCCON1, BANKED
98:            
99:                // BRGL 25; 
100:               U1BRGL = 0xC7;
7E48  0EC7     MOVLW 0xC7
7E4A  6FAE     MOVWF OSCCON2, BANKED
101:           
102:               // BRGH 0; 
103:               U1BRGH = 0x06;
7E4C  0E06     MOVLW 0x6
7E4E  6FAF     MOVWF OSCCON3, BANKED
104:           
105:               // STPMD in middle of first Stop bit; TXWRE No error; 
106:               U1FIFO = 0x00;
7E50  0E00     MOVLW 0x0
7E52  6FB0     MOVWF OSCTUNE, BANKED
107:           
108:               // ABDIF Auto-baud not enabled or not complete; WUIF WUE not enabled by software; ABDIE disabled; 
109:               U1UIR = 0x00;
7E54  0E00     MOVLW 0x0
7E56  6FB1     MOVWF OSCFRQ, BANKED
110:           
111:               // ABDOVF Not overflowed; TXCIF 0; RXBKIF No Break detected; RXFOIF not overflowed; CERIF No Checksum error; 
112:               U1ERRIR = 0x00;
7E58  0E00     MOVLW 0x0
7E5A  6FB2     MOVWF OSCSTAT, BANKED
113:           
114:               // TXCIE disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; RXFOIE disabled; PERIE disabled; RXBKIE disabled; 
115:               U1ERRIE = 0x00;
7E5C  0E00     MOVLW 0x0
7E5E  6FB3     MOVWF OSCEN, BANKED
116:           
117:           
118:               UART1_SetFramingErrorHandler(UART1_DefaultFramingErrorHandler);
7E60  0E00     MOVLW 0x0
7E62  0106     MOVLB 0x6
7E64  6F00     MOVWF txData, BANKED
7E66  0E00     MOVLW 0x0
7E68  6F01     MOVWF 0x1, BANKED
7E6A  0E00     MOVLW 0x0
7E6C  6F02     MOVWF 0x2, BANKED
7E6E  EC0B     CALL 0x8616, 0
7E70  F043     NOP
119:               UART1_SetOverrunErrorHandler(UART1_DefaultOverrunErrorHandler);
7E72  0E00     MOVLW 0x0
7E74  0106     MOVLB 0x6
7E76  6F00     MOVWF txData, BANKED
7E78  0E00     MOVLW 0x0
7E7A  6F01     MOVWF 0x1, BANKED
7E7C  0E00     MOVLW 0x0
7E7E  6F02     MOVWF 0x2, BANKED
7E80  EC01     CALL 0x8602, 0
7E82  F043     NOP
120:               UART1_SetErrorHandler(UART1_DefaultErrorHandler);
7E84  0E00     MOVLW 0x0
7E86  0106     MOVLB 0x6
7E88  6F00     MOVWF txData, BANKED
7E8A  0E00     MOVLW 0x0
7E8C  6F01     MOVWF 0x1, BANKED
7E8E  0E00     MOVLW 0x0
7E90  6F02     MOVWF 0x2, BANKED
7E92  EC15     CALL 0x862A, 0
7E94  F043     NOP
121:           
122:               uart1RxLastError.status = 0;
7E96  0E00     MOVLW 0x0
7E98  0106     MOVLB 0x6
7E9A  6FBD     MOVWF 0xBD, BANKED
123:           
124:           }
7E9C  0012     RETURN 0
125:           
126:           bool UART1_is_rx_ready(void)
127:           {
128:               return (bool)(PIR4bits.U1RXIF);
129:           }
130:           
131:           bool UART1_is_tx_ready(void)
132:           {
133:               return (bool)(PIR4bits.U1TXIF && U1CON0bits.TXEN);
134:           }
135:           
136:           bool UART1_is_tx_done(void)
137:           {
138:               return U1ERRIRbits.TXMTIF;
139:           }
140:           
141:           uart1_status_t UART1_get_last_status(void){
142:               return uart1RxLastError;
143:           }
144:           
145:           uint8_t UART1_Read(void)
146:           {
147:               while(!PIR4bits.U1RXIF)
148:               {
149:               }
150:           
151:               uart1RxLastError.status = 0;
152:           
153:               if(U1ERRIRbits.FERIF){
154:                   uart1RxLastError.ferr = 1;
155:                   UART1_FramingErrorHandler();
156:               }
157:           
158:               if(U1ERRIRbits.RXFOIF){
159:                   uart1RxLastError.oerr = 1;
160:                   UART1_OverrunErrorHandler();
161:               }
162:           
163:               if(uart1RxLastError.status){
164:                   UART1_ErrorHandler();
165:               }
166:           
167:               return U1RXB;
168:           }
169:           
170:           void UART1_Write(uint8_t txData)
85BA  0106     MOVLB 0x6
85BC  6F00     MOVWF txData, BANKED
171:           {
172:               while(0 == PIR4bits.U1TXIF)
173:               {
174:               }
85BE  A2B2     BTFSS 0xFB2, 1, ACCESS
85C0  EFE4     GOTO 0x85C8
85C2  F042     NOP
85C4  EFE6     GOTO 0x85CC
85C6  F042     NOP
85C8  EFDF     GOTO 0x85BE
85CA  F042     NOP
175:           
176:               U1TXB = txData;    // Write the data byte to the USART.
85CE  F800     NOP
85D0  F2A3     NOP
177:           }
85D2  0012     RETURN 0
178:           
179:           char getch(void)
180:           {
181:               return UART1_Read();
182:           }
183:           
184:           void putch(char txData)
86A0  0106     MOVLB 0x6
86A2  6F01     MOVWF 0x1, BANKED
185:           {
186:               UART1_Write(txData);
86A4  0106     MOVLB 0x6
86A6  5101     MOVF 0x1, W, BANKED
86A8  ECDD     CALL 0x85BA, 0
86AA  F042     NOP
187:           }
86AC  0012     RETURN 0
188:           
189:           
190:           
191:           
192:           
193:           void UART1_DefaultFramingErrorHandler(void){}
194:           
195:           void UART1_DefaultOverrunErrorHandler(void){}
196:           
197:           void UART1_DefaultErrorHandler(void){
198:           }
199:           
200:           void UART1_SetFramingErrorHandler(void (* interruptHandler)(void)){
201:               UART1_FramingErrorHandler = interruptHandler;
8618  F800     NOP
861A  F6C4     NOP
861E  F804     NOP
8620  F6C5     NOP
8624  F808     NOP
8626  F6C6     NOP
202:           }
8628  0012     RETURN 0
203:           
204:           void UART1_SetOverrunErrorHandler(void (* interruptHandler)(void)){
205:               UART1_OverrunErrorHandler = interruptHandler;
8604  F800     NOP
8606  F6C1     NOP
860A  F804     NOP
860C  F6C2     NOP
8610  F808     NOP
8612  F6C3     NOP
206:           }
8614  0012     RETURN 0
207:           
208:           void UART1_SetErrorHandler(void (* interruptHandler)(void)){
209:               UART1_ErrorHandler = interruptHandler;
862C  F800     NOP
862E  F6BE     NOP
8632  F804     NOP
8634  F6BF     NOP
8638  F808     NOP
863A  F6C0     NOP
210:           }
863C  0012     RETURN 0
211:           
212:           
213:           
214:           
215:           
216:           
217:           /**
218:             End of File
219:           */
---  C:/Users/C15552/Desktop/Q43_MCC_Test.X/mcc_generated_files/tmr1.c  ---------------------------------
1:             /**
2:               TMR1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.00 and above
21:                    MPLAB 	          :  MPLAB X 5.10
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr1.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            volatile uint16_t timer1ReloadVal;
58:            
59:            /**
60:              Section: TMR1 APIs
61:            */
62:            
63:            void TMR1_Initialize(void)
64:            {
65:                //Set the Timer to the options selected in the GUI
66:            
67:                //T1GE disabled; T1GTM disabled; T1GPOL low; T1GGO done; T1GSPM disabled; 
68:                T1GCON = 0x00;
82FE  0E00     MOVLW 0x0
8300  0103     MOVLB 0x3
8302  6F1F     MOVWF 0x1F, BANKED
69:            
70:                //GSS T1G_pin; 
71:                T1GATE = 0x00;
8304  0E00     MOVLW 0x0
8306  6F20     MOVWF 0x20, BANKED
72:            
73:                //CS FOSC/4; 
74:                T1CLK = 0x05;
8308  0E05     MOVLW 0x5
830A  6F21     MOVWF 0x21, BANKED
75:            
76:                //TMR1H 0; 
77:                TMR1H = 0x00;
830C  0E00     MOVLW 0x0
830E  6F1D     MOVWF 0x1D, BANKED
78:            
79:                //TMR1L 0; 
80:                TMR1L = 0x00;
8310  0E00     MOVLW 0x0
8312  6F1C     MOVWF 0x1C, BANKED
81:            
82:                // Load the TMR value to reload variable
83:                timer1ReloadVal=(uint16_t)((TMR1H << 8) | TMR1L);
8314  511C     MOVF 0x1C, W, BANKED
8318  FC74     NOP
831A  F600     NOP
831C  0106     MOVLB 0x6
831E  6B01     CLRF 0x1, BANKED
8322  F800     NOP
8324  F601     NOP
8326  6B00     CLRF txData, BANKED
8328  1100     IORWF txData, W, BANKED
832A  0105     MOVLB 0x5
832C  6FE3     MOVWF 0xE3, BANKED
832E  0106     MOVLB 0x6
8330  5101     MOVF 0x1, W, BANKED
8332  0105     MOVLB 0x5
8334  6FE4     MOVWF 0xE4, BANKED
84:            
85:                // Clearing IF flag.
86:                PIR3bits.TMR1IF = 0;
8336  98B1     BCF 0xFB1, 4, ACCESS
87:            
88:                // CKPS 1:8; NOT_SYNC synchronize; TMR1ON enabled; T1RD16 enabled; 
89:                T1CON = 0x23;
8338  0E23     MOVLW 0x23
833A  0103     MOVLB 0x3
833C  6F1E     MOVWF 0x1E, BANKED
90:            }
833E  0012     RETURN 0
91:            
92:            void TMR1_StartTimer(void)
93:            {
94:                // Start the Timer by writing to TMRxON bit
95:                T1CONbits.TMR1ON = 1;
96:            }
97:            
98:            void TMR1_StopTimer(void)
99:            {
100:               // Stop the Timer by writing to TMRxON bit
101:               T1CONbits.TMR1ON = 0;
102:           }
103:           
104:           uint16_t TMR1_ReadTimer(void)
105:           {
106:               uint16_t readVal;
107:               uint8_t readValHigh;
108:               uint8_t readValLow;
109:               
110:               T1CONbits.T1RD16 = 1;
111:           	
112:               readValLow = TMR1L;
113:               readValHigh = TMR1H;
114:               
115:               readVal = ((uint16_t)readValHigh << 8) | readValLow;
116:           
117:               return readVal;
118:           }
119:           
120:           void TMR1_WriteTimer(uint16_t timerVal)
121:           {
122:               if (T1CONbits.NOT_SYNC == 1)
123:               {
124:                   // Stop the Timer by writing to TMRxON bit
125:                   T1CONbits.TMR1ON = 0;
126:           
127:                   // Write to the Timer1 register
128:                   TMR1H = (timerVal >> 8);
129:                   TMR1L = timerVal;
130:           
131:                   // Start the Timer after writing to the register
132:                   T1CONbits.TMR1ON =1;
133:               }
134:               else
135:               {
136:                   // Write to the Timer1 register
137:                   TMR1H = (timerVal >> 8);
138:                   TMR1L = timerVal;
139:               }
140:           }
141:           
142:           void TMR1_Reload(void)
143:           {
144:               TMR1_WriteTimer(timer1ReloadVal);
145:           }
146:           
147:           void TMR1_StartSinglePulseAcquisition(void)
148:           {
149:               T1GCONbits.T1GGO = 1;
150:           }
151:           
152:           uint8_t TMR1_CheckGateValueStatus(void)
153:           {
154:               return (T1GCONbits.T1GVAL);
155:           }
156:           
157:           bool TMR1_HasOverflowOccured(void)
158:           {
159:               // check if  overflow has occurred by checking the TMRIF bit
160:               return(PIR3bits.TMR1IF);
161:           }
162:           /**
163:             End of File
164:           */
---  C:/Users/C15552/Desktop/Q43_MCC_Test.X/mcc_generated_files/pwm2.c  ---------------------------------
1:             /**
2:               PWM2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 pwm2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the PWM2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for PWM2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  1.0.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.00 and above or later
21:                    MPLAB             :  MPLAB X 5.10
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "pwm2.h"
53:            
54:            //Pointers to PWM2 interrupt handlers
55:            //User can use them in application code to initialize with custom ISRs
56:            static void (*PWM2_Slice1Output1_InterruptHandler)(void) = NULL;   //SaP1IF and hence PWMxIF is true
57:            static void (*PWM2_Slice1Output2_InterruptHandler)(void) = NULL;   //SaP2IF and hence PWMxIF is true
58:            static void (*PWM2_Period_InterruptHandler)(void) = NULL;          //PWMxPIF is true
59:            
60:            void PWM2_Initialize(void)
61:            {
62:                //PWMERS External Reset Disabled; 
63:                PWM2ERS = 0x00;
83BC  0E00     MOVLW 0x0
83BE  6E6F     MOVWF 0xF6F, ACCESS
64:                //PWMCLK FOSC; 
65:                PWM2CLK = 0x02;
83C0  0E02     MOVLW 0x2
83C2  6E70     MOVWF 0xF70, ACCESS
66:                //PWMLDS Autoload disabled; 
67:                PWM2LDS = 0x00;
83C4  0E00     MOVLW 0x0
83C6  6E71     MOVWF 0xF71, ACCESS
68:                //PWMPRL 39; 
69:                PWM2PRL = 0x00;
83C8  0E00     MOVLW 0x0
83CA  6E72     MOVWF 0xF72, ACCESS
70:                //PWMPRH 0; 
71:                PWM2PRH = 0x0A;
83CC  0E0A     MOVLW 0xA
83CE  6E73     MOVWF 0xF73, ACCESS
72:                //PWMCPRE No prescale; 
73:                PWM2CPRE = 0x00;
83D0  0E00     MOVLW 0x0
83D2  6E74     MOVWF 0xF74, ACCESS
74:                //PWMPIPOS No postscale; 
75:                PWM2PIPOS = 0x00;
83D4  0E00     MOVLW 0x0
83D6  6E75     MOVWF 0xF75, ACCESS
76:                //PWMS1P2IF PWM2 output match did not occur; PWMS1P1IF PWM1 output match did not occur; 
77:                PWM2GIR = 0x00;
83D8  0E00     MOVLW 0x0
83DA  6E76     MOVWF 0xF76, ACCESS
78:                //PWMS1P2IE disabled; PWMS1P1IE disabled; 
79:                PWM2GIE = 0x00;
83DC  0E00     MOVLW 0x0
83DE  6E77     MOVWF 0xF77, ACCESS
80:                //PWMPOL2 disabled; PWMPOL1 disabled; PWMPPEN disabled; PWMMODE PWMOUT1 and PWMOUT2 in left aligned mode; 
81:                PWM2S1CFG = 0x00;
83E0  0E00     MOVLW 0x0
83E2  6E79     MOVWF 0xF79, ACCESS
82:                //PWMS1P1L 0; 
83:                PWM2S1P1L = 0x00;
83E4  0E00     MOVLW 0x0
83E6  6E7A     MOVWF 0xF7A, ACCESS
84:                //PWMS1P1H 05; 
85:                PWM2S1P1H = 0x05;
83E8  0E05     MOVLW 0x5
83EA  6E7B     MOVWF 0xF7B, ACCESS
86:                //PWMS1P2L 0; 
87:                PWM2S1P2L = 0x00;
83EC  0E00     MOVLW 0x0
83EE  6E7C     MOVWF 0xF7C, ACCESS
88:                //PWMS1P2H 05; 
89:                PWM2S1P2H = 0x05;
83F0  0E05     MOVLW 0x5
83F2  6E7D     MOVWF 0xF7D, ACCESS
90:                //PWMEN enabled; PWMLD disabled; PWMERSPOL disabled; PWMERSNOW disabled; 
91:                PWM2CON = 0x80;
83F4  0E80     MOVLW 0x80
83F6  6E78     MOVWF 0xF78, ACCESS
92:            }
83F8  0012     RETURN 0
93:            
94:            void PWM2_Enable()
95:            {
96:                PWM2CON |= _PWM2CON_EN_MASK;
97:            }
98:            
99:            void PWM2_Disable()
100:           {
101:               PWM2CON &= (~_PWM2CON_EN_MASK);
102:           }
103:           
104:           void PWM2_WritePeriodRegister(uint16_t periodCount)
105:           {
106:               PWM2PRL = (uint8_t)periodCount;
107:               PWM2PRH = (uint8_t)(periodCount >> 8);
108:           }
109:           
110:           void PWM2_SetSlice1Output1DutyCycleRegister(uint16_t registerValue)
111:           {    
112:               PWM2S1P1L = (uint8_t)(registerValue);
113:               PWM2S1P1H = (uint8_t)(registerValue >> 8);
114:           }
115:           
116:           void PWM2_SetSlice1Output2DutyCycleRegister(uint16_t registerValue)
117:           {        
118:               PWM2S1P2L = (uint8_t)(registerValue);
119:               PWM2S1P2H = (uint8_t)(registerValue >> 8);
120:           }
121:           
122:           void PWM2_LoadBufferRegisters(void)
123:           {
124:               //Load the period and duty cycle registers on the next period event
125:               PWM2CONbits.LD = 1;
126:           }
127:           
128:           void PWM2_ISR_PWM2_PWMI(void)
129:           {
130:               if((PWM2GIEbits.S1P1IE == 1) && (PWM2GIRbits.S1P1IF == 1))
131:               {
132:                   if(PWM2_Slice1Output1_InterruptHandler != NULL)
133:                       PWM2_Slice1Output1_InterruptHandler();
134:               }
135:               else if((PWM2GIEbits.S1P2IE == 1) && (PWM2GIRbits.S1P2IF == 1))
136:               {
137:                   if(PWM2_Slice1Output2_InterruptHandler != NULL)
138:                       PWM2_Slice1Output2_InterruptHandler();
139:               }
140:           }
141:           
142:           void PWM2_ISR_PWM2_PWMPI(void)
143:           {
144:               if(PWM2_Period_InterruptHandler != NULL)
145:                   PWM2_Period_InterruptHandler();
146:           }
147:           
148:           void PWM2_Slice1Output1_SetInterruptHandler(void (* InterruptHandler)(void))
149:           {
150:               PWM2_Slice1Output1_InterruptHandler = InterruptHandler;
151:           }
152:           
153:           void PWM2_Slice1Output2_SetInterruptHandler(void (* InterruptHandler)(void))
154:           {
155:               PWM2_Slice1Output2_InterruptHandler = InterruptHandler;
156:           }
157:           
158:           void PWM2_Period_SetInterruptHandler(void (* InterruptHandler)(void))
159:           {
160:               PWM2_Period_InterruptHandler = InterruptHandler;
161:           }
---  C:/Users/C15552/Desktop/Q43_MCC_Test.X/mcc_generated_files/pwm1.c  ---------------------------------
1:             /**
2:               PWM1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 pwm1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the PWM1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for PWM1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  1.0.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.00 and above or later
21:                    MPLAB             :  MPLAB X 5.10
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "pwm1.h"
53:            
54:            //Pointers to PWM1 interrupt handlers
55:            //User can use them in application code to initialize with custom ISRs
56:            static void (*PWM1_Slice1Output1_InterruptHandler)(void) = NULL;                //SaP1IF and hence PWMxIF is true
57:            static void (*PWM1_Slice1Output2_InterruptHandler)(void) = NULL;                //SaP2IF and hence PWMxIF is true
58:            static void (*PWM1_Period_InterruptHandler)(void) = NULL;                       //PWMxPIF is true
59:            
60:            void PWM1_Initialize(void)
61:            {
62:                PWM1ERS = 0x00;                                                             // PWMERS External Reset Disabled; 
83FA  0E00     MOVLW 0x0
83FC  6E60     MOVWF 0xF60, ACCESS
63:                PWM1CLK = 0x02;                                                             // PWMCLK FOSC;
83FE  0E02     MOVLW 0x2
8400  6E61     MOVWF 0xF61, ACCESS
64:                PWM1LDS = 0x00;                                                             // PWMLDS Autoload disabled;
8402  0E00     MOVLW 0x0
8404  6E62     MOVWF 0xF62, ACCESS
65:                PWM1PRL = 0x00;                                                             // 0x0A00 = 25 kHz PWM frequency @ 64 MHz FOSC    
8406  0E00     MOVLW 0x0
8408  6E63     MOVWF 0xF63, ACCESS
66:                PWM1PRH = 0x0A;     
840A  0E0A     MOVLW 0xA
840C  6E64     MOVWF 0xF64, ACCESS
67:                PWM1CPRE = 0x00;                                                            // PWMCPRE No prescale;     
840E  0E00     MOVLW 0x0
8410  6E65     MOVWF 0xF65, ACCESS
68:                PWM1PIPOS = 0x00;                                                           // PWMPIPOS No postscale; 
8412  0E00     MOVLW 0x0
8414  6E66     MOVWF 0xF66, ACCESS
69:                PWM1GIR = 0x00;                                                             // PWMS1P2IF PWM2 output match did not occur; PWMS1P1IF PWM1 output match did not occur;     
8416  0E00     MOVLW 0x0
8418  6E67     MOVWF 0xF67, ACCESS
70:                PWM1GIE = 0x00;                                                             // PWMS1P2IE disabled; PWMS1P1IE disabled; 
841A  0E00     MOVLW 0x0
841C  6E68     MOVWF 0xF68, ACCESS
71:                PWM1S1CFG = 0x00;                                                           // PWMPOL2 disabled; PWMPOL1 disabled; PWMPPEN disabled; left aligned mode;
841E  0E00     MOVLW 0x0
8420  6E6A     MOVWF 0xF6A, ACCESS
72:                PWM1S1P1L = 0x00;                                                           
8422  0E00     MOVLW 0x0
8424  6E6B     MOVWF 0xF6B, ACCESS
73:                PWM1S1P1H = 0x05; 
8426  0E05     MOVLW 0x5
8428  6E6C     MOVWF 0xF6C, ACCESS
74:                PWM1S1P2L = 0x00;                                                           
842A  0E00     MOVLW 0x0
842C  6E6D     MOVWF 0xF6D, ACCESS
75:                PWM1S1P2H = 0x05;    
842E  0E05     MOVLW 0x5
8430  6E6E     MOVWF 0xF6E, ACCESS
76:                PWM1CON = 0x80;                                                             //PWMEN enabled; PWMLD disabled; PWMERSPOL disabled; PWMERSNOW disabled;
8432  0E80     MOVLW 0x80
8434  6E69     MOVWF 0xF69, ACCESS
77:            }
8436  0012     RETURN 0
78:            
79:            void PWM1_Enable()
80:            {
81:                PWM1CON |= _PWM1CON_EN_MASK;
82:            }
83:            
84:            void PWM1_Disable()
85:            {
86:                PWM1CON &= (~_PWM1CON_EN_MASK);
87:            }
88:            
89:            void PWM1_WritePeriodRegister(uint16_t periodCount)
90:            {
91:                PWM1PRL = (uint8_t)periodCount;
92:                PWM1PRH = (uint8_t)(periodCount >> 8);
93:            }
94:            
95:            void PWM1_SetSlice1Output1DutyCycleRegister(uint16_t registerValue)
96:            {    
97:                PWM1S1P1L = (uint8_t)(registerValue);
98:                PWM1S1P1H = (uint8_t)(registerValue >> 8);
99:            }
100:           
101:           void PWM1_SetSlice1Output2DutyCycleRegister(uint16_t registerValue)
102:           {        
103:               PWM1S1P2L = (uint8_t)(registerValue);
104:               PWM1S1P2H = (uint8_t)(registerValue >> 8);
105:           }
106:           
107:           void PWM1_LoadBufferRegisters(void)
108:           {
109:               //Load the period and duty cycle registers on the next period event
110:               PWM1CONbits.LD = 1;
111:           }
112:           
113:           void PWM1_ISR_PWM1_PWMI(void)
114:           {
115:               if((PWM1GIEbits.S1P1IE == 1) && (PWM1GIRbits.S1P1IF == 1))
116:               {
117:                   if(PWM1_Slice1Output1_InterruptHandler != NULL)
118:                       PWM1_Slice1Output1_InterruptHandler();
119:               }
120:               else if((PWM1GIEbits.S1P2IE == 1) && (PWM1GIRbits.S1P2IF == 1))
121:               {
122:                   if(PWM1_Slice1Output2_InterruptHandler != NULL)
123:                       PWM1_Slice1Output2_InterruptHandler();
124:               }
125:           }
126:           
127:           void PWM1_ISR_PWM1_PWMPI(void)
128:           {
129:               if(PWM1_Period_InterruptHandler != NULL)
130:                   PWM1_Period_InterruptHandler();
131:           }
132:           
133:           void PWM1_Slice1Output1_SetInterruptHandler(void (* InterruptHandler)(void))
134:           {
135:               PWM1_Slice1Output1_InterruptHandler = InterruptHandler;
136:           }
137:           
138:           void PWM1_Slice1Output2_SetInterruptHandler(void (* InterruptHandler)(void))
139:           {
140:               PWM1_Slice1Output2_InterruptHandler = InterruptHandler;
141:           }
142:           
143:           void PWM1_Period_SetInterruptHandler(void (* InterruptHandler)(void))
144:           {
145:               PWM1_Period_InterruptHandler = InterruptHandler;
146:           }
---  C:/Users/C15552/Desktop/Q43_MCC_Test.X/mcc_generated_files/pin_manager.c  --------------------------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.00 and above
21:                    MPLAB             :  MPLAB X 5.10
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "pin_manager.h"
50:            
51:            
52:            
53:            
54:            
55:            void PIN_MANAGER_Initialize(void)
56:            {
57:                /**
58:                LATx registers
59:                */
60:                LATE = 0x00;
7A16  0E00     MOVLW 0x0
7A18  6EC2     MOVWF 0xFC2, ACCESS
61:                LATD = 0x00;
7A1A  0E00     MOVLW 0x0
7A1C  6EC1     MOVWF 0xFC1, ACCESS
62:                LATA = 0x00;
7A1E  0E00     MOVLW 0x0
7A20  6EBE     MOVWF 0xFBE, ACCESS
63:                LATB = 0x00;
7A22  0E00     MOVLW 0x0
7A24  6EBF     MOVWF 0xFBF, ACCESS
64:                LATC = 0x00;
7A26  0E00     MOVLW 0x0
7A28  6EC0     MOVWF 0xFC0, ACCESS
65:            
66:                /**
67:                TRISx registers
68:                */
69:                TRISE = 0x07;
7A2A  0E07     MOVLW 0x7
7A2C  6ECA     MOVWF 0xFCA, ACCESS
70:                TRISA = 0xFF;
7A2E  68C6     SETF 0xFC6, ACCESS
71:                TRISB = 0xFF;
7A30  68C7     SETF 0xFC7, ACCESS
72:                TRISC = 0xBC;
7A32  0EBC     MOVLW 0xBC
7A34  6EC8     MOVWF 0xFC8, ACCESS
73:                TRISD = 0xFC;
7A36  0EFC     MOVLW 0xFC
7A38  6EC9     MOVWF 0xFC9, ACCESS
74:            
75:                /**
76:                ANSELx registers
77:                */
78:                ANSELD = 0xFC;
7A3A  0EFC     MOVLW 0xFC
7A3C  0104     MOVLB 0x4
7A3E  6F18     MOVWF 0x18, BANKED
79:                ANSELC = 0x3C;
7A40  0E3C     MOVLW 0x3C
7A42  6F10     MOVWF 0x10, BANKED
80:                ANSELB = 0xC7;
7A44  0EC7     MOVLW 0xC7
7A46  6F08     MOVWF 0x8, BANKED
81:                ANSELE = 0x07;
7A48  0E07     MOVLW 0x7
7A4A  6F20     MOVWF 0x20, BANKED
82:                ANSELA = 0xFF;
7A4C  6900     SETF txData, BANKED
83:            
84:                /**
85:                WPUx registers
86:                */
87:                WPUD = 0x00;
7A4E  0E00     MOVLW 0x0
7A50  6F19     MOVWF 0x19, BANKED
88:                WPUE = 0x00;
7A52  0E00     MOVLW 0x0
7A54  6F21     MOVWF 0x21, BANKED
89:                WPUB = 0x38;
7A56  0E38     MOVLW 0x38
7A58  6F09     MOVWF 0x9, BANKED
90:                WPUA = 0x00;
7A5A  0E00     MOVLW 0x0
7A5C  6F01     MOVWF 0x1, BANKED
91:                WPUC = 0x00;
7A5E  0E00     MOVLW 0x0
7A60  6F11     MOVWF 0x11, BANKED
92:            
93:                /**
94:                ODx registers
95:                */
96:                ODCONE = 0x00;
7A62  0E00     MOVLW 0x0
7A64  6F22     MOVWF 0x22, BANKED
97:                ODCONA = 0x00;
7A66  0E00     MOVLW 0x0
7A68  6F02     MOVWF 0x2, BANKED
98:                ODCONB = 0x00;
7A6A  0E00     MOVLW 0x0
7A6C  6F0A     MOVWF 0xA, BANKED
99:                ODCONC = 0x00;
7A6E  0E00     MOVLW 0x0
7A70  6F12     MOVWF 0x12, BANKED
100:               ODCOND = 0x00;
7A72  0E00     MOVLW 0x0
7A74  6F1A     MOVWF 0x1A, BANKED
101:           
102:               /**
103:               SLRCONx registers
104:               */
105:               SLRCONA = 0xFF;
7A76  6903     SETF 0x3, BANKED
106:               SLRCONB = 0xFF;
7A78  690B     SETF 0xB, BANKED
107:               SLRCONC = 0xFF;
7A7A  6913     SETF 0x13, BANKED
108:               SLRCOND = 0xFF;
7A7C  691B     SETF 0x1B, BANKED
109:               SLRCONE = 0x07;
7A7E  0E07     MOVLW 0x7
7A80  6F23     MOVWF 0x23, BANKED
110:           
111:               /**
112:               INLVLx registers
113:               */
114:               INLVLA = 0xFF;
7A82  6904     SETF 0x4, BANKED
115:               INLVLB = 0xFF;
7A84  690C     SETF 0xC, BANKED
116:               INLVLC = 0xFF;
7A86  6914     SETF 0x14, BANKED
117:               INLVLD = 0xFF;
7A88  691C     SETF 0x1C, BANKED
118:               INLVLE = 0x0F;
7A8A  0E0F     MOVLW 0xF
7A8C  6F24     MOVWF 0x24, BANKED
119:               	
120:               RC0PPS = 0x18;   //RC0->PWM1:PWM11;    
7A8E  0E18     MOVLW 0x18
7A90  0102     MOVLB 0x2
7A92  6F11     MOVWF 0x11, BANKED
121:               PWM1ERSPPS = 0x00;   //RA0->PWM1:PWM1ERS;    
7A94  0E00     MOVLW 0x0
7A96  6F53     MOVWF 0x53, BANKED
122:               CCP2PPS = 0x0C;   //RB4->CCP2:CCP2;    
7A98  0E0C     MOVLW 0xC
7A9A  6F50     MOVWF 0x50, BANKED
123:               CCP3PPS = 0x0D;   //RB5->CCP3:CCP3;    
7A9C  0E0D     MOVLW 0xD
7A9E  6F51     MOVWF 0x51, BANKED
124:               RC1PPS = 0x19;   // 0x19 RC1->PWM1:PWM12;    
7AA0  0E19     MOVLW 0x19
7AA2  6F12     MOVWF 0x12, BANKED
125:               CCP1PPS = 0x0B;   //RB3->CCP1:CCP1;    
7AA4  0E0B     MOVLW 0xB
7AA6  6F4F     MOVWF 0x4F, BANKED
126:               RD0PPS = 0x1A;   // 0x1A RD0->PWM2:PWM21;    
7AA8  0E1A     MOVLW 0x1A
7AAA  6F19     MOVWF 0x19, BANKED
127:               RD1PPS = 0x1B;   //RD1->PWM2:PWM22;    
7AAC  0E1B     MOVLW 0x1B
7AAE  6F1A     MOVWF 0x1A, BANKED
128:               PWM2ERSPPS = 0x00;   //RA0->PWM2:PWM2ERS;    
7AB0  0E00     MOVLW 0x0
7AB2  6F54     MOVWF 0x54, BANKED
129:               RC6PPS = 0x20;   //RC6->UART1:TX1;    
7AB4  0E20     MOVLW 0x20
7AB6  6F17     MOVWF 0x17, BANKED
130:               U1RXPPS = 0x17;   //RC7->UART1:RX1;    
7AB8  0E17     MOVLW 0x17
7ABA  6F72     MOVWF CM1NCH, BANKED
131:           }
7ABC  0012     RETURN 0
132:             
133:           void PIN_MANAGER_IOC(void)
134:           {   
135:           }
136:           
137:           /**
138:            End of File
139:           */
---  C:/Users/C15552/Desktop/Q43_MCC_Test.X/mcc_generated_files/mcc.c  ----------------------------------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.00 and above or later
21:                    MPLAB             :  MPLAB X 5.10
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
51:            {
52:                INTERRUPT_Initialize();
8508  EC5D     CALL 0x86BA, 0
850A  F043     NOP
53:                PMD_Initialize();
850C  ECCB     CALL 0x8596, 0
850E  F042     NOP
54:                PIN_MANAGER_Initialize();
8510  EC0B     CALL 0x7A16, 0
8512  F03D     NOP
55:                OSCILLATOR_Initialize();
8514  ECEA     CALL 0x85D4, 0
8516  F042     NOP
56:                CCP2_Initialize();
8518  EC36     CALL 0x846C, 0
851A  F042     NOP
57:                CCP3_Initialize();
851C  EC1C     CALL 0x8438, 0
851E  F042     NOP
58:                ADCC_Initialize();
8520  EC64     CALL 0x80C8, 0
8522  F040     NOP
59:                CCP1_Initialize();
8524  EC50     CALL 0x84A0, 0
8526  F042     NOP
60:                TMR1_Initialize();
8528  EC7F     CALL 0x82FE, 0
852A  F041     NOP
61:                UART1_Initialize();
852C  EC11     CALL 0x7E22, 0
852E  F03F     NOP
62:                PWM1_Initialize();
8530  ECFD     CALL 0x83FA, 0
8532  F041     NOP
63:                PWM2_Initialize();
8534  ECDE     CALL 0x83BC, 0
8536  F041     NOP
64:            }
8538  0012     RETURN 0
65:            
66:            void OSCILLATOR_Initialize(void)
67:            {
68:                // NOSC HFINTOSC @ 64 MHz; NDIV 1; 
69:                OSCCON1 = 0x00;
85D4  0E00     MOVLW 0x0
85D6  0100     MOVLB 0x0
85D8  6FAD     MOVWF OSCCON1, BANKED
70:                // CSWHOLD may proceed; SOSCPWR Low power; 
71:                OSCCON3 = 0x00;
85DA  0E00     MOVLW 0x0
85DC  6FAF     MOVWF OSCCON3, BANKED
72:                // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
73:                OSCEN = 0x00;
85DE  0E00     MOVLW 0x0
85E0  6FB3     MOVWF OSCEN, BANKED
74:                // HFFRQ 64_MHz; 
75:                OSCFRQ = 0x08;
85E2  0E08     MOVLW 0x8
85E4  6FB1     MOVWF OSCFRQ, BANKED
76:                // TUN 0; 
77:                OSCTUNE = 0x00;
85E6  0E00     MOVLW 0x0
85E8  6FB0     MOVWF OSCTUNE, BANKED
78:            }
85EA  0012     RETURN 0
79:            
80:            void PMD_Initialize(void)
81:            {
82:                // CLKRMD CLKR enabled; SYSCMD SYSCLK enabled; SCANMD SCANNER enabled; FVRMD FVR enabled; IOCMD IOC enabled; CRCMD CRC enabled; HLVDMD HLVD enabled; NVMMD NVM enabled; 
83:                PMD0 = 0x00;
8596  0E00     MOVLW 0x0
8598  0100     MOVLB 0x0
859A  6F60     MOVWF PMD0, BANKED
84:                // TMR0MD TMR0 enabled; TMR1MD TMR1 enabled; TMR4MD TMR4 enabled; SMT1MD SMT1 enabled; TMR5MD TMR5 enabled; TMR2MD TMR2 enabled; TMR3MD TMR3 enabled; TMR6MD TMR6 enabled; 
85:                PMD1 = 0x00;
859C  0E00     MOVLW 0x0
859E  6F61     MOVWF PMD1, BANKED
86:                // ZCDMD ZCD enabled; ADCMD ADC enabled; ACTMD ACT enabled; CM2MD CM2 enabled; CM1MD CM1 enabled; DAC1MD DAC1 enabled; 
87:                PMD3 = 0x00;
85A0  0E00     MOVLW 0x0
85A2  6F63     MOVWF PMD3, BANKED
88:                // NCO1MD NCO1 enabled; NCO2MD NCO2 enabled; DSM1MD DSM1 enabled; CWG3MD CWG3 enabled; CWG2MD CWG2 enabled; CWG1MD CWG1 enabled; NCO3MD NCO3 enabled; 
89:                PMD4 = 0x00;
85A4  0E00     MOVLW 0x0
85A6  6F64     MOVWF PMD4, BANKED
90:                // CCP2MD CCP2 enabled; CCP1MD CCP1 enabled; PWM2MD PWM2 enabled; CCP3MD CCP3 enabled; PWM1MD PWM1 enabled; PWM3MD PWM3 enabled; 
91:                PMD5 = 0x00;
85A8  0E00     MOVLW 0x0
85AA  6F65     MOVWF PMD5, BANKED
92:                // U5MD EUSART5 enabled; U4MD EUSART4 enabled; U3MD EUSART3 enabled; U2MD EUSART2 enabled; U1MD EUSART1 enabled; SPI2MD SPI2 enabled; SPI1MD SPI1 enabled; I2C1MD I2C1 enabled; 
93:                PMD6 = 0x00;
85AC  0E00     MOVLW 0x0
85AE  6F66     MOVWF PMD6, BANKED
94:                // CLC5MD CLC5 enabled; CLC6MD CLC6 enabled; CLC3MD CLC3 enabled; CLC4MD CLC4 enabled; CLC7MD CLC7 enabled; CLC8MD CLC8 enabled; CLC1MD CLC1 enabled; CLC2MD CLC2 enabled; 
95:                PMD7 = 0x00;
85B0  0E00     MOVLW 0x0
85B2  6F67     MOVWF PMD7, BANKED
96:                // DMA5MD DMA5 enabled; DMA6MD DMA6 enabled; DMA1MD DMA1 enabled; DMA2MD DMA2 enabled; DMA3MD DMA3 enabled; DMA4MD DMA4 enabled; 
97:                PMD8 = 0x00;
85B4  0E00     MOVLW 0x0
85B6  6F68     MOVWF PMD8, BANKED
98:            }
85B8  0012     RETURN 0
99:            
100:           
101:           /**
102:            End of File
103:           */
---  C:/Users/C15552/Desktop/Q43_MCC_Test.X/mcc_generated_files/interrupt_manager.c  --------------------
1:             /**
2:               Generated Interrupt Manager Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.c
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
19:                    Device            :  PIC18F47Q43
20:                    Driver Version    :  2.03
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 2.00 and above or later
23:                    MPLAB 	          :  MPLAB X 5.10
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "interrupt_manager.h"
50:            #include "mcc.h"
51:            
52:            void  INTERRUPT_Initialize (void)
53:            {
54:                // Disable Interrupt Priority Vectors (16CXXX Compatibility Mode)
55:                INTCON0bits.IPEN = 0;
86BA  9AD6     BCF 0xFD6, 5, ACCESS
56:            }
86BC  0012     RETURN 0
57:            
58:            void __interrupt() INTERRUPT_InterruptManager (void)
59:            {
60:                // interrupt handler
61:                if(PIE11bits.CCP3IE == 1 && PIR11bits.CCP3IF == 1)
7B56  A0A9     BTFSS 0xFA9, 0, ACCESS
7B58  EFB0     GOTO 0x7B60
7B5A  F03D     NOP
7B5C  EFB2     GOTO 0x7B64
7B5E  F03D     NOP
7B60  EFBD     GOTO 0x7B7A
7B62  F03D     NOP
7B64  A0B9     BTFSS 0xFB9, 0, ACCESS
7B66  EFB7     GOTO 0x7B6E
7B68  F03D     NOP
7B6A  EFB9     GOTO 0x7B72
7B6C  F03D     NOP
7B6E  EFBD     GOTO 0x7B7A
7B70  F03D     NOP
62:                {
63:                    CCP3_CaptureISR();
7B72  ECF4     CALL 0x7BE8, 0
7B74  F03D     NOP
64:                }
7B76  EFF3     GOTO 0x7BE6
7B78  F03D     NOP
65:                else if(PIE2bits.ADTIE == 1 && PIR2bits.ADTIF == 1)
7B7A  A0A0     BTFSS 0xFA0, 0, ACCESS
7B7C  EFC2     GOTO 0x7B84
7B7E  F03D     NOP
7B80  EFC4     GOTO 0x7B88
7B82  F03D     NOP
7B84  EFCF     GOTO 0x7B9E
7B86  F03D     NOP
7B88  A0B0     BTFSS 0xFB0, 0, ACCESS
7B8A  EFC9     GOTO 0x7B92
7B8C  F03D     NOP
7B8E  EFCB     GOTO 0x7B96
7B90  F03D     NOP
7B92  EFCF     GOTO 0x7B9E
7B94  F03D     NOP
66:                {
67:                    ADCC_ThresholdISR();
7B96  EC6A     CALL 0x84D4, 0
7B98  F042     NOP
68:                }
7B9A  EFF3     GOTO 0x7BE6
7B9C  F03D     NOP
69:                else if(PIE8bits.CCP2IE == 1 && PIR8bits.CCP2IF == 1)
7B9E  ACA6     BTFSS 0xFA6, 6, ACCESS
7BA0  EFD4     GOTO 0x7BA8
7BA2  F03D     NOP
7BA4  EFD6     GOTO 0x7BAC
7BA6  F03D     NOP
7BA8  EFE1     GOTO 0x7BC2
7BAA  F03D     NOP
7BAC  ACB6     BTFSS 0xFB6, 6, ACCESS
7BAE  EFDB     GOTO 0x7BB6
7BB0  F03D     NOP
7BB2  EFDD     GOTO 0x7BBA
7BB4  F03D     NOP
7BB6  EFE1     GOTO 0x7BC2
7BB8  F03D     NOP
70:                {
71:                    CCP2_CaptureISR();
7BBA  EC3C     CALL 0x7C78, 0
7BBC  F03E     NOP
72:                }
7BBE  EFF3     GOTO 0x7BE6
7BC0  F03D     NOP
73:                else if(PIE3bits.CCP1IE == 1 && PIR3bits.CCP1IF == 1)
7BC2  ACA1     BTFSS 0xFA1, 6, ACCESS
7BC4  EFE6     GOTO 0x7BCC
7BC6  F03D     NOP
7BC8  EFE8     GOTO 0x7BD0
7BCA  F03D     NOP
7BCC  EFF3     GOTO 0x7BE6
7BCE  F03D     NOP
7BD0  ACB1     BTFSS 0xFB1, 6, ACCESS
7BD2  EFED     GOTO 0x7BDA
7BD4  F03D     NOP
7BD6  EFEF     GOTO 0x7BDE
7BD8  F03D     NOP
7BDA  EFF3     GOTO 0x7BE6
7BDC  F03D     NOP
74:                {
75:                    CCP1_CaptureISR();
7BDE  EC84     CALL 0x7D08, 0
7BE0  F03E     NOP
76:                }
7BE2  EFF3     GOTO 0x7BE6
7BE4  F03D     NOP
77:                else
78:                {
79:                    //Unhandled Interrupt
80:                }
81:            }
7BE6  0011     RETFIE 1
82:            /**
83:             End of File
84:            */
---  C:/Users/C15552/Desktop/Q43_MCC_Test.X/mcc_generated_files/ccp3.c  ---------------------------------
1:             /**
2:               CCP3 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 ccp3.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the CCP3 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides implementations for driver APIs for CCP3.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.1.3
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.00 and above
21:                     MPLAB 	          :  MPLAB X 5.10
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "ccp3.h"
53:            
54:            #define TIMER_CONST    3750000                                                  // 2 pulses per rev (Freq / TimerPrescaler) * (60 / pulses per rev) = (1 MHz / 8) * (60 / 2)
55:            
56:            static void (*CCP3_CallBack)(uint16_t);
57:            
58:            /**
59:              Section: Capture Module APIs:
60:            */
61:            
62:            static void CCP3_DefaultCallBack(uint16_t capturedValue)
63:            {
64:                // Add your code here
65:            }
66:            
67:            void CCP3_Initialize(void)
68:            {
69:                // Set the CCP3 to the options selected in the User Interface
70:            	
71:            	// MODE 4th rising edge; EN enabled; FMT right_aligned; 
72:            	CCP3CON = 0x86;    
8438  0E86     MOVLW 0x86
843A  0103     MOVLB 0x3
843C  6F4A     MOVWF HLVDCON0, BANKED
73:            	
74:            	// CCP3CTS CCP3 pin; 
75:            	CCP3CAP = 0x00;    
843E  0E00     MOVLW 0x0
8440  6F4B     MOVWF HLVDCON1, BANKED
76:            	
77:            	// RH 0; 
78:            	CCPR3H = 0x00;    
8442  0E00     MOVLW 0x0
8444  6F49     MOVWF BORCON, BANKED
79:            	
80:            	// RL 0; 
81:            	CCPR3L = 0x00;    
8446  0E00     MOVLW 0x0
8448  6F48     MOVWF VREGCON, BANKED
82:                
83:                // Set the default call back function for CCP3
84:                CCP3_SetCallBack(CCP3_DefaultCallBack);
844A  0E00     MOVLW 0x0
844C  0106     MOVLB 0x6
844E  6F00     MOVWF txData, BANKED
8450  0E00     MOVLW 0x0
8452  6F01     MOVWF 0x1, BANKED
8454  0E00     MOVLW 0x0
8456  6F02     MOVWF 0x2, BANKED
8458  EC1F     CALL 0x863E, 0
845A  F043     NOP
85:            
86:            	// Selecting Timer 1
87:            	CCPTMRS0bits.C3TSEL = 0x1;
845C  0103     MOVLB 0x3
845E  514C     MOVF ZCDCON, W, BANKED
8460  0BCF     ANDLW 0xCF
8462  0910     IORLW 0x10
8464  6F4C     MOVWF ZCDCON, BANKED
88:                
89:                // Clear the CCP3 interrupt flag
90:                PIR11bits.CCP3IF = 0;
8466  90B9     BCF 0xFB9, 0, ACCESS
91:            
92:                // Enable the CCP3 interrupt
93:                PIE11bits.CCP3IE = 1;
8468  80A9     BSF 0xFA9, 0, ACCESS
94:            }
846A  0012     RETURN 0
95:            
96:            void CCP3_CaptureISR(void)
97:            {
98:                CCP3_PERIOD_REG_T module;
99:                   
100:               module.ccpr3l = CCPR3L;                                                     // Copy captured value.
7BEA  FD20     NOP
7BEC  F511     NOP
101:               module.ccpr3h = CCPR3H;
7BF0  FD24     NOP
7BF2  F512     NOP
102:               
103:               // Return 16bit captured value
104:               //CCP3_CallBack(module.ccpr3_16Bit);
105:               
106:               prevCapt3 = currentCapt3;
7BF4  C5D8     MOVFF currentCapt3, prevCapt3
7BF6  F5DA     NOP
7BF8  C5D9     MOVFF 0x5D9, 0x5DB
7BFA  F5DB     NOP
107:               currentCapt3 = module.ccpr3_16Bit;
7BFE  F444     NOP
7C00  F5D8     NOP
7C04  F448     NOP
7C06  F5D9     NOP
108:               
109:               if(currentCapt3 > prevCapt3)
7C08  0105     MOVLB 0x5
7C0A  51D8     MOVF CLCxSEL0, W, BANKED
7C0C  5DDA     SUBWF CLCxSEL2, W, BANKED
7C0E  51D9     MOVF CLCxSEL1, W, BANKED
7C10  59DB     SUBWFB CLCxSEL3, W, BANKED
7C12  B0D8     BTFSC 0xFD8, 0, ACCESS
7C14  EF0E     GOTO 0x7C1C
7C16  F03E     NOP
7C18  EF10     GOTO 0x7C20
7C1A  F03E     NOP
7C1C  EF18     GOTO 0x7C30
7C1E  F03E     NOP
110:               {
111:                   fan3_tmr_val = currentCapt3 - prevCapt3;
7C20  51DA     MOVF CLCxSEL2, W, BANKED
7C22  5DD8     SUBWF CLCxSEL0, W, BANKED
7C24  6FD0     MOVWF 0xD0, BANKED
7C26  51DB     MOVF CLCxSEL3, W, BANKED
7C28  59D9     SUBWFB CLCxSEL1, W, BANKED
7C2A  6FD1     MOVWF 0xD1, BANKED
112:               }
7C2C  EF22     GOTO 0x7C44
7C2E  F03E     NOP
113:               else
114:               {
115:                   fan3_tmr_val = (0xFFFF - prevCapt3) + currentCapt3;
7C30  1DDA     COMF CLCxSEL2, W, BANKED
7C32  6E0F     MOVWF 0xF, ACCESS
7C34  1DDB     COMF CLCxSEL3, W, BANKED
7C36  6E10     MOVWF 0x10, ACCESS
7C38  51D8     MOVF CLCxSEL0, W, BANKED
7C3A  240F     ADDWF 0xF, W, ACCESS
7C3C  6FD0     MOVWF 0xD0, BANKED
7C3E  51D9     MOVF CLCxSEL1, W, BANKED
7C40  2010     ADDWFC 0x10, W, ACCESS
7C42  6FD1     MOVWF 0xD1, BANKED
116:               }
117:               
118:               fan3_spd = TIMER_CONST / fan3_tmr_val;
7C44  0E70     MOVLW 0x70
7C46  6E01     MOVWF 0x1, ACCESS
7C48  0E38     MOVLW 0x38
7C4A  6E02     MOVWF 0x2, ACCESS
7C4C  0E39     MOVLW 0x39
7C4E  6E03     MOVWF 0x3, ACCESS
7C50  0E00     MOVLW 0x0
7C52  6E04     MOVWF 0x4, ACCESS
7C56  F740     NOP
7C58  F505     NOP
7C5C  F744     NOP
7C5E  F506     NOP
7C60  6A07     CLRF 0x7, ACCESS
7C62  6A08     CLRF 0x8, ACCESS
7C64  ECF3     CALL 0x73E6, 0
7C66  F039     NOP
7C6A  F404     NOP
7C6C  F6B9     NOP
7C70  F408     NOP
7C72  F6BA     NOP
119:               
120:               PIR11bits.CCP3IF = 0;
7C74  90B9     BCF 0xFB9, 0, ACCESS
121:           }
7C76  0012     RETURN 0
122:           
123:           void CCP3_SetCallBack(void (*customCallBack)(uint16_t)){
124:               CCP3_CallBack = customCallBack;
8640  F800     NOP
8642  F6C7     NOP
8646  F804     NOP
8648  F6C8     NOP
864C  F808     NOP
864E  F6C9     NOP
125:           }
8650  0012     RETURN 0
126:           /**
127:            End of File
128:           */
---  C:/Users/C15552/Desktop/Q43_MCC_Test.X/mcc_generated_files/ccp2.c  ---------------------------------
1:             /**
2:               CCP2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 ccp2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the CCP2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides implementations for driver APIs for CCP2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.1.3
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.00 and above
21:                     MPLAB 	          :  MPLAB X 5.10
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "ccp2.h"
53:            
54:            #define TIMER_CONST    3750000                                                  // 2 pulses per rev (Freq / TimerPrescaler) * (60 / pulses per rev) = (1 MHz / 8) * (60 / 2)
55:            
56:            static void (*CCP2_CallBack)(uint16_t);
57:            
58:            /**
59:              Section: Capture Module APIs:
60:            */
61:            
62:            static void CCP2_DefaultCallBack(uint16_t capturedValue)
63:            {
64:                // Add your code here
65:            }
66:            
67:            void CCP2_Initialize(void)
68:            {
69:                // Set the CCP2 to the options selected in the User Interface
70:            	
71:            	// MODE 4th rising edge; EN enabled; FMT right_aligned; 
72:            	CCP2CON = 0x86;    
846C  0E86     MOVLW 0x86
846E  0103     MOVLB 0x3
8470  6F46     MOVWF NVMDAT, BANKED
73:            	
74:            	// CCP2CTS CCP2 pin; 
75:            	CCP2CAP = 0x00;    
8472  0E00     MOVLW 0x0
8474  6F47     MOVWF NVMDATH, BANKED
76:            	
77:            	// RH 0; 
78:            	CCPR2H = 0x00;    
8476  0E00     MOVLW 0x0
8478  6F45     MOVWF NVMADRU, BANKED
79:            	
80:            	// RL 0; 
81:            	CCPR2L = 0x00;    
847A  0E00     MOVLW 0x0
847C  6F44     MOVWF NVMADRH, BANKED
82:                
83:                // Set the default call back function for CCP2
84:                CCP2_SetCallBack(CCP2_DefaultCallBack);
847E  0E00     MOVLW 0x0
8480  0106     MOVLB 0x6
8482  6F00     MOVWF txData, BANKED
8484  0E00     MOVLW 0x0
8486  6F01     MOVWF 0x1, BANKED
8488  0E00     MOVLW 0x0
848A  6F02     MOVWF 0x2, BANKED
848C  EC29     CALL 0x8652, 0
848E  F043     NOP
85:            
86:            	// Selecting Timer 1
87:            	CCPTMRS0bits.C2TSEL = 0x1;
8490  0103     MOVLB 0x3
8492  514C     MOVF ZCDCON, W, BANKED
8494  0BF3     ANDLW 0xF3
8496  0904     IORLW 0x4
8498  6F4C     MOVWF ZCDCON, BANKED
88:                
89:                // Clear the CCP2 interrupt flag
90:                PIR8bits.CCP2IF = 0;
849A  9CB6     BCF 0xFB6, 6, ACCESS
91:            
92:                // Enable the CCP2 interrupt
93:                PIE8bits.CCP2IE = 1;
849C  8CA6     BSF 0xFA6, 6, ACCESS
94:            }
849E  0012     RETURN 0
95:            
96:            void CCP2_CaptureISR(void)
97:            {
98:                CCP2_PERIOD_REG_T module;
99:                   
100:               module.ccpr2l = CCPR2L;                                                     // Copy captured value.
7C7A  FD10     NOP
7C7C  F511     NOP
101:               module.ccpr2h = CCPR2H;
7C80  FD14     NOP
7C82  F512     NOP
102:               
103:               // Return 16bit captured value
104:               //CCP2_CallBack(module.ccpr2_16Bit);
105:               
106:               prevCapt2 = currentCapt2;
7C84  C5DC     MOVFF currentCapt2, prevCapt2
7C86  F5DE     NOP
7C88  C5DD     MOVFF 0x5DD, 0x5DF
7C8A  F5DF     NOP
107:               currentCapt2 = module.ccpr2_16Bit;
7C8E  F444     NOP
7C90  F5DC     NOP
7C94  F448     NOP
7C96  F5DD     NOP
108:               
109:               if(currentCapt2 > prevCapt2)
7C98  0105     MOVLB 0x5
7C9A  51DC     MOVF CLCxGLS0, W, BANKED
7C9C  5DDE     SUBWF CLCxGLS2, W, BANKED
7C9E  51DD     MOVF CLCxGLS1, W, BANKED
7CA0  59DF     SUBWFB CLCxGLS3, W, BANKED
7CA2  B0D8     BTFSC 0xFD8, 0, ACCESS
7CA4  EF56     GOTO 0x7CAC
7CA6  F03E     NOP
7CA8  EF58     GOTO 0x7CB0
7CAA  F03E     NOP
7CAC  EF60     GOTO 0x7CC0
7CAE  F03E     NOP
110:               {
111:                   fan2_tmr_val = currentCapt2 - prevCapt2;
7CB0  51DE     MOVF CLCxGLS2, W, BANKED
7CB2  5DDC     SUBWF CLCxGLS0, W, BANKED
7CB4  6FD2     MOVWF 0xD2, BANKED
7CB6  51DF     MOVF CLCxGLS3, W, BANKED
7CB8  59DD     SUBWFB CLCxGLS1, W, BANKED
7CBA  6FD3     MOVWF 0xD3, BANKED
112:               }
7CBC  EF6A     GOTO 0x7CD4
7CBE  F03E     NOP
113:               else
114:               {
115:                   fan2_tmr_val = (0xFFFF - prevCapt2) + currentCapt2;
7CC0  1DDE     COMF CLCxGLS2, W, BANKED
7CC2  6E0F     MOVWF 0xF, ACCESS
7CC4  1DDF     COMF CLCxGLS3, W, BANKED
7CC6  6E10     MOVWF 0x10, ACCESS
7CC8  51DC     MOVF CLCxGLS0, W, BANKED
7CCA  240F     ADDWF 0xF, W, ACCESS
7CCC  6FD2     MOVWF 0xD2, BANKED
7CCE  51DD     MOVF CLCxGLS1, W, BANKED
7CD0  2010     ADDWFC 0x10, W, ACCESS
7CD2  6FD3     MOVWF 0xD3, BANKED
116:               }
117:               
118:               fan2_spd = TIMER_CONST / fan2_tmr_val;
7CD4  0E70     MOVLW 0x70
7CD6  6E01     MOVWF 0x1, ACCESS
7CD8  0E38     MOVLW 0x38
7CDA  6E02     MOVWF 0x2, ACCESS
7CDC  0E39     MOVLW 0x39
7CDE  6E03     MOVWF 0x3, ACCESS
7CE0  0E00     MOVLW 0x0
7CE2  6E04     MOVWF 0x4, ACCESS
7CE6  F748     NOP
7CE8  F505     NOP
7CEC  F74C     NOP
7CEE  F506     NOP
7CF0  6A07     CLRF 0x7, ACCESS
7CF2  6A08     CLRF 0x8, ACCESS
7CF4  ECF3     CALL 0x73E6, 0
7CF6  F039     NOP
7CFA  F404     NOP
7CFC  F6BB     NOP
7D00  F408     NOP
7D02  F6BC     NOP
119:               
120:               PIR8bits.CCP2IF = 0;
7D04  9CB6     BCF 0xFB6, 6, ACCESS
121:           }
7D06  0012     RETURN 0
122:           
123:           void CCP2_SetCallBack(void (*customCallBack)(uint16_t)){
124:               CCP2_CallBack = customCallBack;
8654  F800     NOP
8656  F6CA     NOP
865A  F804     NOP
865C  F6CB     NOP
8660  F808     NOP
8662  F6CC     NOP
125:           }
8664  0012     RETURN 0
126:           /**
127:            End of File
128:           */
---  C:/Users/C15552/Desktop/Q43_MCC_Test.X/mcc_generated_files/ccp1.c  ---------------------------------
1:             /**
2:               CCP1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 ccp1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the CCP1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides implementations for driver APIs for CCP1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.1.3
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.00 and above
21:                     MPLAB 	          :  MPLAB X 5.10
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include <stdio.h>
53:            #include "ccp1.h"
54:            
55:            #define TIMER_CONST    3750000                                                  // 2 pulses per rev (Freq / TimerPrescaler) * (60 / pulses per rev) = (1 MHz / 8) * (60 / 2)
56:                   
57:            
58:            static void (*CCP1_CallBack)(uint16_t);
59:            
60:            /**
61:              Section: Capture Module APIs:
62:            */
63:            
64:            static void CCP1_DefaultCallBack(uint16_t capturedValue)
65:            {
66:                
67:            }
68:            
69:            void CCP1_Initialize(void)
70:            {
71:                // Set the CCP1 to the options selected in the User Interface
72:            	
73:            	// MODE 4th rising edge; EN enabled; FMT right_aligned; 
74:            	CCP1CON = 0x86;    
84A0  0E86     MOVLW 0x86
84A2  0103     MOVLB 0x3
84A4  6F42     MOVWF NVMLOCK, BANKED
75:            	
76:            	// CCP1CTS CCP1 pin; 
77:            	CCP1CAP = 0x00;    
84A6  0E00     MOVLW 0x0
84A8  6F43     MOVWF NVMADR, BANKED
78:            	
79:            	// RH 0; 
80:            	CCPR1H = 0x00;    
84AA  0E00     MOVLW 0x0
84AC  6F41     MOVWF NVMCON1, BANKED
81:            	
82:            	// RL 0; 
83:            	CCPR1L = 0x00;    
84AE  0E00     MOVLW 0x0
84B0  6F40     MOVWF NVMCON0, BANKED
84:                
85:                // Set the default call back function for CCP1
86:                CCP1_SetCallBack(CCP1_DefaultCallBack);
84B2  0E00     MOVLW 0x0
84B4  0106     MOVLB 0x6
84B6  6F00     MOVWF txData, BANKED
84B8  0E00     MOVLW 0x0
84BA  6F01     MOVWF 0x1, BANKED
84BC  0E00     MOVLW 0x0
84BE  6F02     MOVWF 0x2, BANKED
84C0  EC33     CALL 0x8666, 0
84C2  F043     NOP
87:            
88:            	// Selecting Timer 1
89:            	CCPTMRS0bits.C1TSEL = 0x1;
84C4  0103     MOVLB 0x3
84C6  514C     MOVF ZCDCON, W, BANKED
84C8  0BFC     ANDLW 0xFC
84CA  0901     IORLW 0x1
84CC  6F4C     MOVWF ZCDCON, BANKED
90:                
91:                // Clear the CCP1 interrupt flag
92:                PIR3bits.CCP1IF = 0;
84CE  9CB1     BCF 0xFB1, 6, ACCESS
93:            
94:                // Enable the CCP1 interrupt
95:                PIE3bits.CCP1IE = 1;
84D0  8CA1     BSF 0xFA1, 6, ACCESS
96:            }
84D2  0012     RETURN 0
97:            
98:            void CCP1_CaptureISR(void)
99:            {
100:               CCP1_PERIOD_REG_T module;
101:                   
102:               module.ccpr1l = CCPR1L;                                                     // Copy captured value.
7D0A  FD00     NOP
7D0C  F511     NOP
103:               module.ccpr1h = CCPR1H;
7D10  FD04     NOP
7D12  F512     NOP
104:               
105:               // Return 16bit captured value
106:               //CCP1_CallBack(module.ccpr1_16Bit);
107:               
108:               prevCapt1 = currentCapt1;
7D14  C5D4     MOVFF currentCapt1, prevCapt1
7D16  F5D6     NOP
7D18  C5D5     MOVFF 0x5D5, 0x5D7
7D1A  F5D7     NOP
109:               currentCapt1 = module.ccpr1_16Bit;
7D1E  F444     NOP
7D20  F5D4     NOP
7D24  F448     NOP
7D26  F5D5     NOP
110:               
111:               if(currentCapt1 > prevCapt1)
7D28  0105     MOVLB 0x5
7D2A  51D4     MOVF CLCDATA, W, BANKED
7D2C  5DD6     SUBWF CLCxCON, W, BANKED
7D2E  51D5     MOVF CLCSELECT, W, BANKED
7D30  59D7     SUBWFB CLCxPOL, W, BANKED
7D32  B0D8     BTFSC 0xFD8, 0, ACCESS
7D34  EF9E     GOTO 0x7D3C
7D36  F03E     NOP
7D38  EFA0     GOTO 0x7D40
7D3A  F03E     NOP
7D3C  EFA8     GOTO 0x7D50
7D3E  F03E     NOP
112:               {
113:                   fan1_tmr_val = currentCapt1 - prevCapt1;
7D40  51D6     MOVF CLCxCON, W, BANKED
7D42  5DD4     SUBWF CLCDATA, W, BANKED
7D44  6FCE     MOVWF 0xCE, BANKED
7D46  51D7     MOVF CLCxPOL, W, BANKED
7D48  59D5     SUBWFB CLCSELECT, W, BANKED
7D4A  6FCF     MOVWF 0xCF, BANKED
114:               }
7D4C  EFB2     GOTO 0x7D64
7D4E  F03E     NOP
115:               else
116:               {
117:                   fan1_tmr_val = (0xFFFF - prevCapt1) + currentCapt1;
7D50  1DD6     COMF CLCxCON, W, BANKED
7D52  6E0F     MOVWF 0xF, ACCESS
7D54  1DD7     COMF CLCxPOL, W, BANKED
7D56  6E10     MOVWF 0x10, ACCESS
7D58  51D4     MOVF CLCDATA, W, BANKED
7D5A  240F     ADDWF 0xF, W, ACCESS
7D5C  6FCE     MOVWF 0xCE, BANKED
7D5E  51D5     MOVF CLCSELECT, W, BANKED
7D60  2010     ADDWFC 0x10, W, ACCESS
7D62  6FCF     MOVWF 0xCF, BANKED
118:               }
119:               
120:               fan1_spd = TIMER_CONST / fan1_tmr_val;
7D64  0E70     MOVLW 0x70
7D66  6E01     MOVWF 0x1, ACCESS
7D68  0E38     MOVLW 0x38
7D6A  6E02     MOVWF 0x2, ACCESS
7D6C  0E39     MOVLW 0x39
7D6E  6E03     MOVWF 0x3, ACCESS
7D70  0E00     MOVLW 0x0
7D72  6E04     MOVWF 0x4, ACCESS
7D76  F738     NOP
7D78  F505     NOP
7D7C  F73C     NOP
7D7E  F506     NOP
7D80  6A07     CLRF 0x7, ACCESS
7D82  6A08     CLRF 0x8, ACCESS
7D84  ECF3     CALL 0x73E6, 0
7D86  F039     NOP
7D8A  F404     NOP
7D8C  F6B7     NOP
7D90  F408     NOP
7D92  F6B8     NOP
121:               
122:               PIR3bits.CCP1IF = 0;
7D94  9CB1     BCF 0xFB1, 6, ACCESS
123:           }
7D96  0012     RETURN 0
124:           
125:           void CCP1_SetCallBack(void (*customCallBack)(uint16_t)){
126:               CCP1_CallBack = customCallBack;
8668  F800     NOP
866A  F6CD     NOP
866E  F804     NOP
8670  F6CE     NOP
8674  F808     NOP
8676  F6CF     NOP
127:           }
8678  0012     RETURN 0
128:           /**
129:            End of File
130:           */
---  C:/Users/C15552/Desktop/Q43_MCC_Test.X/mcc_generated_files/adcc.c  ---------------------------------
1:             /**
2:               ADCC Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 adcc.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the ADCC driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides implementations for driver APIs for ADCC.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.1.4
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.00 and above
21:                    MPLAB             :  MPLAB X 5.10
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            
48:            #include <xc.h>
49:            #include <math.h>
50:            #include <float.h>
51:            #include <stdio.h>
52:            #include <stdlib.h>
53:            #include "adcc.h"
54:            
55:            #define MAXADC          4095.000                                                // 12-Bit ADCC
56:            #define K               273.1500                                                // Kelvin constant
57:            #define LN              0.4343                                                  // Log(e)
58:            
59:            
60:            void (*ADCC_ADTI_InterruptHandler)(void);
61:            
62:            /**
63:              Section: ADCC Module APIs
64:            */
65:            
66:            void ADCC_Initialize(void)
67:            {
68:                ADLTHL = 0x32;                                                              // Lower threshold set at 50 (0x0032)
80C8  0E32     MOVLW 0x32
80CA  0103     MOVLB 0x3
80CC  6FD9     MOVWF CLCxSEL1, BANKED
69:                ADLTHH = 0x00; 
80CE  0E00     MOVLW 0x0
80D0  6FDA     MOVWF CLCxSEL2, BANKED
70:                ADUTHL = 0xD2;                                                              // Upper threshold set at 4050 (0x0FD2)
80D2  0ED2     MOVLW 0xD2
80D4  6FDB     MOVWF CLCxSEL3, BANKED
71:                ADUTHH = 0x0F;
80D6  0E0F     MOVLW 0xF
80D8  6FDC     MOVWF CLCxGLS0, BANKED
72:                ADSTPTL = 0x00;                                                             // Setpoint set to 0
80DA  0E00     MOVLW 0x0
80DC  6FDF     MOVWF CLCxGLS3, BANKED
73:                ADSTPTH = 0x00;
80DE  0E00     MOVLW 0x0
80E0  6FE0     MOVWF 0xE0, BANKED
74:                ADACCU = 0x00;   
80E2  0E00     MOVLW 0x0
80E4  6FE5     MOVWF 0xE5, BANKED
75:                ADRPT = 0x10;                                                               // Set for 16 samples
80E6  0E10     MOVLW 0x10
80E8  6FE7     MOVWF 0xE7, BANKED
76:                ADPCH = 0x00;    
80EA  0E00     MOVLW 0x0
80EC  6FEC     MOVWF DMAxDPTR, BANKED
77:                ADCON1 = 0x00;                                                              // ADDSEN disabled; ADGPOL digital_low; ADIPEN disabled; ADPPOL Vss;     
80EE  0E00     MOVLW 0x0
80F0  6FF4     MOVWF DMAxSPTR, BANKED
78:                ADCON2 = 0xA3;                                                              // ADCRS 4; ADMD Burst_average_mode; ADACLR disabled; ADPSIS RES;     
80F2  0EA3     MOVLW 0xA3
80F4  6FF5     MOVWF DMAxSPTRH, BANKED
79:                ADCON3 = 0x57;                                                              // ADCALC Filtered value vs setpoint; ADTMD disabled; ADSOI ADGO not cleared;
80F6  0E57     MOVLW 0x57
80F8  6FF6     MOVWF DMAxSPTRU, BANKED
80:                ADSTAT = 0x00;   
80FA  0E00     MOVLW 0x0
80FC  6FF7     MOVWF DMAxSSZ, BANKED
81:                ADREF = 0x00;                                                               // ADNREF VSS; ADPREF VDD;     
80FE  0E00     MOVLW 0x0
8100  6FF8     MOVWF DMAxSSZH, BANKED
82:                ADACT = 0x05;                                                               // ADACT TMR3_overflow;     
8102  0E05     MOVLW 0x5
8104  6FF9     MOVWF DMAxSSA, BANKED
83:                ADCLK = 0x3F;                                                               // ADCS FOSC/128;   
8106  0E3F     MOVLW 0x3F
8108  6FFA     MOVWF DMAxSSAH, BANKED
84:                ADCON0 = 0x84;                                                              // ADGO stop; ADFM right; ADON enabled; ADCS FOSC/ADCLK; ADCONT disabled; 
810A  0E84     MOVLW 0x84
810C  6FF3     MOVWF DMAxSCNTH, BANKED
85:                   
86:                PIR2bits.ADTIF = 0;                                                         // Clear the ADC Threshold interrupt flag    
810E  90B0     BCF 0xFB0, 0, ACCESS
87:                PIE2bits.ADTIE = 1;                                                         // Enabling ADCC threshold interrupt.
8110  80A0     BSF 0xFA0, 0, ACCESS
88:            
89:                ADCC_SetADTIInterruptHandler(ADCC_DefaultInterruptHandler);
8112  0E4A     MOVLW 0x4A
8114  0106     MOVLB 0x6
8116  6F00     MOVWF txData, BANKED
8118  0E67     MOVLW 0x67
811A  6F01     MOVWF 0x1, BANKED
811C  0E00     MOVLW 0x0
811E  6F02     MOVWF 0x2, BANKED
8120  EC3D     CALL 0x867A, 0
8122  F043     NOP
90:            }
8124  0012     RETURN 0
91:            
92:            void ADCC_StartConversion(adcc_channel_t channel)
868E  0106     MOVLB 0x6
8690  6F00     MOVWF txData, BANKED
93:            {
94:                // select the A/D channel
95:                ADPCH = channel;      
8694  F800     NOP
8696  F3EC     NOP
96:              
97:                // Turn on the ADC module
98:                ADCON0bits.ADON = 1;
8698  0103     MOVLB 0x3
869A  8FF3     BSF DMAxSCNTH, 7, BANKED
99:            
100:               // Start the conversion
101:               ADCON0bits.ADGO = 1;
869C  81F3     BSF DMAxSCNTH, 0, BANKED
102:           }
869E  0012     RETURN 0
103:           
104:           bool ADCC_IsConversionDone()
105:           {
106:               // Start the conversion
107:               return ((unsigned char)(!ADCON0bits.ADGO));
108:           }
109:           
110:           adc_result_t ADCC_GetConversionResult(void)
111:           {
112:               // Return the result
113:               return ((adc_result_t)((ADRESH << 8) + ADRESL));
85EC  0103     MOVLB 0x3
85EE  51EB     MOVF DMAxDCNTH, W, BANKED
85F0  6E04     MOVWF 0x4, ACCESS
85F2  6A03     CLRF 0x3, ACCESS
85F4  51EA     MOVF DMAxDCNT, W, BANKED
85F6  2403     ADDWF 0x3, W, ACCESS
85F8  6E01     MOVWF 0x1, ACCESS
85FA  0E00     MOVLW 0x0
85FC  2004     ADDWFC 0x4, W, ACCESS
85FE  6E02     MOVWF 0x2, ACCESS
114:           }
8600  0012     RETURN 0
115:           
116:           adc_result_t ADCC_GetSingleConversion(adcc_channel_t channel)
117:           {
118:               // select the A/D channel
119:               ADPCH = channel;  
120:           
121:               // Turn on the ADC module
122:               ADCON0bits.ADON = 1;
123:           	
124:               //Disable the continuous mode.
125:               ADCON0bits.ADCONT = 0;    
126:           
127:               // Start the conversion
128:               ADCON0bits.ADGO = 1;
129:           
130:           
131:               // Wait for the conversion to finish
132:               while (ADCON0bits.ADGO)
133:               {
134:               }
135:               
136:               
137:               // Conversion finished, return the result
138:               return ((adc_result_t)((ADRESH << 8) + ADRESL));
139:           }
140:           
141:           void ADCC_StopConversion(void)
142:           {
143:               //Reset the ADGO bit.
144:               ADCON0bits.ADGO = 0;
145:           }
146:           
147:           void ADCC_SetStopOnInterrupt(void)
148:           {
149:               //Set the ADSOI bit.
150:               ADCON3bits.ADSOI = 1;
151:           }
152:           
153:           void ADCC_DischargeSampleCapacitor(void)
154:           {
155:               //Set the ADC channel to AVss.
156:               ADPCH = 0x3b;   
157:           }
158:           
159:           void ADCC_LoadAcquisitionRegister(uint16_t acquisitionValue)
160:           {
161:               //Load the ADACQH and ADACQL registers.
162:               ADACQH = acquisitionValue >> 8; 
163:               ADACQL = acquisitionValue;  
164:           }
165:           
166:           void ADCC_SetPrechargeTime(uint16_t prechargeTime)
167:           {
168:               //Load the ADPREH and ADPREL registers.
169:               ADPREH = prechargeTime >> 8;  
170:               ADPREL = prechargeTime;
171:           }
172:           
173:           void ADCC_SetRepeatCount(uint8_t repeatCount)
174:           {
175:               //Load the ADRPT register.
176:               ADRPT = repeatCount;   
177:           }
178:           
179:           uint8_t ADCC_GetCurrentCountofConversions(void)
180:           {
181:               //Return the contents of ADCNT register
182:               return ADCNT;
183:           }
184:           
185:           void ADCC_ClearAccumulator(void)
186:           {
187:               //Reset the ADCON2bits.ADACLR bit.
188:               ADCON2bits.ADACLR = 1;
189:           }
190:           
191:           uint24_t ADCC_GetAccumulatorValue(void)
192:           {
193:               //Return the contents of ADACCU, ADACCH and ADACCL registers
194:               return (((uint24_t)ADACCU << 16)+((uint24_t)ADACCH << 8) + ADACCL);
195:           }
196:           
197:           bool ADCC_HasAccumulatorOverflowed(void)
198:           {
199:               //Return the status of ADSTATbits.ADAOV
200:               return ADSTATbits.ADAOV;
201:           }
202:           
203:           uint16_t ADCC_GetFilterValue(void)
204:           {
205:               //Return the contents of ADFLTRH and ADFLTRL registers
206:               return ((uint16_t)((ADFLTRH << 8) + ADFLTRL));
207:           }
208:           
209:           uint16_t ADCC_GetPreviousResult(void)
210:           {
211:               //Return the contents of ADPREVH and ADPREVL registers
212:               return ((uint16_t)((ADPREVH << 8) + ADPREVL));
213:           }
214:           
215:           void ADCC_DefineSetPoint(uint16_t setPoint)
216:           {
217:               //Sets the ADSTPTH and ADSTPTL registers
218:               ADSTPTH = setPoint >> 8;
219:               ADSTPTL = setPoint;
220:           }
221:           
222:           void ADCC_SetUpperThreshold(uint16_t upperThreshold)
223:           {
224:               //Sets the ADUTHH and ADUTHL registers
225:               ADUTHH = upperThreshold >> 8;
226:               ADUTHL = upperThreshold;
227:           }
228:           
229:           void ADCC_SetLowerThreshold(uint16_t lowerThreshold)
230:           {
231:               //Sets the ADLTHH and ADLTHL registers
232:               ADLTHH = lowerThreshold >> 8;
233:               ADLTHL = lowerThreshold;
234:           }
235:           
236:           uint16_t ADCC_GetErrorCalculation(void)
237:           {
238:           	//Return the contents of ADERRH and ADERRL registers
239:           	return ((uint16_t)((ADERRH << 8) + ADERRL));
240:           }
241:           
242:           void ADCC_EnableDoubleSampling(void)
243:           {
244:               //Sets the ADCON1bits.ADDSEN
245:               ADCON1bits.ADDSEN = 1;
246:           }
247:           
248:           void ADCC_EnableContinuousConversion(void)
249:           {
250:               //Sets the ADCON0bits.ADCONT
251:               ADCON0bits.ADCONT = 1;
252:           }
253:           
254:           void ADCC_DisableContinuousConversion(void)
255:           {
256:               //Resets the ADCON0bits.ADCONT
257:               ADCON0bits.ADCONT = 0;
258:           }
259:           
260:           bool ADCC_HasErrorCrossedUpperThreshold(void)
261:           {
262:               //Returns the value of ADSTATbits.ADUTHR bit.
263:               return ADSTATbits.ADUTHR;
264:           }
265:           
266:           bool ADCC_HasErrorCrossedLowerThreshold(void)
267:           {
268:               //Returns the value of ADSTATbits.ADLTHR bit.
269:               return ADSTATbits.ADLTHR;
270:           }
271:           
272:           uint8_t ADCC_GetConversionStageStatus(void)
273:           {
274:               //Returns the contents of ADSTATbits.ADSTAT field.
275:               return ADSTATbits.ADSTAT;
276:           }
277:           
278:           
279:           void ADCC_ThresholdISR(void)
280:           {
281:               // Clear the ADCC Threshold interrupt flag
282:               PIR2bits.ADTIF = 0;
84D4  90B0     BCF 0xFB0, 0, ACCESS
283:           
284:               if (ADCC_ADTI_InterruptHandler)
84D6  0105     MOVLB 0x5
84D8  51E0     MOVF 0xE0, W, BANKED
84DA  11E1     IORWF 0xE1, W, BANKED
84DC  11E2     IORWF 0xE2, W, BANKED
84DE  B4D8     BTFSC 0xFD8, 2, ACCESS
84E0  EF74     GOTO 0x84E8
84E2  F042     NOP
84E4  EF76     GOTO 0x84EC
84E6  F042     NOP
84E8  EF83     GOTO 0x8506
84EA  F042     NOP
285:                   ADCC_ADTI_InterruptHandler();
84EC  D802     RCALL 0x84F2
84EE  EF83     GOTO 0x8506
84F0  F042     NOP
84F2  0005     PUSH
84F4  6EFA     MOVWF 0xFFA, ACCESS
84F6  51E0     MOVF 0xE0, W, BANKED
84F8  6EFD     MOVWF 0xFFD, ACCESS
84FA  51E1     MOVF 0xE1, W, BANKED
84FC  6EFE     MOVWF 0xFFE, ACCESS
84FE  51E2     MOVF 0xE2, W, BANKED
8500  6EFF     MOVWF 0xFFF, ACCESS
8502  50FA     MOVF 0xFFA, W, ACCESS
8504  0012     RETURN 0
286:           }
8506  0012     RETURN 0
287:           
288:           void ADCC_SetADTIInterruptHandler(void (* InterruptHandler)(void)){
289:               ADCC_ADTI_InterruptHandler = InterruptHandler;
867C  F800     NOP
867E  F5E0     NOP
8682  F804     NOP
8684  F5E1     NOP
8688  F808     NOP
868A  F5E2     NOP
290:           }
868C  0012     RETURN 0
291:           void ADCC_DefaultInterruptHandler(void)
292:           {   
293:               float T0 = 0.00335;                                                         // 1 / 298.15
674A  0EAC     MOVLW 0xAC
674C  6E55     MOVWF 0x55, ACCESS
674E  0E8B     MOVLW 0x8B
6750  6E56     MOVWF 0x56, ACCESS
6752  0E5B     MOVLW 0x5B
6754  6E57     MOVWF 0x57, ACCESS
6756  0E3B     MOVLW 0x3B
6758  6E58     MOVWF 0x58, ACCESS
294:               float B = 0.00025;                                                          // 1 / 3950 (beta value)
675A  0E6F     MOVLW 0x6F
675C  6E59     MOVWF 0x59, ACCESS
675E  0E12     MOVLW 0x12
6760  6E5A     MOVWF 0x5A, ACCESS
6762  0E83     MOVLW 0x83
6764  6E5B     MOVWF 0x5B, ACCESS
6766  0E39     MOVLW 0x39
6768  6E5C     MOVWF 0x5C, ACCESS
295:                   
296:               adc_val = ADCC_GetConversionResult();  
676A  ECF6     CALL 0x85EC, 0
676C  F042     NOP
6770  F404     NOP
6772  F5CC     NOP
6776  F408     NOP
6778  F5CD     NOP
297:           
298:               temperature = (MAXADC / (float)adc_val) - 1.00000;                      // Find Resistance equivalent of input voltage
677C  F730     NOP
677E  F501     NOP
6782  F734     NOP
6784  F502     NOP
6786  6A03     CLRF 0x3, ACCESS
6788  6A04     CLRF 0x4, ACCESS
678A  0E00     MOVLW 0x0
678C  ECCD     CALL 0x699A, 0
678E  F034     NOP
6792  F404     NOP
6794  F51E     NOP
6798  F408     NOP
679A  F51F     NOP
679E  F40C     NOP
67A0  F520     NOP
67A4  F410     NOP
67A6  F521     NOP
67A8  0E00     MOVLW 0x0
67AA  6E1A     MOVWF 0x1A, ACCESS
67AC  0EF0     MOVLW 0xF0
67AE  6E1B     MOVWF 0x1B, ACCESS
67B0  0E7F     MOVLW 0x7F
67B2  6E1C     MOVWF 0x1C, ACCESS
67B4  0E45     MOVLW 0x45
67B6  6E1D     MOVWF 0x1D, ACCESS
67B8  ECF3     CALL 0x5DE6, 0
67BA  F02E     NOP
67BE  F468     NOP
67C0  F533     NOP
67C4  F46C     NOP
67C6  F534     NOP
67CA  F470     NOP
67CC  F535     NOP
67D0  F474     NOP
67D2  F536     NOP
67D4  0E00     MOVLW 0x0
67D6  6E37     MOVWF 0x37, ACCESS
67D8  0E00     MOVLW 0x0
67DA  6E38     MOVWF 0x38, ACCESS
67DC  0E80     MOVLW 0x80
67DE  6E39     MOVWF CLKRCON, ACCESS
67E0  0EBF     MOVLW 0xBF
67E2  6E3A     MOVWF CLKRCLK, ACCESS
67E4  EC0A     CALL 0x4C14, 0
67E6  F026     NOP
67EA  F4CC     NOP
67EC  F5C8     NOP
67F0  F4D0     NOP
67F2  F5C9     NOP
67F6  F4D4     NOP
67F8  F5CA     NOP
67FC  F4D8     NOP
67FE  F5CB     NOP
299:               temperature = log10f(temperature);                                      // Take the Log of the temperature
6802  F720     NOP
6804  F54B     NOP
6808  F724     NOP
680A  F54C     NOP
680E  F728     NOP
6810  F54D     NOP
6814  F72C     NOP
6816  F54E     NOP
6818  ECAA     CALL 0x3354, 0
681A  F019     NOP
681E  F52C     NOP
6820  F5C8     NOP
6824  F530     NOP
6826  F5C9     NOP
682A  F534     NOP
682C  F5CA     NOP
6830  F538     NOP
6832  F5CB     NOP
300:               temperature = temperature / LN;                                         // Divide the log(temp) value by the Log(e) value: converts log(x) into ln(x)
6836  F720     NOP
6838  F51A     NOP
683C  F724     NOP
683E  F51B     NOP
6842  F728     NOP
6844  F51C     NOP
6848  F72C     NOP
684A  F51D     NOP
684C  0E92     MOVLW 0x92
684E  6E1E     MOVWF 0x1E, ACCESS
6850  0E5C     MOVLW 0x5C
6852  6E1F     MOVWF 0x1F, ACCESS
6854  0EDE     MOVLW 0xDE
6856  6E20     MOVWF 0x20, ACCESS
6858  0E3E     MOVLW 0x3E
685A  6E21     MOVWF 0x21, ACCESS
685C  ECF3     CALL 0x5DE6, 0
685E  F02E     NOP
6862  F468     NOP
6864  F5C8     NOP
6868  F46C     NOP
686A  F5C9     NOP
686E  F470     NOP
6870  F5CA     NOP
6874  F474     NOP
6876  F5CB     NOP
301:               temperature = B * temperature;                                          // Multiply by B constant
687A  F564     NOP
687C  F501     NOP
6880  F568     NOP
6882  F502     NOP
6886  F56C     NOP
6888  F503     NOP
688C  F570     NOP
688E  F504     NOP
6892  F720     NOP
6894  F505     NOP
6898  F724     NOP
689A  F506     NOP
689E  F728     NOP
68A0  F507     NOP
68A4  F72C     NOP
68A6  F508     NOP
68A8  ECCE     CALL 0x559C, 0
68AA  F02A     NOP
68AE  F404     NOP
68B0  F5C8     NOP
68B4  F408     NOP
68B6  F5C9     NOP
68BA  F40C     NOP
68BC  F5CA     NOP
68C0  F410     NOP
68C2  F5CB     NOP
302:               temperature += T0;                                                      // Add T0 constant
68C6  F720     NOP
68C8  F533     NOP
68CC  F724     NOP
68CE  F534     NOP
68D2  F728     NOP
68D4  F535     NOP
68D8  F72C     NOP
68DA  F536     NOP
68DE  F554     NOP
68E0  F537     NOP
68E4  F558     NOP
68E6  F538     NOP
68EA  F55C     NOP
68EC  F539     NOP
68F0  F560     NOP
68F2  F53A     NOP
68F4  EC0A     CALL 0x4C14, 0
68F6  F026     NOP
68FA  F4CC     NOP
68FC  F5C8     NOP
6900  F4D0     NOP
6902  F5C9     NOP
6906  F4D4     NOP
6908  F5CA     NOP
690C  F4D8     NOP
690E  F5CB     NOP
303:               temperature = 1 / temperature;                                          // Invert to get degrees in Kelvin (K)
6910  0E00     MOVLW 0x0
6912  6E1A     MOVWF 0x1A, ACCESS
6914  0E00     MOVLW 0x0
6916  6E1B     MOVWF 0x1B, ACCESS
6918  0E80     MOVLW 0x80
691A  6E1C     MOVWF 0x1C, ACCESS
691C  0E3F     MOVLW 0x3F
691E  6E1D     MOVWF 0x1D, ACCESS
6922  F720     NOP
6924  F51E     NOP
6928  F724     NOP
692A  F51F     NOP
692E  F728     NOP
6930  F520     NOP
6934  F72C     NOP
6936  F521     NOP
6938  ECF3     CALL 0x5DE6, 0
693A  F02E     NOP
693E  F468     NOP
6940  F5C8     NOP
6944  F46C     NOP
6946  F5C9     NOP
694A  F470     NOP
694C  F5CA     NOP
6950  F474     NOP
6952  F5CB     NOP
304:               temperature -= K;                                                       // Subtract the K constant to get actual temp in degrees C   
6956  F720     NOP
6958  F543     NOP
695C  F724     NOP
695E  F544     NOP
6962  F728     NOP
6964  F545     NOP
6968  F72C     NOP
696A  F546     NOP
696C  0E33     MOVLW 0x33
696E  6E47     MOVWF NVMDATH, ACCESS
6970  0E93     MOVLW 0x93
6972  6E48     MOVWF VREGCON, ACCESS
6974  0E88     MOVLW 0x88
6976  6E49     MOVWF BORCON, ACCESS
6978  0E43     MOVLW 0x43
697A  6E4A     MOVWF HLVDCON0, ACCESS
697C  EC93     CALL 0x8126, 0
697E  F040     NOP
6982  F50C     NOP
6984  F5C8     NOP
6988  F510     NOP
698A  F5C9     NOP
698E  F514     NOP
6990  F5CA     NOP
6994  F518     NOP
6996  F5CB     NOP
305:           }
6998  0012     RETURN 0
306:           /**
307:            End of File
308:           */
---  C:/Users/C15552/Desktop/Q43_MCC_Test.X/main.c  -----------------------------------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.76
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.00
19:            */
20:            
21:            /*
22:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
23:                
24:                Subject to your compliance with these terms, you may use Microchip software and any 
25:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
26:                license terms applicable to your use of third party software (including open source software) that 
27:                may accompany Microchip software.
28:                
29:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
30:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
31:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
32:                FOR A PARTICULAR PURPOSE.
33:                
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
37:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
38:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
39:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
40:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
41:                SOFTWARE.
42:            */
43:            
44:            #include "mcc_generated_files/mcc.h"
45:            
46:            #define MIN_THERM_ADC   1800                                                    // ADC value at 20C
47:            #define MAX_THERM_ADC   3488                                                    // ADC value at 70C
48:            #define MIN_SPD         1000
49:            #define MAX_SPD         8000
50:            #define SLOPE_M         ((MAX_SPD - MIN_SPD) / (MAX_THERM_ADC - MIN_THERM_ADC))
51:            #define B_OFFSET        (MAX_SPD - (SLOPE_M * MAX_THERM_ADC))
52:            
53:            uint8_t therm_fail = 0;
54:            
55:            void adjustSpeed(void);
56:            
57:            void main(void)
58:            {
59:                // Initialize the device
60:                SYSTEM_Initialize();
7D98  EC84     CALL 0x8508, 0
7D9A  F042     NOP
61:            
62:                // If using interrupts in PIC18 High/Low Priority Mode you need to enable the Global High and Low Interrupts
63:                // If using interrupts in PIC Mid-Range Compatibility Mode you need to enable the Global and Peripheral Interrupts
64:                // Use the following macros to:
65:            
66:                // Enable the Global Interrupts
67:                INTERRUPT_GlobalInterruptEnable();
7D9C  8ED6     BSF 0xFD6, 7, ACCESS
68:            
69:                // Disable the Global Interrupts
70:                //INTERRUPT_GlobalInterruptDisable();
71:            
72:                // Enable the Peripheral Interrupts
73:                //INTERRUPT_PeripheralInterruptEnable();
74:            
75:                // Disable the Peripheral Interrupts
76:                //INTERRUPT_PeripheralInterruptDisable();
77:            
78:                while (1)
79:                {
80:                    ADCC_StartConversion(Thermistor);
7D9E  0E01     MOVLW 0x1
7DA0  EC47     CALL 0x868E, 0
7DA2  F043     NOP
81:                    printf("%1.2fC \r\n", temperature);  
7DA4  0E3D     MOVLW 0x3D
7DA6  0106     MOVLB 0x6
7DA8  6F99     MOVWF SPI2CLK, BANKED
7DAA  0E25     MOVLW 0x25
7DAC  6F9A     MOVWF 0x9A, BANKED
7DB0  F720     NOP
7DB2  F69B     NOP
7DB6  F724     NOP
7DB8  F69C     NOP
7DBC  F728     NOP
7DBE  F69D     NOP
7DC2  F72C     NOP
7DC4  F69E     NOP
7DC6  ECB5     CALL 0x856A, 0
7DC8  F042     NOP
82:                    //printf("%d ADC \r\n", adc_val);// Print values for verification
83:                    printf("%d RPM1  %d RPM2  %d RPM3\r\n", fan1_spd, fan2_spd, fan3_spd);  // Print values for verification
7DCA  0E21     MOVLW 0x21
7DCC  0106     MOVLB 0x6
7DCE  6F99     MOVWF SPI2CLK, BANKED
7DD0  0E25     MOVLW 0x25
7DD2  6F9A     MOVWF 0x9A, BANKED
7DD6  FADC     NOP
7DD8  F69B     NOP
7DDC  FAE0     NOP
7DDE  F69C     NOP
7DE2  FAEC     NOP
7DE4  F69D     NOP
7DE8  FAF0     NOP
7DEA  F69E     NOP
7DEE  FAE4     NOP
7DF0  F69F     NOP
7DF4  FAE8     NOP
7DF6  F6A0     NOP
7DF8  ECB5     CALL 0x856A, 0
7DFA  F042     NOP
84:                    adjustSpeed();
7DFC  EC28     CALL 0x7050, 0
7DFE  F038     NOP
85:                    __delay_ms(1000);
7E00  0E52     MOVLW 0x52
7E02  0106     MOVLB 0x6
7E04  6FA6     MOVWF 0xA6, BANKED
7E06  0E2B     MOVLW 0x2B
7E08  6FA5     MOVWF 0xA5, BANKED
7E0A  0E00     MOVLW 0x0
7E0C  2EE8     DECFSZ 0xFE8, F, ACCESS
7E0E  D7FE     BRA 0x7E0C
7E10  2FA5     DECFSZ 0xA5, F, BANKED
7E12  D7FC     BRA 0x7E0C
7E14  2FA6     DECFSZ 0xA6, F, BANKED
7E16  D7FA     BRA 0x7E0C
7E18  F000     NOP
7E1A  EFCF     GOTO 0x7D9E
7E1C  F03E     NOP
7E1E  EF0D     GOTO 0x1A
7E20  F000     NOP
86:                }
87:            }
88:            
89:            void adjustSpeed(void)
90:            {
91:                if(adc_val < MIN_THERM_ADC)
7050  0E08     MOVLW 0x8
7052  0105     MOVLB 0x5
7054  5DCC     SUBWF 0xCC, W, BANKED
7056  0E07     MOVLW 0x7
7058  59CD     SUBWFB 0xCD, W, BANKED
705A  B0D8     BTFSC 0xFD8, 0, ACCESS
705C  EF32     GOTO 0x7064
705E  F038     NOP
7060  EF34     GOTO 0x7068
7062  F038     NOP
7064  EF4A     GOTO 0x7094
7066  F038     NOP
92:                {
93:                    if(ADSTATbits.ADLTHR == 0)
7068  0103     MOVLB 0x3
706A  BBF7     BTFSC DMAxSSZ, 5, BANKED
706C  EF3A     GOTO 0x7074
706E  F038     NOP
7070  EF3C     GOTO 0x7078
7072  F038     NOP
7074  EF42     GOTO 0x7084
7076  F038     NOP
94:                    {
95:                        y_therm = MIN_SPD;
7078  0E03     MOVLW 0x3
707A  6E5E     MOVWF 0x5E, ACCESS
707C  0EE8     MOVLW 0xE8
707E  6E5D     MOVWF 0x5D, ACCESS
96:                    }
7080  EF78     GOTO 0x70F0
7082  F038     NOP
97:                    else
98:                    {
99:                        y_therm = MAX_SPD;
7084  0E1F     MOVLW 0x1F
7086  6E5E     MOVWF 0x5E, ACCESS
7088  0E40     MOVLW 0x40
708A  6E5D     MOVWF 0x5D, ACCESS
100:                       therm_fail = 1;
708C  0E01     MOVLW 0x1
708E  6E5F     MOVWF 0x5F, ACCESS
7090  EF78     GOTO 0x70F0
7092  F038     NOP
101:                   }
102:               }
103:               else if(adc_val > MAX_THERM_ADC)
7094  0EA1     MOVLW 0xA1
7096  5DCC     SUBWF 0xCC, W, BANKED
7098  0E0D     MOVLW 0xD
709A  59CD     SUBWFB 0xCD, W, BANKED
709C  A0D8     BTFSS 0xFD8, 0, ACCESS
709E  EF53     GOTO 0x70A6
70A0  F038     NOP
70A2  EF55     GOTO 0x70AA
70A4  F038     NOP
70A6  EF63     GOTO 0x70C6
70A8  F038     NOP
104:               {
105:                   if(ADSTATbits.ADUTHR == 0)
70AA  0103     MOVLB 0x3
70AC  BDF7     BTFSC DMAxSSZ, 6, BANKED
70AE  EF5B     GOTO 0x70B6
70B0  F038     NOP
70B2  EF5D     GOTO 0x70BA
70B4  F038     NOP
70B6  EF42     GOTO 0x7084
70B8  F038     NOP
106:                   {
107:                       y_therm = MAX_SPD;
70BA  0E1F     MOVLW 0x1F
70BC  6E5E     MOVWF 0x5E, ACCESS
70BE  0E40     MOVLW 0x40
70C0  6E5D     MOVWF 0x5D, ACCESS
108:                   }
70C2  EF78     GOTO 0x70F0
70C4  F038     NOP
109:                   else
110:                   {
111:                       y_therm = MAX_SPD;
112:                       therm_fail = 1;
113:                   }
114:               }
115:               else
116:               {
117:                   y_therm = SLOPE_M * adc_val + B_OFFSET;                                     // Speed based on y = mx + b line equation
70C8  F730     NOP
70CA  F600     NOP
70CE  F734     NOP
70D0  F601     NOP
70D2  0106     MOVLB 0x6
70D4  90D8     BCF 0xFD8, 0, ACCESS
70D6  3700     RLCF txData, F, BANKED
70D8  3701     RLCF 0x1, F, BANKED
70DA  90D8     BCF 0xFD8, 0, ACCESS
70DC  3700     RLCF txData, F, BANKED
70DE  3701     RLCF 0x1, F, BANKED
70E0  0EC0     MOVLW 0xC0
70E2  2500     ADDWF txData, W, BANKED
70E4  6E5D     MOVWF 0x5D, ACCESS
70E6  0EE8     MOVLW 0xE8
70E8  2101     ADDWFC 0x1, W, BANKED
70EA  6E5E     MOVWF 0x5E, ACCESS
118:                   therm_fail = 0;
70EC  0E00     MOVLW 0x0
70EE  6E5F     MOVWF 0x5F, ACCESS
119:               }
120:               if(fan1_spd < y_therm)                                                      // Fan 1 too slow?
70F0  505D     MOVF 0x5D, W, ACCESS
70F2  0106     MOVLB 0x6
70F4  5DB7     SUBWF DMA2PR, W, BANKED
70F6  505E     MOVF 0x5E, W, ACCESS
70F8  59B8     SUBWFB DMA3PR, W, BANKED
70FA  B0D8     BTFSC 0xFD8, 0, ACCESS
70FC  EF82     GOTO 0x7104
70FE  F038     NOP
7100  EF84     GOTO 0x7108
7102  F038     NOP
7104  EF89     GOTO 0x7112
7106  F038     NOP
121:               {
122:                   PWM1S1P1 += 1;
7108  4A6B     INFSNZ 0xF6B, F, ACCESS
710A  2A6C     INCF 0xF6C, F, ACCESS
123:                   PWM1CONbits.LD = 1;
710C  8469     BSF 0xF69, 2, ACCESS
124:               }
710E  EF98     GOTO 0x7130
7110  F038     NOP
125:               else if(fan1_spd > y_therm)
7112  51B7     MOVF DMA2PR, W, BANKED
7114  5C5D     SUBWF 0x5D, W, ACCESS
7116  51B8     MOVF DMA3PR, W, BANKED
7118  585E     SUBWFB 0x5E, W, ACCESS
711A  B0D8     BTFSC 0xFD8, 0, ACCESS
711C  EF92     GOTO 0x7124
711E  F038     NOP
7120  EF94     GOTO 0x7128
7122  F038     NOP
7124  EF98     GOTO 0x7130
7126  F038     NOP
126:               {
127:                   PWM1S1P1 -= 1;
7128  066B     DECF 0xF6B, F, ACCESS
712A  A0D8     BTFSS 0xFD8, 0, ACCESS
712C  066C     DECF 0xF6C, F, ACCESS
128:                   PWM1CONbits.LD = 1;
712E  8469     BSF 0xF69, 2, ACCESS
129:               }
130:               if(fan2_spd < y_therm)                                                      // Fan 1 too slow?
7130  505D     MOVF 0x5D, W, ACCESS
7132  5DBB     SUBWF DMA6PR, W, BANKED
7134  505E     MOVF 0x5E, W, ACCESS
7136  59BC     SUBWFB 0xBC, W, BANKED
7138  B0D8     BTFSC 0xFD8, 0, ACCESS
713A  EFA1     GOTO 0x7142
713C  F038     NOP
713E  EFA3     GOTO 0x7146
7140  F038     NOP
7142  EFA8     GOTO 0x7150
7144  F038     NOP
131:               {
132:                   PWM1S1P2 += 1;
7146  4A6D     INFSNZ 0xF6D, F, ACCESS
7148  2A6E     INCF 0xF6E, F, ACCESS
133:                   PWM1CONbits.LD = 1;
714A  8469     BSF 0xF69, 2, ACCESS
134:               }
714C  EFB7     GOTO 0x716E
714E  F038     NOP
135:               else if(fan2_spd > y_therm)
7150  51BB     MOVF DMA6PR, W, BANKED
7152  5C5D     SUBWF 0x5D, W, ACCESS
7154  51BC     MOVF 0xBC, W, BANKED
7156  585E     SUBWFB 0x5E, W, ACCESS
7158  B0D8     BTFSC 0xFD8, 0, ACCESS
715A  EFB1     GOTO 0x7162
715C  F038     NOP
715E  EFB3     GOTO 0x7166
7160  F038     NOP
7162  EFB7     GOTO 0x716E
7164  F038     NOP
136:               {
137:                   PWM1S1P2 -= 1;
7166  066D     DECF 0xF6D, F, ACCESS
7168  A0D8     BTFSS 0xFD8, 0, ACCESS
716A  066E     DECF 0xF6E, F, ACCESS
138:                   PWM1CONbits.LD = 1;
716C  8469     BSF 0xF69, 2, ACCESS
139:               }
140:               if(fan3_spd < y_therm)                                                      // Fan 1 too slow?
716E  505D     MOVF 0x5D, W, ACCESS
7170  5DB9     SUBWF DMA4PR, W, BANKED
7172  505E     MOVF 0x5E, W, ACCESS
7174  59BA     SUBWFB DMA5PR, W, BANKED
7176  B0D8     BTFSC 0xFD8, 0, ACCESS
7178  EFC0     GOTO 0x7180
717A  F038     NOP
717C  EFC2     GOTO 0x7184
717E  F038     NOP
7180  EFC7     GOTO 0x718E
7182  F038     NOP
141:               {
142:                   PWM2S1P1 += 1;
7184  4A7A     INFSNZ 0xF7A, F, ACCESS
7186  2A7B     INCF 0xF7B, F, ACCESS
143:                   PWM2CONbits.LD = 1;
7188  8478     BSF 0xF78, 2, ACCESS
144:               }
718A  EFD6     GOTO 0x71AC
718C  F038     NOP
145:               else if(fan3_spd > y_therm)
718E  51B9     MOVF DMA4PR, W, BANKED
7190  5C5D     SUBWF 0x5D, W, ACCESS
7192  51BA     MOVF DMA5PR, W, BANKED
7194  585E     SUBWFB 0x5E, W, ACCESS
7196  B0D8     BTFSC 0xFD8, 0, ACCESS
7198  EFD0     GOTO 0x71A0
719A  F038     NOP
719C  EFD2     GOTO 0x71A4
719E  F038     NOP
71A0  EFD6     GOTO 0x71AC
71A2  F038     NOP
146:               {
147:                   PWM2S1P1 -= 1;
71A4  067A     DECF 0xF7A, F, ACCESS
71A6  A0D8     BTFSS 0xFD8, 0, ACCESS
71A8  067B     DECF 0xF7B, F, ACCESS
148:                   PWM2CONbits.LD = 1;
71AA  8478     BSF 0xF78, 2, ACCESS
149:               }
150:               
151:           }
71AC  0012     RETURN 0
152:           /**
153:            End of File
154:           */
---  C:/Users/C15552/AppData/Local/Temp/skn0.s  ---------------------------------------------------------
7F18  0EAE     MOVLW 0xAE
7F1A  6EF6     MOVWF 0xFF6, ACCESS
7F1C  0E86     MOVLW 0x86
7F1E  6EF7     MOVWF 0xFF7, ACCESS
7F20  0E00     MOVLW 0x0
7F22  6EF8     MOVWF 0xFF8, ACCESS
7F24  EE01     LFSR 0, 0x5D4
7F28  EE10     LFSR 1, 0xC
7F2C  0009     TBLRD*+
7F2E  C4F5     MOVFF TABLAT, POSTINC0
7F32  50E5     MOVF 0xFE5, W, ACCESS
7F34  50E1     MOVF 0xFE1, W, ACCESS
7F36  E1FA     BNZ 0x7F2C
7F38  0EBE     MOVLW 0xBE
7F3A  6EF6     MOVWF 0xFF6, ACCESS
7F3C  0E86     MOVLW 0x86
7F3E  6EF7     MOVWF 0xFF7, ACCESS
7F40  0E00     MOVLW 0x0
7F42  6EF8     MOVWF 0xFF8, ACCESS
7F44  0009     TBLRD*+
7F4C  0009     TBLRD*+
7F54  EE01     LFSR 0, 0x700
7F58  0E50     MOVLW 0x50
7F5A  6AEE     CLRF 0xFEE, ACCESS
7F5C  06E8     DECF 0xFE8, F, ACCESS
7F5E  E1FD     BNZ 0x7F5A
7F60  EE01     LFSR 0, 0x6A7
7F64  0E17     MOVLW 0x17
7F66  6AEE     CLRF 0xFEE, ACCESS
7F68  06E8     DECF 0xFE8, F, ACCESS
7F6A  E1FD     BNZ 0x7F66
7F6C  EE01     LFSR 0, 0x5B2
7F70  0E22     MOVLW 0x22
7F72  6AEE     CLRF 0xFEE, ACCESS
7F74  06E8     DECF 0xFE8, F, ACCESS
7F76  E1FD     BNZ 0x7F72
7F78  6A5F     CLRF 0x5F, ACCESS
7F7A  0104     MOVLB 0x4
7F7C  0E08     MOVLW 0x8
7F7E  6F5D     MOVWF 0x5D, BANKED
7F80  0E00     MOVLW 0x0
7F82  6F5E     MOVWF 0x5E, BANKED
7F84  0E00     MOVLW 0x0
7F86  6F5F     MOVWF 0x5F, BANKED
7F88  0100     MOVLB 0x0
7F8A  EFCC     GOTO 0x7D98
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/xxtofl.c  ------------------------
1:             // since we use tests on the size of operands, suppress the warnings that
2:             // would be generated
3:             #pragma warning disable 757
4:             
5:             /* Convert an integer to a 32-bit floating point value.
6:              * sign : is val actually a signed value
7:              * val  : the incoming integer (signed or unsigned) for conversion, cast to a signed long
8:              */ 
9:             double
10:            __xxtofl(unsigned char sign, signed long val)
699A  6E09     MOVWF 0x9, ACCESS
11:            {
12:            	unsigned char exp;
13:            	unsigned long arg;
14:            
15:            	if(sign && val < 0) {
699C  5009     MOVF 0x9, W, ACCESS
699E  B4D8     BTFSC 0xFD8, 2, ACCESS
69A0  EFD4     GOTO 0x69A8
69A2  F034     NOP
69A4  EFD6     GOTO 0x69AC
69A6  F034     NOP
69A8  EF00     GOTO 0x6A00
69AA  F035     NOP
69AC  BE04     BTFSC 0x4, 7, ACCESS
69AE  EFDD     GOTO 0x69BA
69B0  F034     NOP
69B2  EFDB     GOTO 0x69B6
69B4  F034     NOP
69B6  EF00     GOTO 0x6A00
69B8  F035     NOP
16:            		arg = -val;
69BC  F404     NOP
69BE  F505     NOP
69C2  F408     NOP
69C4  F506     NOP
69C8  F40C     NOP
69CA  F507     NOP
69CE  F410     NOP
69D0  F508     NOP
69D2  1E05     COMF 0x5, F, ACCESS
69D4  1E06     COMF 0x6, F, ACCESS
69D6  1E07     COMF 0x7, F, ACCESS
69D8  1E08     COMF 0x8, F, ACCESS
69DA  2A05     INCF 0x5, F, ACCESS
69DC  0E00     MOVLW 0x0
69DE  2206     ADDWFC 0x6, F, ACCESS
69E0  2207     ADDWFC 0x7, F, ACCESS
69E2  2208     ADDWFC 0x8, F, ACCESS
69E6  F414     NOP
69E8  F50B     NOP
69EC  F418     NOP
69EE  F50C     NOP
69F2  F41C     NOP
69F4  F50D     NOP
69F8  F420     NOP
69FA  F50E     NOP
17:            	}
69FC  EF0C     GOTO 0x6A18
69FE  F035     NOP
18:            	else {
19:            		arg = val;
6A02  F404     NOP
6A04  F50B     NOP
6A08  F408     NOP
6A0A  F50C     NOP
6A0E  F40C     NOP
6A10  F50D     NOP
6A14  F410     NOP
6A16  F50E     NOP
20:            	}
21:            	if(val == 0)
6A18  5001     MOVF 0x1, W, ACCESS
6A1A  1002     IORWF 0x2, W, ACCESS
6A1C  1003     IORWF 0x3, W, ACCESS
6A1E  1004     IORWF 0x4, W, ACCESS
6A20  A4D8     BTFSS 0xFD8, 2, ACCESS
6A22  EF15     GOTO 0x6A2A
6A24  F035     NOP
6A26  EF17     GOTO 0x6A2E
6A28  F035     NOP
6A2A  EF21     GOTO 0x6A42
6A2C  F035     NOP
22:            		return 0.0;
6A2E  0E00     MOVLW 0x0
6A30  6E01     MOVWF 0x1, ACCESS
6A32  0E00     MOVLW 0x0
6A34  6E02     MOVWF 0x2, ACCESS
6A36  0E00     MOVLW 0x0
6A38  6E03     MOVWF 0x3, ACCESS
6A3A  0E00     MOVLW 0x0
6A3C  6E04     MOVWF 0x4, ACCESS
6A3E  EFB8     GOTO 0x6B70
6A40  F035     NOP
23:            	exp = (127 + 23);
6A42  0E96     MOVLW 0x96
6A44  6E0A     MOVWF 0xA, ACCESS
24:            	while(arg & ~0x1FFFFFFUL) {
6A46  EF2B     GOTO 0x6A56
6A48  F035     NOP
6A56  0E00     MOVLW 0x0
6A58  140B     ANDWF 0xB, W, ACCESS
6A5A  6E05     MOVWF 0x5, ACCESS
6A5C  0E00     MOVLW 0x0
6A5E  140C     ANDWF 0xC, W, ACCESS
6A60  6E06     MOVWF 0x6, ACCESS
6A62  0E00     MOVLW 0x0
6A64  140D     ANDWF 0xD, W, ACCESS
6A66  6E07     MOVWF 0x7, ACCESS
6A68  0EFE     MOVLW 0xFE
6A6A  140E     ANDWF 0xE, W, ACCESS
6A6C  6E08     MOVWF 0x8, ACCESS
6A6E  5005     MOVF 0x5, W, ACCESS
6A70  1006     IORWF 0x6, W, ACCESS
6A72  1007     IORWF 0x7, W, ACCESS
6A74  1008     IORWF 0x8, W, ACCESS
6A76  A4D8     BTFSS 0xFD8, 2, ACCESS
6A78  EF40     GOTO 0x6A80
6A7A  F035     NOP
6A7C  EF42     GOTO 0x6A84
6A7E  F035     NOP
6A80  EF25     GOTO 0x6A4A
6A82  F035     NOP
6A84  EF50     GOTO 0x6AA0
6A86  F035     NOP
25:            		++exp;
6A4A  2A0A     INCF 0xA, F, ACCESS
26:            		arg >>= 1;
6A4C  90D8     BCF 0xFD8, 0, ACCESS
6A4E  320E     RRCF 0xE, F, ACCESS
6A50  320D     RRCF 0xD, F, ACCESS
6A52  320C     RRCF 0xC, F, ACCESS
6A54  320B     RRCF 0xB, F, ACCESS
27:            	}
28:            	while(arg & ~0xFFFFFFUL) {
29:            		++exp;
6A88  2A0A     INCF 0xA, F, ACCESS
30:            		++arg;
6A8A  0E01     MOVLW 0x1
6A8C  260B     ADDWF 0xB, F, ACCESS
6A8E  0E00     MOVLW 0x0
6A90  220C     ADDWFC 0xC, F, ACCESS
6A92  220D     ADDWFC 0xD, F, ACCESS
6A94  220E     ADDWFC 0xE, F, ACCESS
31:            		arg >>= 1;
6A96  90D8     BCF 0xFD8, 0, ACCESS
6A98  320E     RRCF 0xE, F, ACCESS
6A9A  320D     RRCF 0xD, F, ACCESS
6A9C  320C     RRCF 0xC, F, ACCESS
6A9E  320B     RRCF 0xB, F, ACCESS
32:            	}
6AA0  0E00     MOVLW 0x0
6AA2  140B     ANDWF 0xB, W, ACCESS
6AA4  6E05     MOVWF 0x5, ACCESS
6AA6  0E00     MOVLW 0x0
6AA8  140C     ANDWF 0xC, W, ACCESS
6AAA  6E06     MOVWF 0x6, ACCESS
6AAC  0E00     MOVLW 0x0
6AAE  140D     ANDWF 0xD, W, ACCESS
6AB0  6E07     MOVWF 0x7, ACCESS
6AB2  0EFF     MOVLW 0xFF
6AB4  140E     ANDWF 0xE, W, ACCESS
6AB6  6E08     MOVWF 0x8, ACCESS
6AB8  5005     MOVF 0x5, W, ACCESS
6ABA  1006     IORWF 0x6, W, ACCESS
6ABC  1007     IORWF 0x7, W, ACCESS
6ABE  1008     IORWF 0x8, W, ACCESS
6AC0  A4D8     BTFSS 0xFD8, 2, ACCESS
6AC2  EF65     GOTO 0x6ACA
6AC4  F035     NOP
6AC6  EF67     GOTO 0x6ACE
6AC8  F035     NOP
6ACA  EF44     GOTO 0x6A88
6ACC  F035     NOP
6ACE  EF6F     GOTO 0x6ADE
6AD0  F035     NOP
33:            	while(!(arg & 0x800000UL) && exp > 1) {
6ADE  BE0D     BTFSC 0xD, 7, ACCESS
6AE0  EF74     GOTO 0x6AE8
6AE2  F035     NOP
6AE4  EF76     GOTO 0x6AEC
6AE6  F035     NOP
6AE8  EF7E     GOTO 0x6AFC
6AEA  F035     NOP
6AEC  0E02     MOVLW 0x2
6AEE  600A     CPFSLT 0xA, ACCESS
6AF0  EF7C     GOTO 0x6AF8
6AF2  F035     NOP
6AF4  EF7E     GOTO 0x6AFC
6AF6  F035     NOP
6AF8  EF69     GOTO 0x6AD2
6AFA  F035     NOP
34:            		--exp;
6AD2  060A     DECF 0xA, F, ACCESS
35:            		arg <<= 1;
6AD4  90D8     BCF 0xFD8, 0, ACCESS
6AD6  360B     RLCF 0xB, F, ACCESS
6AD8  360C     RLCF 0xC, F, ACCESS
6ADA  360D     RLCF 0xD, F, ACCESS
6ADC  360E     RLCF 0xE, F, ACCESS
36:            	}
37:            	if(!(exp & 1))
6AFC  B00A     BTFSC 0xA, 0, ACCESS
6AFE  EF83     GOTO 0x6B06
6B00  F035     NOP
6B02  EF85     GOTO 0x6B0A
6B04  F035     NOP
6B06  EF86     GOTO 0x6B0C
6B08  F035     NOP
38:            		arg &= ~0x800000UL;
6B0A  9E0D     BCF 0xD, 7, ACCESS
39:            	exp >>= 1;
6B0C  90D8     BCF 0xFD8, 0, ACCESS
6B0E  320A     RRCF 0xA, F, ACCESS
40:            	arg |= (unsigned long)exp << 24;
6B12  F428     NOP
6B14  F505     NOP
6B16  6A06     CLRF 0x6, ACCESS
6B18  6A07     CLRF 0x7, ACCESS
6B1A  6A08     CLRF 0x8, ACCESS
6B1E  F414     NOP
6B20  F508     NOP
6B22  6A07     CLRF 0x7, ACCESS
6B24  6A06     CLRF 0x6, ACCESS
6B26  6A05     CLRF 0x5, ACCESS
6B28  5005     MOVF 0x5, W, ACCESS
6B2A  120B     IORWF 0xB, F, ACCESS
6B2C  5006     MOVF 0x6, W, ACCESS
6B2E  120C     IORWF 0xC, F, ACCESS
6B30  5007     MOVF 0x7, W, ACCESS
6B32  120D     IORWF 0xD, F, ACCESS
6B34  5008     MOVF 0x8, W, ACCESS
6B36  120E     IORWF 0xE, F, ACCESS
41:            	if(sign && val < 0)
6B38  5009     MOVF 0x9, W, ACCESS
6B3A  B4D8     BTFSC 0xFD8, 2, ACCESS
6B3C  EFA2     GOTO 0x6B44
6B3E  F035     NOP
6B40  EFA4     GOTO 0x6B48
6B42  F035     NOP
6B44  EFAC     GOTO 0x6B58
6B46  F035     NOP
6B48  BE04     BTFSC 0x4, 7, ACCESS
6B4A  EFAB     GOTO 0x6B56
6B4C  F035     NOP
6B4E  EFA9     GOTO 0x6B52
6B50  F035     NOP
6B52  EFAC     GOTO 0x6B58
6B54  F035     NOP
42:            		arg |= 0x80000000UL;
6B56  8E0E     BSF 0xE, 7, ACCESS
43:            	return *(double *)&arg;
6B5A  F42C     NOP
6B5C  F501     NOP
6B60  F430     NOP
6B62  F502     NOP
6B66  F434     NOP
6B68  F503     NOP
6B6C  F438     NOP
6B6E  F504     NOP
44:            }
6B70  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/tolower.c  -----------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             
4:             int tolower(int c)
5:             {
6:             	if (isupper(c)) return c | 32;
7FFE  0EBF     MOVLW 0xBF
8000  0106     MOVLB 0x6
8002  6F08     MOVWF 0x8, BANKED
8004  0EFF     MOVLW 0xFF
8006  6F09     MOVWF 0x9, BANKED
800A  F818     NOP
800C  F60A     NOP
8010  F81C     NOP
8012  F60B     NOP
8014  5108     MOVF 0x8, W, BANKED
8016  270A     ADDWF 0xA, F, BANKED
8018  5109     MOVF 0x9, W, BANKED
801A  230B     ADDWFC 0xB, F, BANKED
801C  510B     MOVF 0xB, W, BANKED
801E  E10A     BNZ 0x8034
8020  0E1A     MOVLW 0x1A
8022  5D0A     SUBWF 0xA, W, BANKED
8024  A0D8     BTFSS 0xFD8, 0, ACCESS
8026  EF17     GOTO 0x802E
8028  F040     NOP
802A  EF1A     GOTO 0x8034
802C  F040     NOP
802E  0E01     MOVLW 0x1
8030  EF1B     GOTO 0x8036
8032  F040     NOP
8034  0E00     MOVLW 0x0
8036  6F0C     MOVWF 0xC, BANKED
8038  6B0D     CLRF 0xD, BANKED
803A  510C     MOVF 0xC, W, BANKED
803C  110D     IORWF 0xD, W, BANKED
803E  B4D8     BTFSC 0xFD8, 2, ACCESS
8040  EF24     GOTO 0x8048
8042  F040     NOP
8044  EF26     GOTO 0x804C
8046  F040     NOP
8048  EF2D     GOTO 0x805A
804A  F040     NOP
804C  0E20     MOVLW 0x20
804E  1106     IORWF 0x6, W, BANKED
8050  6F06     MOVWF 0x6, BANKED
8052  5107     MOVF 0x7, W, BANKED
8054  6F07     MOVWF 0x7, BANKED
8056  EF33     GOTO 0x8066
8058  F040     NOP
7:             	return c;
805C  F818     NOP
805E  F606     NOP
8062  F81C     NOP
8064  F607     NOP
8:             }
8066  0012     RETURN 0
9:             
10:            int __tolower_l(int c, locale_t l)
11:            {
12:            	return tolower(c);
13:            }
14:            
15:            weak_alias(__tolower_l, tolower_l);
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/strncmp.c  -----------------------
1:             #include <string.h>
2:             
3:             int strncmp(const char *_l, const char *_r, size_t n)
4:             {
5:             	const unsigned char *l=(void *)_l, *r=(void *)_r;
7602  F800     NOP
7604  F607     NOP
7608  F804     NOP
760A  F608     NOP
760E  F808     NOP
7610  F609     NOP
7614  F80C     NOP
7616  F60A     NOP
6:             	if (!n--) return 0;
7618  0106     MOVLB 0x6
761A  0704     DECF 0x4, F, BANKED
761C  A0D8     BTFSS 0xFD8, 0, ACCESS
761E  0705     DECF 0x5, F, BANKED
7620  2904     INCF 0x4, W, BANKED
7622  E106     BNZ 0x7630
7624  2905     INCF 0x5, W, BANKED
7626  A4D8     BTFSS 0xFD8, 2, ACCESS
7628  EF18     GOTO 0x7630
762A  F03B     NOP
762C  EF1A     GOTO 0x7634
762E  F03B     NOP
7630  EF27     GOTO 0x764E
7632  F03B     NOP
7634  0E00     MOVLW 0x0
7636  6F01     MOVWF 0x1, BANKED
7638  0E00     MOVLW 0x0
763A  6F00     MOVWF txData, BANKED
763C  EF81     GOTO 0x7702
763E  F03B     NOP
7:             	for (; *l && *r && n && *l == *r ; l++, r++, n--);
7640  4B07     INFSNZ 0x7, F, BANKED
7642  2B08     INCF 0x8, F, BANKED
7644  4B09     INFSNZ 0x9, F, BANKED
7646  2B0A     INCF 0xA, F, BANKED
7648  0704     DECF 0x4, F, BANKED
764A  A0D8     BTFSS 0xFD8, 0, ACCESS
764C  0705     DECF 0x5, F, BANKED
7650  F81C     NOP
7652  F4D9     NOP
7656  F820     NOP
7658  F4DA     NOP
765A  50DF     MOVF 0xFDF, W, ACCESS
765C  B4D8     BTFSC 0xFD8, 2, ACCESS
765E  EF33     GOTO 0x7666
7660  F03B     NOP
7662  EF35     GOTO 0x766A
7664  F03B     NOP
7666  EF6A     GOTO 0x76D4
7668  F03B     NOP
766C  F824     NOP
766E  F4F6     NOP
7672  F828     NOP
7674  F4F7     NOP
7676  0E00     MOVLW 0x0
7678  6EF8     MOVWF 0xFF8, ACCESS
767A  0008     TBLRD*
767C  50F5     MOVF 0xFF5, W, ACCESS
767E  0900     IORLW 0x0
7680  B4D8     BTFSC 0xFD8, 2, ACCESS
7682  EF45     GOTO 0x768A
7684  F03B     NOP
7686  EF47     GOTO 0x768E
7688  F03B     NOP
768A  EF6A     GOTO 0x76D4
768C  F03B     NOP
768E  5104     MOVF 0x4, W, BANKED
7690  1105     IORWF 0x5, W, BANKED
7692  B4D8     BTFSC 0xFD8, 2, ACCESS
7694  EF4E     GOTO 0x769C
7696  F03B     NOP
7698  EF50     GOTO 0x76A0
769A  F03B     NOP
769C  EF6A     GOTO 0x76D4
769E  F03B     NOP
76A2  F81C     NOP
76A4  F4D9     NOP
76A8  F820     NOP
76AA  F4DA     NOP
76AC  50DF     MOVF 0xFDF, W, ACCESS
76AE  6F06     MOVWF 0x6, BANKED
76B2  F824     NOP
76B4  F4F6     NOP
76B8  F828     NOP
76BA  F4F7     NOP
76BC  0E00     MOVLW 0x0
76BE  6EF8     MOVWF 0xFF8, ACCESS
76C0  0008     TBLRD*
76C2  50F5     MOVF 0xFF5, W, ACCESS
76C4  1906     XORWF 0x6, W, BANKED
76C6  B4D8     BTFSC 0xFD8, 2, ACCESS
76C8  EF68     GOTO 0x76D0
76CA  F03B     NOP
76CC  EF6A     GOTO 0x76D4
76CE  F03B     NOP
76D0  EF20     GOTO 0x7640
76D2  F03B     NOP
8:             	return *l - *r;
76D6  F81C     NOP
76D8  F4D9     NOP
76DC  F820     NOP
76DE  F4DA     NOP
76E0  50DF     MOVF 0xFDF, W, ACCESS
76E2  6F06     MOVWF 0x6, BANKED
76E6  F824     NOP
76E8  F4F6     NOP
76EC  F828     NOP
76EE  F4F7     NOP
76F0  0E00     MOVLW 0x0
76F2  6EF8     MOVWF 0xFF8, ACCESS
76F4  0008     TBLRD*
76F6  50F5     MOVF 0xFF5, W, ACCESS
76F8  5D06     SUBWF 0x6, W, BANKED
76FA  6F00     MOVWF txData, BANKED
76FC  6B01     CLRF 0x1, BANKED
76FE  A0D8     BTFSS 0xFD8, 0, ACCESS
7700  0701     DECF 0x1, F, BANKED
9:             }
7702  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/strlen.c  ------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             size_t strlen(const char *s)
6:             {
7:             	const char *a = s;
82BE  F800     NOP
82C0  F602     NOP
82C4  F804     NOP
82C6  F603     NOP
8:             	while(*s) {
82C8  EF69     GOTO 0x82D2
82CA  F041     NOP
82D4  F800     NOP
82D6  F4D9     NOP
82DA  F804     NOP
82DC  F4DA     NOP
82DE  50DF     MOVF 0xFDF, W, ACCESS
82E0  A4D8     BTFSS 0xFD8, 2, ACCESS
82E2  EF75     GOTO 0x82EA
82E4  F041     NOP
82E6  EF77     GOTO 0x82EE
82E8  F041     NOP
82EA  EF66     GOTO 0x82CC
82EC  F041     NOP
9:             		s++;
82CC  0106     MOVLB 0x6
82CE  4B00     INFSNZ txData, F, BANKED
82D0  2B01     INCF 0x1, F, BANKED
10:            	}
11:            	return s-a;
82EE  0106     MOVLB 0x6
82F0  5102     MOVF 0x2, W, BANKED
82F2  5D00     SUBWF txData, W, BANKED
82F4  6F00     MOVWF txData, BANKED
82F6  5103     MOVF 0x3, W, BANKED
82F8  5901     SUBWFB 0x1, W, BANKED
82FA  6F01     MOVWF 0x1, BANKED
12:            }
82FC  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/strcpy.c  ------------------------
1:             #include <string.h>
2:             
3:             char *strcpy(char *restrict dest, const char *restrict src)
4:             {
5:             	const char *s = src;
7F90  F808     NOP
7F92  F606     NOP
7F96  F80C     NOP
7F98  F607     NOP
6:             	char *d = dest;
7F9C  F800     NOP
7F9E  F608     NOP
7FA2  F804     NOP
7FA4  F609     NOP
7:             	while ((*d++ = *s++));
7FA6  0106     MOVLB 0x6
7FA8  5106     MOVF 0x6, W, BANKED
7FAA  6F04     MOVWF 0x4, BANKED
7FAC  5107     MOVF 0x7, W, BANKED
7FAE  6F05     MOVWF 0x5, BANKED
7FB0  4B06     INFSNZ 0x6, F, BANKED
7FB2  2B07     INCF 0x7, F, BANKED
7FB6  F810     NOP
7FB8  F4F6     NOP
7FBC  F814     NOP
7FBE  F4F7     NOP
7FC0  0E00     MOVLW 0x0
7FC2  6EF8     MOVWF 0xFF8, ACCESS
7FC6  F820     NOP
7FC8  F4D9     NOP
7FCC  F824     NOP
7FCE  F4DA     NOP
7FD0  4B08     INFSNZ 0x8, F, BANKED
7FD2  2B09     INCF 0x9, F, BANKED
7FD4  0E24     MOVLW 0x24
7FD6  64F7     CPFSGT 0xFF7, ACCESS
7FD8  D003     BRA 0x7FE0
7FDA  0008     TBLRD*
7FDC  50F5     MOVF 0xFF5, W, ACCESS
7FDE  D005     BRA 0x7FEA
7FE0  C4F6     MOVFF TBLPTR, FSR0
7FE2  F4E9     NOP
7FE4  C4F7     MOVFF TBLPTRH, FSR0H
7FE6  F4EA     NOP
7FE8  50EF     MOVF 0xFEF, W, ACCESS
7FEA  6EDF     MOVWF 0xFDF, ACCESS
7FEC  50DF     MOVF 0xFDF, W, ACCESS
7FEE  A4D8     BTFSS 0xFD8, 2, ACCESS
7FF0  EFFC     GOTO 0x7FF8
7FF2  F03F     NOP
7FF4  EFFE     GOTO 0x7FFC
7FF6  F03F     NOP
7FF8  EFD3     GOTO 0x7FA6
7FFA  F03F     NOP
8:             	return dest;
9:             }
7FFC  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/sprcmul.c  -----------------------
1:             /* SP relaxed compliance floating point multiply intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             /* SP Multiply */
6:             /* single monolithic routine */
7:             SP
8:             SPMUL(SP b, SP a) {
9:             	unsigned char sign;	/* sign of result */
10:            	unsigned char bexp;	/* Dst exponent */
11:            	unsigned char aexp;	/* Src exponent */
12:            	uint32_t grs;		/* Guard, round, sticky */
13:            	SFP prod;
14:            	wordProduct temp;	/* intermediate mult results ; exponent of result */
15:            
16:            	/* Unpack and check operands */
17:            	sign = (*(SFP *) & b).fAsBytes.d & 0x80;
5110  0106     MOVLB 0x6
5112  5103     MOVF 0x3, W, BANKED
5114  0B80     ANDLW 0x80
5116  6F0C     MOVWF 0xC, BANKED
559C  5004     MOVF 0x4, W, ACCESS
18:            	bexp = ((*(SFP *) & b).fAsBytes.d) << 1;
5118  5103     MOVF 0x3, W, BANKED
511A  2503     ADDWF 0x3, W, BANKED
511C  6F12     MOVWF 0x12, BANKED
55A2  5004     MOVF 0x4, W, ACCESS
55A4  2404     ADDWF 0x4, W, ACCESS
55A6  6E13     MOVWF 0x13, ACCESS
19:            	if ((*(SFP *) & b).fAsBytes.c & 0x80) {
511E  AF02     BTFSS 0x2, 7, BANKED
5120  EF94     GOTO 0x5128
5122  F028     NOP
5124  EF96     GOTO 0x512C
5126  F028     NOP
5128  EF97     GOTO 0x512E
512A  F028     NOP
55A8  AE03     BTFSS 0x3, 7, ACCESS
55AA  EFD9     GOTO 0x55B2
55AC  F02A     NOP
55AE  EFDB     GOTO 0x55B6
55B0  F02A     NOP
55B2  EFDC     GOTO 0x55B8
55B4  F02A     NOP
20:            		bexp |= 0x1;
512C  8112     BSF 0x12, 0, BANKED
55B6  8013     BSF 0x13, 0, ACCESS
21:            	}
22:            
23:            	/* Destination normal ? */
24:            	if (bexp) {
512E  5112     MOVF 0x12, W, BANKED
5130  B4D8     BTFSC 0xFD8, 2, ACCESS
5132  EF9D     GOTO 0x513A
5134  F028     NOP
5136  EF9F     GOTO 0x513E
5138  F028     NOP
513A  EFB2     GOTO 0x5164
513C  F028     NOP
55B8  5013     MOVF 0x13, W, ACCESS
55BA  B4D8     BTFSC 0xFD8, 2, ACCESS
55BC  EFE2     GOTO 0x55C4
55BE  F02A     NOP
55C0  EFE4     GOTO 0x55C8
55C2  F02A     NOP
55C4  EFF7     GOTO 0x55EE
55C6  F02A     NOP
25:            		/* Destination inf or NaN ? */
26:            		if (bexp == 0xFF) {
513E  2912     INCF 0x12, W, BANKED
5140  A4D8     BTFSS 0xFD8, 2, ACCESS
5142  EFA5     GOTO 0x514A
5144  F028     NOP
5146  EFA7     GOTO 0x514E
5148  F028     NOP
514A  EFAF     GOTO 0x515E
514C  F028     NOP
55C8  2813     INCF 0x13, W, ACCESS
55CA  A4D8     BTFSS 0xFD8, 2, ACCESS
55CC  EFEA     GOTO 0x55D4
55CE  F02A     NOP
55D0  EFEC     GOTO 0x55D8
55D2  F02A     NOP
55D4  EFF4     GOTO 0x55E8
55D6  F02A     NOP
27:            			/* Make it inf */
28:            			b = 0;
514E  0E00     MOVLW 0x0
5150  6F00     MOVWF txData, BANKED
5152  0E00     MOVLW 0x0
5154  6F01     MOVWF 0x1, BANKED
5156  0E00     MOVLW 0x0
5158  6F02     MOVWF 0x2, BANKED
515A  0E00     MOVLW 0x0
515C  6F03     MOVWF 0x3, BANKED
55D8  0E00     MOVLW 0x0
55DA  6E01     MOVWF 0x1, ACCESS
55DC  0E00     MOVLW 0x0
55DE  6E02     MOVWF 0x2, ACCESS
55E0  0E00     MOVLW 0x0
55E2  6E03     MOVWF 0x3, ACCESS
55E4  0E00     MOVLW 0x0
55E6  6E04     MOVWF 0x4, ACCESS
29:            		}
30:            		// and in the implied 1-bit to b's fraction
31:            		(*(SFP *) & b).i |= (int32_t) 1 << SPFRCB;
515E  8F02     BSF 0x2, 7, BANKED
55E8  8E03     BSF 0x3, 7, ACCESS
32:            
33:            	}
5160  EFBA     GOTO 0x5174
5162  F028     NOP
55EA  EFFF     GOTO 0x55FE
55EC  F02A     NOP
34:            	else {
35:            		/* Make it zero */
36:            		b = 0;
5164  0E00     MOVLW 0x0
5166  6F00     MOVWF txData, BANKED
5168  0E00     MOVLW 0x0
516A  6F01     MOVWF 0x1, BANKED
516C  0E00     MOVLW 0x0
516E  6F02     MOVWF 0x2, BANKED
5170  0E00     MOVLW 0x0
5172  6F03     MOVWF 0x3, BANKED
55EE  0E00     MOVLW 0x0
55F0  6E01     MOVWF 0x1, ACCESS
55F2  0E00     MOVLW 0x0
55F4  6E02     MOVWF 0x2, ACCESS
55F6  0E00     MOVLW 0x0
55F8  6E03     MOVWF 0x3, ACCESS
55FA  0E00     MOVLW 0x0
55FC  6E04     MOVWF 0x4, ACCESS
37:            	}
38:            
39:            	sign ^= (*(SFP *) & a).fAsBytes.d & 0x80;
5174  5107     MOVF 0x7, W, BANKED
5176  0B80     ANDLW 0x80
5178  1B0C     XORWF 0xC, F, BANKED
55FE  5008     MOVF 0x8, W, ACCESS
5600  0B80     ANDLW 0x80
5602  1A0D     XORWF 0xD, F, ACCESS
40:            	aexp = ((*(SFP *) & a).fAsBytes.d) << 1;
517A  5107     MOVF 0x7, W, BANKED
517C  2507     ADDWF 0x7, W, BANKED
517E  6F11     MOVWF 0x11, BANKED
5604  5008     MOVF 0x8, W, ACCESS
5606  2408     ADDWF 0x8, W, ACCESS
5608  6E12     MOVWF 0x12, ACCESS
41:            	if ((*(SFP *) & a).fAsBytes.c & 0x80) {
5180  AF06     BTFSS 0x6, 7, BANKED
5182  EFC5     GOTO 0x518A
5184  F028     NOP
5186  EFC7     GOTO 0x518E
5188  F028     NOP
518A  EFC8     GOTO 0x5190
518C  F028     NOP
560A  AE07     BTFSS 0x7, 7, ACCESS
560C  EF0A     GOTO 0x5614
560E  F02B     NOP
5610  EF0C     GOTO 0x5618
5612  F02B     NOP
5614  EF0D     GOTO 0x561A
5616  F02B     NOP
42:            		aexp |= 0x1;
518E  8111     BSF 0x11, 0, BANKED
5618  8012     BSF 0x12, 0, ACCESS
43:            	}
44:            	/* Destination normal ? */
45:            	if (aexp) {
5190  5111     MOVF 0x11, W, BANKED
5192  B4D8     BTFSC 0xFD8, 2, ACCESS
5194  EFCE     GOTO 0x519C
5196  F028     NOP
5198  EFD0     GOTO 0x51A0
519A  F028     NOP
519C  EFE3     GOTO 0x51C6
519E  F028     NOP
561A  5012     MOVF 0x12, W, ACCESS
561C  B4D8     BTFSC 0xFD8, 2, ACCESS
561E  EF13     GOTO 0x5626
5620  F02B     NOP
5622  EF15     GOTO 0x562A
5624  F02B     NOP
5626  EF28     GOTO 0x5650
5628  F02B     NOP
46:            
47:            		/* Destination inf or NaN ? */
48:            		if (aexp == 0xFF) {
51A0  2911     INCF 0x11, W, BANKED
51A2  A4D8     BTFSS 0xFD8, 2, ACCESS
51A4  EFD6     GOTO 0x51AC
51A6  F028     NOP
51A8  EFD8     GOTO 0x51B0
51AA  F028     NOP
51AC  EFE0     GOTO 0x51C0
51AE  F028     NOP
562A  2812     INCF 0x12, W, ACCESS
562C  A4D8     BTFSS 0xFD8, 2, ACCESS
562E  EF1B     GOTO 0x5636
5630  F02B     NOP
5632  EF1D     GOTO 0x563A
5634  F02B     NOP
5636  EF25     GOTO 0x564A
5638  F02B     NOP
49:            			/* Make it inf */
50:            			a = 0;
51B0  0E00     MOVLW 0x0
51B2  6F04     MOVWF 0x4, BANKED
51B4  0E00     MOVLW 0x0
51B6  6F05     MOVWF 0x5, BANKED
51B8  0E00     MOVLW 0x0
51BA  6F06     MOVWF 0x6, BANKED
51BC  0E00     MOVLW 0x0
51BE  6F07     MOVWF 0x7, BANKED
563A  0E00     MOVLW 0x0
563C  6E05     MOVWF 0x5, ACCESS
563E  0E00     MOVLW 0x0
5640  6E06     MOVWF 0x6, ACCESS
5642  0E00     MOVLW 0x0
5644  6E07     MOVWF 0x7, ACCESS
5646  0E00     MOVLW 0x0
5648  6E08     MOVWF 0x8, ACCESS
51:            		}
52:            		// and in the implied 1-bit to a's fraction
53:            		(*(SFP *) & a).i |= (int32_t) 1 << SPFRCB;
51C0  8F06     BSF 0x6, 7, BANKED
564A  8E07     BSF 0x7, 7, ACCESS
54:            	}
51C2  EFEB     GOTO 0x51D6
51C4  F028     NOP
564C  EF30     GOTO 0x5660
564E  F02B     NOP
55:            	else {
56:            		/* Make it zero */
57:            		a = 0;
51C6  0E00     MOVLW 0x0
51C8  6F04     MOVWF 0x4, BANKED
51CA  0E00     MOVLW 0x0
51CC  6F05     MOVWF 0x5, BANKED
51CE  0E00     MOVLW 0x0
51D0  6F06     MOVWF 0x6, BANKED
51D2  0E00     MOVLW 0x0
51D4  6F07     MOVWF 0x7, BANKED
5650  0E00     MOVLW 0x0
5652  6E05     MOVWF 0x5, ACCESS
5654  0E00     MOVLW 0x0
5656  6E06     MOVWF 0x6, ACCESS
5658  0E00     MOVLW 0x0
565A  6E07     MOVWF 0x7, ACCESS
565C  0E00     MOVLW 0x0
565E  6E08     MOVWF 0x8, ACCESS
58:            	}
59:            
60:            	/* Multiply */
61:            
62:            	/* Special operand check */
63:            
64:            	/* Source or destination zero ? Result zero */
65:            	if (aexp == 0 || bexp == 0) {
51D6  5111     MOVF 0x11, W, BANKED
51D8  B4D8     BTFSC 0xFD8, 2, ACCESS
51DA  EFF1     GOTO 0x51E2
51DC  F028     NOP
51DE  EFF3     GOTO 0x51E6
51E0  F028     NOP
51E2  EFFB     GOTO 0x51F6
51E4  F028     NOP
51E6  5112     MOVF 0x12, W, BANKED
51E8  A4D8     BTFSS 0xFD8, 2, ACCESS
51EA  EFF9     GOTO 0x51F2
51EC  F028     NOP
51EE  EFFB     GOTO 0x51F6
51F0  F028     NOP
51F2  EF05     GOTO 0x520A
51F4  F029     NOP
5660  5012     MOVF 0x12, W, ACCESS
5662  B4D8     BTFSC 0xFD8, 2, ACCESS
5664  EF36     GOTO 0x566C
5666  F02B     NOP
5668  EF38     GOTO 0x5670
566A  F02B     NOP
566C  EF40     GOTO 0x5680
566E  F02B     NOP
5670  5013     MOVF 0x13, W, ACCESS
5672  A4D8     BTFSS 0xFD8, 2, ACCESS
5674  EF3E     GOTO 0x567C
5676  F02B     NOP
5678  EF40     GOTO 0x5680
567A  F02B     NOP
567C  EF4A     GOTO 0x5694
567E  F02B     NOP
66:            		return 0.0;
51F6  0E00     MOVLW 0x0
51F8  6F00     MOVWF txData, BANKED
51FA  0E00     MOVLW 0x0
51FC  6F01     MOVWF 0x1, BANKED
51FE  0E00     MOVLW 0x0
5200  6F02     MOVWF 0x2, BANKED
5202  0E00     MOVLW 0x0
5204  6F03     MOVWF 0x3, BANKED
5206  EFCD     GOTO 0x559A
5208  F02A     NOP
5680  0E00     MOVLW 0x0
5682  6E01     MOVWF 0x1, ACCESS
5684  0E00     MOVLW 0x0
5686  6E02     MOVWF 0x2, ACCESS
5688  0E00     MOVLW 0x0
568A  6E03     MOVWF 0x3, ACCESS
568C  0E00     MOVLW 0x0
568E  6E04     MOVWF 0x4, ACCESS
5690  EF12     GOTO 0x5A24
5692  F02D     NOP
67:            	}
68:            
69:            //    we decompose a 24 bit multiply into 9 8 bit multiplies as follows:
70:            //
71:            //    b's fraction is b1|b2|b3 and a's fraction is a1|a2|a3
72:            //
73:            //    then ab is the (48 bit) sum of these 9 16 bit intermediate products shifted appropriately
74:            //
75:            //
76:            //                                     a3b3
77:            //                                   a2b3
78:            //                                   a3b2
79:            //                                 a1b3
80:            //                                 a2b2
81:            //                                 a3b1
82:            //                               a1b2
83:            //                               a2b1
84:            //                             a1b1
85:            //
86:            //   in this algorithm we compute the product to be the upper 24 bits of the sum and grs to be the lower 24 bits
87:            //   shifted 8 to the left     then we renormalize and round as usual.
88:            //
89:            
90:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
91:            #define MIDBYTE(x)  (*(((unsigned char *)(&x))+1))
92:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+2))
93:            
94:            #ifdef _PIC18
95:            	temp.n = HIGHBYTE(a) * LOWBYTE(b);
520A  5106     MOVF 0x6, W, BANKED
520C  0300     MULWF txData, BANKED
5210  F3CC     NOP
5212  F617     NOP
5216  F3D0     NOP
5218  F618     NOP
5694  5007     MOVF 0x7, W, ACCESS
5696  0201     MULWF 0x1, ACCESS
569A  F3CC     NOP
569C  F518     NOP
56A0  F3D0     NOP
56A2  F519     NOP
96:            	grs = temp.nAsBytes.a;
521A  5117     MOVF 0x17, W, BANKED
521C  6F0D     MOVWF 0xD, BANKED
521E  6B0E     CLRF 0xE, BANKED
5220  6B0F     CLRF 0xF, BANKED
5222  6B10     CLRF 0x10, BANKED
56A4  5018     MOVF 0x18, W, ACCESS
56A6  6E0E     MOVWF 0xE, ACCESS
56A8  6A0F     CLRF 0xF, ACCESS
56AA  6A10     CLRF 0x10, ACCESS
56AC  6A11     CLRF 0x11, ACCESS
97:            	prod.i = temp.nAsBytes.b;
5224  5118     MOVF 0x18, W, BANKED
5226  6F13     MOVWF 0x13, BANKED
5228  6B14     CLRF 0x14, BANKED
522A  6B15     CLRF 0x15, BANKED
522C  6B16     CLRF 0x16, BANKED
56AE  5019     MOVF 0x19, W, ACCESS
56B0  6E14     MOVWF 0x14, ACCESS
56B2  6A15     CLRF 0x15, ACCESS
56B4  6A16     CLRF 0x16, ACCESS
56B6  6A17     CLRF 0x17, ACCESS
98:            	temp.n = MIDBYTE(a) * MIDBYTE(b);
522E  5105     MOVF 0x5, W, BANKED
5230  0301     MULWF 0x1, BANKED
5234  F3CC     NOP
5236  F617     NOP
523A  F3D0     NOP
523C  F618     NOP
56B8  5006     MOVF 0x6, W, ACCESS
56BA  0202     MULWF 0x2, ACCESS
56BE  F3CC     NOP
56C0  F518     NOP
56C4  F3D0     NOP
56C6  F519     NOP
99:            	grs += temp.nAsBytes.a;
523E  5117     MOVF 0x17, W, BANKED
5240  270D     ADDWF 0xD, F, BANKED
5242  0E00     MOVLW 0x0
5244  230E     ADDWFC 0xE, F, BANKED
5246  230F     ADDWFC 0xF, F, BANKED
5248  2310     ADDWFC 0x10, F, BANKED
56C8  5018     MOVF 0x18, W, ACCESS
56CA  260E     ADDWF 0xE, F, ACCESS
56CC  0E00     MOVLW 0x0
56CE  220F     ADDWFC 0xF, F, ACCESS
56D0  2210     ADDWFC 0x10, F, ACCESS
56D2  2211     ADDWFC 0x11, F, ACCESS
100:           	prod.i += temp.nAsBytes.b;
524A  5118     MOVF 0x18, W, BANKED
524C  2713     ADDWF 0x13, F, BANKED
524E  0E00     MOVLW 0x0
5250  2314     ADDWFC 0x14, F, BANKED
5252  2315     ADDWFC 0x15, F, BANKED
5254  2316     ADDWFC 0x16, F, BANKED
56D4  5019     MOVF 0x19, W, ACCESS
56D6  2614     ADDWF 0x14, F, ACCESS
56D8  0E00     MOVLW 0x0
56DA  2215     ADDWFC 0x15, F, ACCESS
56DC  2216     ADDWFC 0x16, F, ACCESS
56DE  2217     ADDWFC 0x17, F, ACCESS
101:           	temp.n = LOWBYTE(a) * HIGHBYTE(b);
5256  5104     MOVF 0x4, W, BANKED
5258  0302     MULWF 0x2, BANKED
525C  F3CC     NOP
525E  F617     NOP
5262  F3D0     NOP
5264  F618     NOP
56E0  5005     MOVF 0x5, W, ACCESS
56E2  0203     MULWF 0x3, ACCESS
56E6  F3CC     NOP
56E8  F518     NOP
56EC  F3D0     NOP
56EE  F519     NOP
102:           	grs += temp.nAsBytes.a;
5266  5117     MOVF 0x17, W, BANKED
5268  270D     ADDWF 0xD, F, BANKED
526A  0E00     MOVLW 0x0
526C  230E     ADDWFC 0xE, F, BANKED
526E  230F     ADDWFC 0xF, F, BANKED
5270  2310     ADDWFC 0x10, F, BANKED
56F0  5018     MOVF 0x18, W, ACCESS
56F2  260E     ADDWF 0xE, F, ACCESS
56F4  0E00     MOVLW 0x0
56F6  220F     ADDWFC 0xF, F, ACCESS
56F8  2210     ADDWFC 0x10, F, ACCESS
56FA  2211     ADDWFC 0x11, F, ACCESS
103:           	prod.i += temp.nAsBytes.b;
5272  5118     MOVF 0x18, W, BANKED
5274  2713     ADDWF 0x13, F, BANKED
5276  0E00     MOVLW 0x0
5278  2314     ADDWFC 0x14, F, BANKED
527A  2315     ADDWFC 0x15, F, BANKED
527C  2316     ADDWFC 0x16, F, BANKED
56FC  5019     MOVF 0x19, W, ACCESS
56FE  2614     ADDWF 0x14, F, ACCESS
5700  0E00     MOVLW 0x0
5702  2215     ADDWFC 0x15, F, ACCESS
5704  2216     ADDWFC 0x16, F, ACCESS
5706  2217     ADDWFC 0x17, F, ACCESS
104:           	grs <<= 8;
5280  F83C     NOP
5282  F610     NOP
5286  F838     NOP
5288  F60F     NOP
528C  F834     NOP
528E  F60E     NOP
5290  6B0D     CLRF 0xD, BANKED
570A  F440     NOP
570C  F511     NOP
5710  F43C     NOP
5712  F510     NOP
5716  F438     NOP
5718  F50F     NOP
571A  6A0E     CLRF 0xE, ACCESS
105:           	temp.n = LOWBYTE(a) * MIDBYTE(b);
5292  5104     MOVF 0x4, W, BANKED
5294  0301     MULWF 0x1, BANKED
5298  F3CC     NOP
529A  F617     NOP
529E  F3D0     NOP
52A0  F618     NOP
571C  5005     MOVF 0x5, W, ACCESS
571E  0202     MULWF 0x2, ACCESS
5722  F3CC     NOP
5724  F518     NOP
5728  F3D0     NOP
572A  F519     NOP
106:           	grs += (unsigned long)temp.n;
52A2  5117     MOVF 0x17, W, BANKED
52A4  270D     ADDWF 0xD, F, BANKED
52A6  5118     MOVF 0x18, W, BANKED
52A8  230E     ADDWFC 0xE, F, BANKED
52AA  0E00     MOVLW 0x0
52AC  230F     ADDWFC 0xF, F, BANKED
52AE  0E00     MOVLW 0x0
52B0  2310     ADDWFC 0x10, F, BANKED
572C  5018     MOVF 0x18, W, ACCESS
572E  260E     ADDWF 0xE, F, ACCESS
5730  5019     MOVF 0x19, W, ACCESS
5732  220F     ADDWFC 0xF, F, ACCESS
5734  0E00     MOVLW 0x0
5736  2210     ADDWFC 0x10, F, ACCESS
5738  0E00     MOVLW 0x0
573A  2211     ADDWFC 0x11, F, ACCESS
107:           	temp.n = MIDBYTE(a) * LOWBYTE(b);
52B2  5105     MOVF 0x5, W, BANKED
52B4  0300     MULWF txData, BANKED
52B8  F3CC     NOP
52BA  F617     NOP
52BE  F3D0     NOP
52C0  F618     NOP
573C  5006     MOVF 0x6, W, ACCESS
573E  0201     MULWF 0x1, ACCESS
5742  F3CC     NOP
5744  F518     NOP
5748  F3D0     NOP
574A  F519     NOP
108:           	grs += (unsigned long)temp.n;
52C2  5117     MOVF 0x17, W, BANKED
52C4  270D     ADDWF 0xD, F, BANKED
52C6  5118     MOVF 0x18, W, BANKED
52C8  230E     ADDWFC 0xE, F, BANKED
52CA  0E00     MOVLW 0x0
52CC  230F     ADDWFC 0xF, F, BANKED
52CE  0E00     MOVLW 0x0
52D0  2310     ADDWFC 0x10, F, BANKED
574C  5018     MOVF 0x18, W, ACCESS
574E  260E     ADDWF 0xE, F, ACCESS
5750  5019     MOVF 0x19, W, ACCESS
5752  220F     ADDWFC 0xF, F, ACCESS
5754  0E00     MOVLW 0x0
5756  2210     ADDWFC 0x10, F, ACCESS
5758  0E00     MOVLW 0x0
575A  2211     ADDWFC 0x11, F, ACCESS
109:           	grs <<= 8;
52D4  F83C     NOP
52D6  F610     NOP
52DA  F838     NOP
52DC  F60F     NOP
52E0  F834     NOP
52E2  F60E     NOP
52E4  6B0D     CLRF 0xD, BANKED
575E  F440     NOP
5760  F511     NOP
5764  F43C     NOP
5766  F510     NOP
576A  F438     NOP
576C  F50F     NOP
576E  6A0E     CLRF 0xE, ACCESS
110:           	temp.n = LOWBYTE(a) * LOWBYTE(b);
52E6  5104     MOVF 0x4, W, BANKED
52E8  0300     MULWF txData, BANKED
52EC  F3CC     NOP
52EE  F617     NOP
52F2  F3D0     NOP
52F4  F618     NOP
5770  5005     MOVF 0x5, W, ACCESS
5772  0201     MULWF 0x1, ACCESS
5776  F3CC     NOP
5778  F518     NOP
577C  F3D0     NOP
577E  F519     NOP
111:           	grs += (unsigned long)temp.n;
52F6  5117     MOVF 0x17, W, BANKED
52F8  270D     ADDWF 0xD, F, BANKED
52FA  5118     MOVF 0x18, W, BANKED
52FC  230E     ADDWFC 0xE, F, BANKED
52FE  0E00     MOVLW 0x0
5300  230F     ADDWFC 0xF, F, BANKED
5302  0E00     MOVLW 0x0
5304  2310     ADDWFC 0x10, F, BANKED
5780  5018     MOVF 0x18, W, ACCESS
5782  260E     ADDWF 0xE, F, ACCESS
5784  5019     MOVF 0x19, W, ACCESS
5786  220F     ADDWFC 0xF, F, ACCESS
5788  0E00     MOVLW 0x0
578A  2210     ADDWFC 0x10, F, ACCESS
578C  0E00     MOVLW 0x0
578E  2211     ADDWFC 0x11, F, ACCESS
112:           	temp.n = HIGHBYTE(a) * MIDBYTE(b);
5306  5106     MOVF 0x6, W, BANKED
5308  0301     MULWF 0x1, BANKED
530C  F3CC     NOP
530E  F617     NOP
5312  F3D0     NOP
5314  F618     NOP
5790  5007     MOVF 0x7, W, ACCESS
5792  0202     MULWF 0x2, ACCESS
5796  F3CC     NOP
5798  F518     NOP
579C  F3D0     NOP
579E  F519     NOP
113:           	prod.i += (unsigned long)temp.n;
5316  5117     MOVF 0x17, W, BANKED
5318  2713     ADDWF 0x13, F, BANKED
531A  5118     MOVF 0x18, W, BANKED
531C  2314     ADDWFC 0x14, F, BANKED
531E  0E00     MOVLW 0x0
5320  2315     ADDWFC 0x15, F, BANKED
5322  0E00     MOVLW 0x0
5324  2316     ADDWFC 0x16, F, BANKED
57A0  5018     MOVF 0x18, W, ACCESS
57A2  2614     ADDWF 0x14, F, ACCESS
57A4  5019     MOVF 0x19, W, ACCESS
57A6  2215     ADDWFC 0x15, F, ACCESS
57A8  0E00     MOVLW 0x0
57AA  2216     ADDWFC 0x16, F, ACCESS
57AC  0E00     MOVLW 0x0
57AE  2217     ADDWFC 0x17, F, ACCESS
114:           	temp.n = MIDBYTE(a) * HIGHBYTE(b);
5326  5105     MOVF 0x5, W, BANKED
5328  0302     MULWF 0x2, BANKED
532C  F3CC     NOP
532E  F617     NOP
5332  F3D0     NOP
5334  F618     NOP
57B0  5006     MOVF 0x6, W, ACCESS
57B2  0203     MULWF 0x3, ACCESS
57B6  F3CC     NOP
57B8  F518     NOP
57BC  F3D0     NOP
57BE  F519     NOP
115:           	prod.i += (unsigned long)temp.n;
5336  5117     MOVF 0x17, W, BANKED
5338  2713     ADDWF 0x13, F, BANKED
533A  5118     MOVF 0x18, W, BANKED
533C  2314     ADDWFC 0x14, F, BANKED
533E  0E00     MOVLW 0x0
5340  2315     ADDWFC 0x15, F, BANKED
5342  0E00     MOVLW 0x0
5344  2316     ADDWFC 0x16, F, BANKED
57C0  5018     MOVF 0x18, W, ACCESS
57C2  2614     ADDWF 0x14, F, ACCESS
57C4  5019     MOVF 0x19, W, ACCESS
57C6  2215     ADDWFC 0x15, F, ACCESS
57C8  0E00     MOVLW 0x0
57CA  2216     ADDWFC 0x16, F, ACCESS
57CC  0E00     MOVLW 0x0
57CE  2217     ADDWFC 0x17, F, ACCESS
116:           	temp.n = HIGHBYTE(a) * HIGHBYTE(b);
5346  5106     MOVF 0x6, W, BANKED
5348  0302     MULWF 0x2, BANKED
534C  F3CC     NOP
534E  F617     NOP
5352  F3D0     NOP
5354  F618     NOP
57D0  5007     MOVF 0x7, W, ACCESS
57D2  0203     MULWF 0x3, ACCESS
57D6  F3CC     NOP
57D8  F518     NOP
57DC  F3D0     NOP
57DE  F519     NOP
117:           	prod.i += (((unsigned long)temp.n) << 8);
5356  5117     MOVF 0x17, W, BANKED
5358  6F08     MOVWF 0x8, BANKED
535A  5118     MOVF 0x18, W, BANKED
535C  6F09     MOVWF 0x9, BANKED
535E  6B0A     CLRF 0xA, BANKED
5360  6B0B     CLRF 0xB, BANKED
5364  F828     NOP
5366  F60B     NOP
536A  F824     NOP
536C  F60A     NOP
5370  F820     NOP
5372  F609     NOP
5374  6B08     CLRF 0x8, BANKED
5376  5108     MOVF 0x8, W, BANKED
5378  2713     ADDWF 0x13, F, BANKED
537A  5109     MOVF 0x9, W, BANKED
537C  2314     ADDWFC 0x14, F, BANKED
537E  510A     MOVF 0xA, W, BANKED
5380  2315     ADDWFC 0x15, F, BANKED
5382  510B     MOVF 0xB, W, BANKED
5384  2316     ADDWFC 0x16, F, BANKED
57E0  5018     MOVF 0x18, W, ACCESS
57E2  6E09     MOVWF 0x9, ACCESS
57E4  5019     MOVF 0x19, W, ACCESS
57E6  6E0A     MOVWF 0xA, ACCESS
57E8  6A0B     CLRF 0xB, ACCESS
57EA  6A0C     CLRF 0xC, ACCESS
57EE  F42C     NOP
57F0  F50C     NOP
57F4  F428     NOP
57F6  F50B     NOP
57FA  F424     NOP
57FC  F50A     NOP
57FE  6A09     CLRF 0x9, ACCESS
5800  5009     MOVF 0x9, W, ACCESS
5802  2614     ADDWF 0x14, F, ACCESS
5804  500A     MOVF 0xA, W, ACCESS
5806  2215     ADDWFC 0x15, F, ACCESS
5808  500B     MOVF 0xB, W, ACCESS
580A  2216     ADDWFC 0x16, F, ACCESS
580C  500C     MOVF 0xC, W, ACCESS
580E  2217     ADDWFC 0x17, F, ACCESS
118:           #else
119:           	temp.n = _Umul8_16(HIGHBYTE(a), LOWBYTE(b));
120:           	grs = temp.nAsBytes.a;
121:           	prod.i = temp.nAsBytes.b;
122:           	temp.n = _Umul8_16(MIDBYTE(a), MIDBYTE(b));
123:           	grs += temp.nAsBytes.a;
124:           	prod.i += temp.nAsBytes.b;
125:           	temp.n = _Umul8_16(LOWBYTE(a), HIGHBYTE(b));
126:           	grs += temp.nAsBytes.a;
127:           	prod.i += temp.nAsBytes.b;
128:           	grs <<= 8;
129:           	temp.n = _Umul8_16(LOWBYTE(a), MIDBYTE(b));
130:           	grs += (unsigned long)temp.n;
131:           	temp.n = _Umul8_16(MIDBYTE(a), LOWBYTE(b));
132:           	grs += (unsigned long)temp.n;
133:           	grs <<= 8;
134:           	temp.n = _Umul8_16(LOWBYTE(a), LOWBYTE(b));
135:           	grs += (unsigned long)temp.n;
136:           	temp.n = _Umul8_16(HIGHBYTE(a), MIDBYTE(b));
137:           	prod.i += (unsigned long)temp.n;
138:           	temp.n = _Umul8_16(MIDBYTE(a), HIGHBYTE(b));
139:           	prod.i += (unsigned long)temp.n;
140:           	temp.n = _Umul8_16(HIGHBYTE(a), HIGHBYTE(b));
141:           	prod.i += (((unsigned long)temp.n) << 8);
142:           #endif
143:           
144:           	// first add the overflow bit from the lower half to the upper half
145:           	prod.i += (grs >> 24);
5388  F834     NOP
538A  F608     NOP
538E  F838     NOP
5390  F609     NOP
5394  F83C     NOP
5396  F60A     NOP
539A  F840     NOP
539C  F60B     NOP
539E  0E19     MOVLW 0x19
53A0  EFD7     GOTO 0x53AE
53A2  F029     NOP
53A4  90D8     BCF 0xFD8, 0, ACCESS
53A6  330B     RRCF 0xB, F, BANKED
53A8  330A     RRCF 0xA, F, BANKED
53AA  3309     RRCF 0x9, F, BANKED
53AC  3308     RRCF 0x8, F, BANKED
53AE  2EE8     DECFSZ 0xFE8, F, ACCESS
53B0  EFD2     GOTO 0x53A4
53B2  F029     NOP
53B4  5108     MOVF 0x8, W, BANKED
53B6  2713     ADDWF 0x13, F, BANKED
53B8  5109     MOVF 0x9, W, BANKED
53BA  2314     ADDWFC 0x14, F, BANKED
53BC  510A     MOVF 0xA, W, BANKED
53BE  2315     ADDWFC 0x15, F, BANKED
53C0  510B     MOVF 0xB, W, BANKED
53C2  2316     ADDWFC 0x16, F, BANKED
5812  F438     NOP
5814  F509     NOP
5818  F43C     NOP
581A  F50A     NOP
581E  F440     NOP
5820  F50B     NOP
5824  F444     NOP
5826  F50C     NOP
5828  0E19     MOVLW 0x19
582A  EF1C     GOTO 0x5838
582C  F02C     NOP
582E  90D8     BCF 0xFD8, 0, ACCESS
5830  320C     RRCF 0xC, F, ACCESS
5832  320B     RRCF 0xB, F, ACCESS
5834  320A     RRCF 0xA, F, ACCESS
5836  3209     RRCF 0x9, F, ACCESS
5838  2EE8     DECFSZ 0xFE8, F, ACCESS
583A  EF17     GOTO 0x582E
583C  F02C     NOP
583E  5009     MOVF 0x9, W, ACCESS
5840  2614     ADDWF 0x14, F, ACCESS
5842  500A     MOVF 0xA, W, ACCESS
5844  2215     ADDWFC 0x15, F, ACCESS
5846  500B     MOVF 0xB, W, ACCESS
5848  2216     ADDWFC 0x16, F, ACCESS
584A  500C     MOVF 0xC, W, ACCESS
584C  2217     ADDWFC 0x17, F, ACCESS
146:           	grs <<= 8;
53C6  F83C     NOP
53C8  F610     NOP
53CC  F838     NOP
53CE  F60F     NOP
53D2  F834     NOP
53D4  F60E     NOP
53D6  6B0D     CLRF 0xD, BANKED
5850  F440     NOP
5852  F511     NOP
5856  F43C     NOP
5858  F510     NOP
585C  F438     NOP
585E  F50F     NOP
5860  6A0E     CLRF 0xE, ACCESS
147:           
148:           	/* Add source exponent, minus (bias - 1) */
149:           	temp.i = bexp + aexp - 126;
53D8  5111     MOVF 0x11, W, BANKED
53DC  F848     NOP
53DE  F608     NOP
53E0  6B09     CLRF 0x9, BANKED
53E2  2708     ADDWF 0x8, F, BANKED
53E4  0E00     MOVLW 0x0
53E6  2309     ADDWFC 0x9, F, BANKED
53E8  0E82     MOVLW 0x82
53EA  2508     ADDWF 0x8, W, BANKED
53EC  6F17     MOVWF 0x17, BANKED
53EE  0EFF     MOVLW 0xFF
53F0  2109     ADDWFC 0x9, W, BANKED
53F2  6F18     MOVWF 0x18, BANKED
5862  5012     MOVF 0x12, W, ACCESS
5866  F44C     NOP
5868  F509     NOP
586A  6A0A     CLRF 0xA, ACCESS
586C  2609     ADDWF 0x9, F, ACCESS
586E  0E00     MOVLW 0x0
5870  220A     ADDWFC 0xA, F, ACCESS
5872  0E82     MOVLW 0x82
5874  2409     ADDWF 0x9, W, ACCESS
5876  6E18     MOVWF 0x18, ACCESS
5878  0EFF     MOVLW 0xFF
587A  200A     ADDWFC 0xA, W, ACCESS
587C  6E19     MOVWF 0x19, ACCESS
150:           
151:           	/* Renormalize  */
152:           	while (!(prod.i & ((int32_t) 1 << SPFRCB))) {
53F4  EF11     GOTO 0x5422
53F6  F02A     NOP
5422  AF15     BTFSS 0x15, 7, BANKED
5424  EF16     GOTO 0x542C
5426  F02A     NOP
5428  EF18     GOTO 0x5430
542A  F02A     NOP
542C  EFFC     GOTO 0x53F8
542E  F029     NOP
587E  EF56     GOTO 0x58AC
5880  F02C     NOP
58AC  AE16     BTFSS 0x16, 7, ACCESS
58AE  EF5B     GOTO 0x58B6
58B0  F02C     NOP
58B2  EF5D     GOTO 0x58BA
58B4  F02C     NOP
58B6  EF41     GOTO 0x5882
58B8  F02C     NOP
153:           		prod.i <<= 1;
53F8  90D8     BCF 0xFD8, 0, ACCESS
53FA  3713     RLCF 0x13, F, BANKED
53FC  3714     RLCF 0x14, F, BANKED
53FE  3715     RLCF 0x15, F, BANKED
5400  3716     RLCF 0x16, F, BANKED
5882  90D8     BCF 0xFD8, 0, ACCESS
5884  3614     RLCF 0x14, F, ACCESS
5886  3615     RLCF 0x15, F, ACCESS
5888  3616     RLCF 0x16, F, ACCESS
588A  3617     RLCF 0x17, F, ACCESS
154:           		if (grs & 0x80000000) {
5402  AF10     BTFSS 0x10, 7, BANKED
5404  EF06     GOTO 0x540C
5406  F02A     NOP
5408  EF08     GOTO 0x5410
540A  F02A     NOP
540C  EF09     GOTO 0x5412
540E  F02A     NOP
588C  AE11     BTFSS 0x11, 7, ACCESS
588E  EF4B     GOTO 0x5896
5890  F02C     NOP
5892  EF4D     GOTO 0x589A
5894  F02C     NOP
5896  EF4E     GOTO 0x589C
5898  F02C     NOP
155:           			prod.i |= 0x1;
5410  8113     BSF 0x13, 0, BANKED
589A  8014     BSF 0x14, 0, ACCESS
156:           		}
157:           		grs <<= 1;
5412  90D8     BCF 0xFD8, 0, ACCESS
5414  370D     RLCF 0xD, F, BANKED
5416  370E     RLCF 0xE, F, BANKED
5418  370F     RLCF 0xF, F, BANKED
541A  3710     RLCF 0x10, F, BANKED
589C  90D8     BCF 0xFD8, 0, ACCESS
589E  360E     RLCF 0xE, F, ACCESS
58A0  360F     RLCF 0xF, F, ACCESS
58A2  3610     RLCF 0x10, F, ACCESS
58A4  3611     RLCF 0x11, F, ACCESS
158:           		--temp.i;
541C  0717     DECF 0x17, F, BANKED
541E  A0D8     BTFSS 0xFD8, 0, ACCESS
5420  0718     DECF 0x18, F, BANKED
58A6  0618     DECF 0x18, F, ACCESS
58A8  A0D8     BTFSS 0xFD8, 0, ACCESS
58AA  0619     DECF 0x19, F, ACCESS
159:           	}
160:           
161:           	/* Round, check overflow, underflow */
162:           	// reuse aexp as round up flag
163:           	aexp = 0;
5430  0E00     MOVLW 0x0
5432  6F11     MOVWF 0x11, BANKED
58BA  0E00     MOVLW 0x0
58BC  6E12     MOVWF 0x12, ACCESS
164:           	if (grs & 0x80000000) {
5434  AF10     BTFSS 0x10, 7, BANKED
5436  EF1F     GOTO 0x543E
5438  F02A     NOP
543A  EF21     GOTO 0x5442
543C  F02A     NOP
543E  EF45     GOTO 0x548A
5440  F02A     NOP
58BE  AE11     BTFSS 0x11, 7, ACCESS
58C0  EF64     GOTO 0x58C8
58C2  F02C     NOP
58C4  EF66     GOTO 0x58CC
58C6  F02C     NOP
58C8  EF8A     GOTO 0x5914
58CA  F02C     NOP
165:           		if (grs & 0x7FFFFFFF) {
5442  0EFF     MOVLW 0xFF
5444  150D     ANDWF 0xD, W, BANKED
5446  6F08     MOVWF 0x8, BANKED
5448  0EFF     MOVLW 0xFF
544A  150E     ANDWF 0xE, W, BANKED
544C  6F09     MOVWF 0x9, BANKED
544E  0EFF     MOVLW 0xFF
5450  150F     ANDWF 0xF, W, BANKED
5452  6F0A     MOVWF 0xA, BANKED
5454  0E7F     MOVLW 0x7F
5456  1510     ANDWF 0x10, W, BANKED
5458  6F0B     MOVWF 0xB, BANKED
545A  5108     MOVF 0x8, W, BANKED
545C  1109     IORWF 0x9, W, BANKED
545E  110A     IORWF 0xA, W, BANKED
5460  110B     IORWF 0xB, W, BANKED
5462  B4D8     BTFSC 0xFD8, 2, ACCESS
5464  EF36     GOTO 0x546C
5466  F02A     NOP
5468  EF38     GOTO 0x5470
546A  F02A     NOP
546C  EF3C     GOTO 0x5478
546E  F02A     NOP
58CC  0EFF     MOVLW 0xFF
58CE  140E     ANDWF 0xE, W, ACCESS
58D0  6E09     MOVWF 0x9, ACCESS
58D2  0EFF     MOVLW 0xFF
58D4  140F     ANDWF 0xF, W, ACCESS
58D6  6E0A     MOVWF 0xA, ACCESS
58D8  0EFF     MOVLW 0xFF
58DA  1410     ANDWF 0x10, W, ACCESS
58DC  6E0B     MOVWF 0xB, ACCESS
58DE  0E7F     MOVLW 0x7F
58E0  1411     ANDWF 0x11, W, ACCESS
58E2  6E0C     MOVWF 0xC, ACCESS
58E4  5009     MOVF 0x9, W, ACCESS
58E6  100A     IORWF 0xA, W, ACCESS
58E8  100B     IORWF 0xB, W, ACCESS
58EA  100C     IORWF 0xC, W, ACCESS
58EC  B4D8     BTFSC 0xFD8, 2, ACCESS
58EE  EF7B     GOTO 0x58F6
58F0  F02C     NOP
58F2  EF7D     GOTO 0x58FA
58F4  F02C     NOP
58F6  EF81     GOTO 0x5902
58F8  F02C     NOP
166:           			aexp = 1;
5470  0E01     MOVLW 0x1
5472  6F11     MOVWF 0x11, BANKED
58FA  0E01     MOVLW 0x1
58FC  6E12     MOVWF 0x12, ACCESS
167:           		}
5474  EF45     GOTO 0x548A
5476  F02A     NOP
58FE  EF8A     GOTO 0x5914
5900  F02C     NOP
168:           		else {
169:           			if (prod.i & 1) {
5478  A113     BTFSS 0x13, 0, BANKED
547A  EF41     GOTO 0x5482
547C  F02A     NOP
547E  EF43     GOTO 0x5486
5480  F02A     NOP
5482  EF45     GOTO 0x548A
5484  F02A     NOP
5486  EF38     GOTO 0x5470
5488  F02A     NOP
5902  A014     BTFSS 0x14, 0, ACCESS
5904  EF86     GOTO 0x590C
5906  F02C     NOP
5908  EF88     GOTO 0x5910
590A  F02C     NOP
590C  EF8A     GOTO 0x5914
590E  F02C     NOP
5910  EF7D     GOTO 0x58FA
5912  F02C     NOP
170:           				aexp = 1;
171:           			}
172:           		}
173:           	}
174:           	if (aexp) {
548A  5111     MOVF 0x11, W, BANKED
548C  B4D8     BTFSC 0xFD8, 2, ACCESS
548E  EF4B     GOTO 0x5496
5490  F02A     NOP
5492  EF4D     GOTO 0x549A
5494  F02A     NOP
5496  EF79     GOTO 0x54F2
5498  F02A     NOP
5914  5012     MOVF 0x12, W, ACCESS
5916  B4D8     BTFSC 0xFD8, 2, ACCESS
5918  EF90     GOTO 0x5920
591A  F02C     NOP
591C  EF92     GOTO 0x5924
591E  F02C     NOP
5920  EFBE     GOTO 0x597C
5922  F02C     NOP
175:           		++prod.i;
549A  0E01     MOVLW 0x1
549C  2713     ADDWF 0x13, F, BANKED
549E  0E00     MOVLW 0x0
54A0  2314     ADDWFC 0x14, F, BANKED
54A2  2315     ADDWFC 0x15, F, BANKED
54A4  2316     ADDWFC 0x16, F, BANKED
5924  0E01     MOVLW 0x1
5926  2614     ADDWF 0x14, F, ACCESS
5928  0E00     MOVLW 0x0
592A  2215     ADDWFC 0x15, F, ACCESS
592C  2216     ADDWFC 0x16, F, ACCESS
592E  2217     ADDWFC 0x17, F, ACCESS
176:           		if (prod.i & ((int32_t) 1 << (SPFRCB + 1))) {
54A6  A116     BTFSS 0x16, 0, BANKED
54A8  EF58     GOTO 0x54B0
54AA  F02A     NOP
54AC  EF5A     GOTO 0x54B4
54AE  F02A     NOP
54B0  EF79     GOTO 0x54F2
54B2  F02A     NOP
5930  A017     BTFSS 0x17, 0, ACCESS
5932  EF9D     GOTO 0x593A
5934  F02C     NOP
5936  EF9F     GOTO 0x593E
5938  F02C     NOP
593A  EFBE     GOTO 0x597C
593C  F02C     NOP
177:           			prod.i = prod.i >> 1;
54B6  F84C     NOP
54B8  F608     NOP
54BC  F850     NOP
54BE  F609     NOP
54C2  F854     NOP
54C4  F60A     NOP
54C8  F858     NOP
54CA  F60B     NOP
54CC  350B     RLCF 0xB, W, BANKED
54CE  330B     RRCF 0xB, F, BANKED
54D0  330A     RRCF 0xA, F, BANKED
54D2  3309     RRCF 0x9, F, BANKED
54D4  3308     RRCF 0x8, F, BANKED
54D8  F820     NOP
54DA  F613     NOP
54DE  F824     NOP
54E0  F614     NOP
54E4  F828     NOP
54E6  F615     NOP
54EA  F82C     NOP
54EC  F616     NOP
5940  F450     NOP
5942  F509     NOP
5946  F454     NOP
5948  F50A     NOP
594C  F458     NOP
594E  F50B     NOP
5952  F45C     NOP
5954  F50C     NOP
5956  340C     RLCF 0xC, W, ACCESS
5958  320C     RRCF 0xC, F, ACCESS
595A  320B     RRCF 0xB, F, ACCESS
595C  320A     RRCF 0xA, F, ACCESS
595E  3209     RRCF 0x9, F, ACCESS
5962  F424     NOP
5964  F514     NOP
5968  F428     NOP
596A  F515     NOP
596E  F42C     NOP
5970  F516     NOP
5974  F430     NOP
5976  F517     NOP
178:           			++temp.i;
54EE  4B17     INFSNZ 0x17, F, BANKED
54F0  2B18     INCF 0x18, F, BANKED
5978  4A18     INFSNZ 0x18, F, ACCESS
597A  2A19     INCF 0x19, F, ACCESS
179:           		}
180:           	}
181:           
182:           	/* Overflow ? Return infinity */
183:           	if (!(temp.i < SPEXPM)) {
54F2  BF18     BTFSC 0x18, 7, BANKED
54F4  EF84     GOTO 0x5508
54F6  F02A     NOP
54F8  5118     MOVF 0x18, W, BANKED
54FA  E108     BNZ 0x550C
54FC  2917     INCF 0x17, W, BANKED
54FE  A0D8     BTFSS 0xFD8, 0, ACCESS
5500  EF84     GOTO 0x5508
5502  F02A     NOP
5504  EF86     GOTO 0x550C
5506  F02A     NOP
5508  EF90     GOTO 0x5520
550A  F02A     NOP
597C  BE19     BTFSC 0x19, 7, ACCESS
597E  EFC9     GOTO 0x5992
5980  F02C     NOP
5982  5019     MOVF 0x19, W, ACCESS
5984  E108     BNZ 0x5996
5986  2818     INCF 0x18, W, ACCESS
5988  A0D8     BTFSS 0xFD8, 0, ACCESS
598A  EFC9     GOTO 0x5992
598C  F02C     NOP
598E  EFCB     GOTO 0x5996
5990  F02C     NOP
5992  EFD5     GOTO 0x59AA
5994  F02C     NOP
184:           		prod.i = 0x7F800000;
550C  0E00     MOVLW 0x0
550E  6F13     MOVWF 0x13, BANKED
5510  0E00     MOVLW 0x0
5512  6F14     MOVWF 0x14, BANKED
5514  0E80     MOVLW 0x80
5516  6F15     MOVWF 0x15, BANKED
5518  0E7F     MOVLW 0x7F
551A  6F16     MOVWF 0x16, BANKED
5996  0E00     MOVLW 0x0
5998  6E14     MOVWF 0x14, ACCESS
599A  0E00     MOVLW 0x0
599C  6E15     MOVWF 0x15, ACCESS
599E  0E80     MOVLW 0x80
59A0  6E16     MOVWF 0x16, ACCESS
59A2  0E7F     MOVLW 0x7F
59A4  6E17     MOVWF 0x17, ACCESS
185:           	}
551C  EFBF     GOTO 0x557E
551E  F02A     NOP
59A6  EF04     GOTO 0x5A08
59A8  F02D     NOP
186:           	/* Underflow ? Flush to zero */
187:           	else if (!(0 < temp.i)) {
5520  BF18     BTFSC 0x18, 7, BANKED
5522  EF9D     GOTO 0x553A
5524  F02A     NOP
5526  5118     MOVF 0x18, W, BANKED
5528  E106     BNZ 0x5536
552A  0517     DECF 0x17, W, BANKED
552C  B0D8     BTFSC 0xFD8, 0, ACCESS
552E  EF9B     GOTO 0x5536
5530  F02A     NOP
5532  EF9D     GOTO 0x553A
5534  F02A     NOP
5536  EFA9     GOTO 0x5552
5538  F02A     NOP
59AA  BE19     BTFSC 0x19, 7, ACCESS
59AC  EFE2     GOTO 0x59C4
59AE  F02C     NOP
59B0  5019     MOVF 0x19, W, ACCESS
59B2  E106     BNZ 0x59C0
59B4  0418     DECF 0x18, W, ACCESS
59B6  B0D8     BTFSC 0xFD8, 0, ACCESS
59B8  EFE0     GOTO 0x59C0
59BA  F02C     NOP
59BC  EFE2     GOTO 0x59C4
59BE  F02C     NOP
59C0  EFEE     GOTO 0x59DC
59C2  F02C     NOP
188:           		prod.i = 0;
553A  0E00     MOVLW 0x0
553C  6F13     MOVWF 0x13, BANKED
553E  0E00     MOVLW 0x0
5540  6F14     MOVWF 0x14, BANKED
5542  0E00     MOVLW 0x0
5544  6F15     MOVWF 0x15, BANKED
5546  0E00     MOVLW 0x0
5548  6F16     MOVWF 0x16, BANKED
59C4  0E00     MOVLW 0x0
59C6  6E14     MOVWF 0x14, ACCESS
59C8  0E00     MOVLW 0x0
59CA  6E15     MOVWF 0x15, ACCESS
59CC  0E00     MOVLW 0x0
59CE  6E16     MOVWF 0x16, ACCESS
59D0  0E00     MOVLW 0x0
59D2  6E17     MOVWF 0x17, ACCESS
189:                           // no negative 0 for now
190:                           sign=0;
554A  0E00     MOVLW 0x0
554C  6F0C     MOVWF 0xC, BANKED
59D4  0E00     MOVLW 0x0
59D6  6E0D     MOVWF 0xD, ACCESS
191:           	}
554E  EFBF     GOTO 0x557E
5550  F02A     NOP
59D8  EF04     GOTO 0x5A08
59DA  F02D     NOP
192:           	else {
193:           		/* Pack and return result */
194:           		bexp = temp.i;	// it fits in 8 bits !
5554  F85C     NOP
5556  F612     NOP
59DE  F460     NOP
59E0  F513     NOP
195:           		prod.i &= SPFRCM;	// trim away the leading 1
5558  0EFF     MOVLW 0xFF
555A  1713     ANDWF 0x13, F, BANKED
555C  0EFF     MOVLW 0xFF
555E  1714     ANDWF 0x14, F, BANKED
5560  0E7F     MOVLW 0x7F
5562  1715     ANDWF 0x15, F, BANKED
5564  0E00     MOVLW 0x0
5566  1716     ANDWF 0x16, F, BANKED
59E2  0EFF     MOVLW 0xFF
59E4  1614     ANDWF 0x14, F, ACCESS
59E6  0EFF     MOVLW 0xFF
59E8  1615     ANDWF 0x15, F, ACCESS
59EA  0E7F     MOVLW 0x7F
59EC  1616     ANDWF 0x16, F, ACCESS
59EE  0E00     MOVLW 0x0
59F0  1617     ANDWF 0x17, F, ACCESS
196:           		if (bexp & 0x1) {
5568  A112     BTFSS 0x12, 0, BANKED
556A  EFB9     GOTO 0x5572
556C  F02A     NOP
556E  EFBB     GOTO 0x5576
5570  F02A     NOP
5572  EFBC     GOTO 0x5578
5574  F02A     NOP
59F2  A013     BTFSS 0x13, 0, ACCESS
59F4  EFFE     GOTO 0x59FC
59F6  F02C     NOP
59F8  EF00     GOTO 0x5A00
59FA  F02D     NOP
59FC  EF01     GOTO 0x5A02
59FE  F02D     NOP
197:           			prod.fAsBytes.c |= 0x80;
5576  8F15     BSF 0x15, 7, BANKED
5A00  8E16     BSF 0x16, 7, ACCESS
198:           		}
199:           		prod.fAsBytes.d = bexp >> 1;
5578  90D8     BCF 0xFD8, 0, ACCESS
557A  3112     RRCF 0x12, W, BANKED
557C  6F16     MOVWF 0x16, BANKED
5A02  90D8     BCF 0xFD8, 0, ACCESS
5A04  3013     RRCF 0x13, W, ACCESS
5A06  6E17     MOVWF 0x17, ACCESS
200:           	}
201:           	prod.fAsBytes.d |= sign;
557E  510C     MOVF 0xC, W, BANKED
5580  1316     IORWF 0x16, F, BANKED
5A08  500D     MOVF 0xD, W, ACCESS
5A0A  1217     IORWF 0x17, F, ACCESS
202:           
203:           	return prod.f;
5584  F84C     NOP
5586  F600     NOP
558A  F850     NOP
558C  F601     NOP
5590  F854     NOP
5592  F602     NOP
5596  F858     NOP
5598  F603     NOP
5A0E  F450     NOP
5A10  F501     NOP
5A14  F454     NOP
5A16  F502     NOP
5A1A  F458     NOP
5A1C  F503     NOP
5A20  F45C     NOP
5A22  F504     NOP
204:           
205:           }
559A  0012     RETURN 0
5A24  0012     RETURN 0
206:           
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/sprcdiv.c  -----------------------
1:             /* SP relaxed compliance floating point divide intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             /* SP Divide */
6:             #ifdef __PICC__
7:             SP
8:             SPDIV(SP a, SP b)
9:             #else
10:            SP
11:            SPDIV(SP b, SP a)
12:            #endif
13:            {
14:            #define A_FRACTION    (*(SFP *)&a)
15:            #define B_FRACTION    (*(SFP *)&b)
16:            	unsigned char sign;	/* sign of result */
17:            
18:            	unsigned char bexp;	/* Dst exponent */
19:            	unsigned char aexp;	/* Src exponent */
20:            	int16_t new_exp;
21:            	uint32_t grs;		/* Guard, round, sticky */
22:            	uint32_t rem;
23:            
24:            	/* Unpack and check operands */
25:            	// put b's sign as the result sign ...
26:            	sign = B_FRACTION.fAsBytes.d & 0x80;
5A26  0106     MOVLB 0x6
5A28  5103     MOVF 0x3, W, BANKED
5A2A  0B80     ANDLW 0x80
5A2C  6F10     MOVWF 0x10, BANKED
5DE6  501D     MOVF 0x1D, W, ACCESS
27:            	bexp = B_FRACTION.fAsBytes.d << 1;
5A2E  5103     MOVF 0x3, W, BANKED
5A30  2503     ADDWF 0x3, W, BANKED
5A32  6F17     MOVWF 0x17, BANKED
5DEC  501D     MOVF 0x1D, W, ACCESS
5DEE  241D     ADDWF 0x1D, W, ACCESS
5DF0  6E31     MOVWF 0x31, ACCESS
28:            	if (B_FRACTION.fAsBytes.c & 0x80) {
5A34  AF02     BTFSS 0x2, 7, BANKED
5A36  EF1F     GOTO 0x5A3E
5A38  F02D     NOP
5A3A  EF21     GOTO 0x5A42
5A3C  F02D     NOP
5A3E  EF22     GOTO 0x5A44
5A40  F02D     NOP
5DF2  AE1C     BTFSS 0x1C, 7, ACCESS
5DF4  EFFE     GOTO 0x5DFC
5DF6  F02E     NOP
5DF8  EF00     GOTO 0x5E00
5DFA  F02F     NOP
5DFC  EF01     GOTO 0x5E02
5DFE  F02F     NOP
29:            		bexp |= 0x1;
5A42  8117     BSF 0x17, 0, BANKED
5E00  8031     BSF 0x31, 0, ACCESS
30:            	}
31:            
32:            	/* Destination normal ? */
33:            	if (bexp) {
5A44  5117     MOVF 0x17, W, BANKED
5A46  B4D8     BTFSC 0xFD8, 2, ACCESS
5A48  EF28     GOTO 0x5A50
5A4A  F02D     NOP
5A4C  EF2A     GOTO 0x5A54
5A4E  F02D     NOP
5A50  EF3F     GOTO 0x5A7E
5A52  F02D     NOP
5E02  5031     MOVF 0x31, W, ACCESS
5E04  B4D8     BTFSC 0xFD8, 2, ACCESS
5E06  EF07     GOTO 0x5E0E
5E08  F02F     NOP
5E0A  EF09     GOTO 0x5E12
5E0C  F02F     NOP
5E0E  EF1E     GOTO 0x5E3C
5E10  F02F     NOP
34:            		/* Destination inf or NaN ? */
35:            		if (bexp == 0xFF) {
5A54  2917     INCF 0x17, W, BANKED
5A56  A4D8     BTFSS 0xFD8, 2, ACCESS
5A58  EF30     GOTO 0x5A60
5A5A  F02D     NOP
5A5C  EF32     GOTO 0x5A64
5A5E  F02D     NOP
5A60  EF3A     GOTO 0x5A74
5A62  F02D     NOP
5E12  2831     INCF 0x31, W, ACCESS
5E14  A4D8     BTFSS 0xFD8, 2, ACCESS
5E16  EF0F     GOTO 0x5E1E
5E18  F02F     NOP
5E1A  EF11     GOTO 0x5E22
5E1C  F02F     NOP
5E1E  EF19     GOTO 0x5E32
5E20  F02F     NOP
36:            			/* Make it inf */
37:            			b = 0;
5A64  0E00     MOVLW 0x0
5A66  6F00     MOVWF txData, BANKED
5A68  0E00     MOVLW 0x0
5A6A  6F01     MOVWF 0x1, BANKED
5A6C  0E00     MOVLW 0x0
5A6E  6F02     MOVWF 0x2, BANKED
5A70  0E00     MOVLW 0x0
5A72  6F03     MOVWF 0x3, BANKED
5E22  0E00     MOVLW 0x0
5E24  6E1A     MOVWF 0x1A, ACCESS
5E26  0E00     MOVLW 0x0
5E28  6E1B     MOVWF 0x1B, ACCESS
5E2A  0E00     MOVLW 0x0
5E2C  6E1C     MOVWF 0x1C, ACCESS
5E2E  0E00     MOVLW 0x0
5E30  6E1D     MOVWF 0x1D, ACCESS
38:            		}
39:            		// OR in the hidden 1-bit to b's fraction
40:            		B_FRACTION.i |= (int32_t) 1 << SPFRCB;
5A74  8F02     BSF 0x2, 7, BANKED
5E32  8E1C     BSF 0x1C, 7, ACCESS
41:            		// and zero out the upper byte so we can safely shift
42:            		B_FRACTION.fAsBytes.d = 0;
5A76  0E00     MOVLW 0x0
5A78  6F03     MOVWF 0x3, BANKED
5E34  0E00     MOVLW 0x0
5E36  6E1D     MOVWF 0x1D, ACCESS
43:            	}
5A7A  EF47     GOTO 0x5A8E
5A7C  F02D     NOP
5E38  EF26     GOTO 0x5E4C
5E3A  F02F     NOP
44:            	else {
45:            		/* Make it zero */
46:            		b = 0;
5A7E  0E00     MOVLW 0x0
5A80  6F00     MOVWF txData, BANKED
5A82  0E00     MOVLW 0x0
5A84  6F01     MOVWF 0x1, BANKED
5A86  0E00     MOVLW 0x0
5A88  6F02     MOVWF 0x2, BANKED
5A8A  0E00     MOVLW 0x0
5A8C  6F03     MOVWF 0x3, BANKED
5E3C  0E00     MOVLW 0x0
5E3E  6E1A     MOVWF 0x1A, ACCESS
5E40  0E00     MOVLW 0x0
5E42  6E1B     MOVWF 0x1B, ACCESS
5E44  0E00     MOVLW 0x0
5E46  6E1C     MOVWF 0x1C, ACCESS
5E48  0E00     MOVLW 0x0
5E4A  6E1D     MOVWF 0x1D, ACCESS
47:            	}
48:            	// xor a's sign into the result sign
49:            	sign ^= A_FRACTION.fAsBytes.d & 0x80;
5A8E  5107     MOVF 0x7, W, BANKED
5A90  0B80     ANDLW 0x80
5A92  1B10     XORWF 0x10, F, BANKED
5E4C  5021     MOVF 0x21, W, ACCESS
5E4E  0B80     ANDLW 0x80
5E50  1A2A     XORWF 0x2A, F, ACCESS
50:            	aexp = A_FRACTION.fAsBytes.d << 1;
5A94  5107     MOVF 0x7, W, BANKED
5A96  2507     ADDWF 0x7, W, BANKED
5A98  6F18     MOVWF 0x18, BANKED
5E52  5021     MOVF 0x21, W, ACCESS
5E54  2421     ADDWF 0x21, W, ACCESS
5E56  6E32     MOVWF 0x32, ACCESS
51:            	if (A_FRACTION.fAsBytes.c & 0x80) {
5A9A  AF06     BTFSS 0x6, 7, BANKED
5A9C  EF52     GOTO 0x5AA4
5A9E  F02D     NOP
5AA0  EF54     GOTO 0x5AA8
5AA2  F02D     NOP
5AA4  EF55     GOTO 0x5AAA
5AA6  F02D     NOP
5E58  AE20     BTFSS 0x20, 7, ACCESS
5E5A  EF31     GOTO 0x5E62
5E5C  F02F     NOP
5E5E  EF33     GOTO 0x5E66
5E60  F02F     NOP
5E62  EF34     GOTO 0x5E68
5E64  F02F     NOP
52:            		aexp |= 0x1;
5AA8  8118     BSF 0x18, 0, BANKED
5E66  8032     BSF 0x32, 0, ACCESS
53:            	}
54:            
55:            	/* Destination normal ? */
56:            	if (aexp) {
5AAA  5118     MOVF 0x18, W, BANKED
5AAC  B4D8     BTFSC 0xFD8, 2, ACCESS
5AAE  EF5B     GOTO 0x5AB6
5AB0  F02D     NOP
5AB2  EF5D     GOTO 0x5ABA
5AB4  F02D     NOP
5AB6  EF72     GOTO 0x5AE4
5AB8  F02D     NOP
5E68  5032     MOVF 0x32, W, ACCESS
5E6A  B4D8     BTFSC 0xFD8, 2, ACCESS
5E6C  EF3A     GOTO 0x5E74
5E6E  F02F     NOP
5E70  EF3C     GOTO 0x5E78
5E72  F02F     NOP
5E74  EF51     GOTO 0x5EA2
5E76  F02F     NOP
57:            		/* Destination inf or NaN ? */
58:            		if (aexp == 0xFF) {
5ABA  2918     INCF 0x18, W, BANKED
5ABC  A4D8     BTFSS 0xFD8, 2, ACCESS
5ABE  EF63     GOTO 0x5AC6
5AC0  F02D     NOP
5AC2  EF65     GOTO 0x5ACA
5AC4  F02D     NOP
5AC6  EF6D     GOTO 0x5ADA
5AC8  F02D     NOP
5E78  2832     INCF 0x32, W, ACCESS
5E7A  A4D8     BTFSS 0xFD8, 2, ACCESS
5E7C  EF42     GOTO 0x5E84
5E7E  F02F     NOP
5E80  EF44     GOTO 0x5E88
5E82  F02F     NOP
5E84  EF4C     GOTO 0x5E98
5E86  F02F     NOP
59:            			/* Make it inf */
60:            			a = 0;
5ACA  0E00     MOVLW 0x0
5ACC  6F04     MOVWF 0x4, BANKED
5ACE  0E00     MOVLW 0x0
5AD0  6F05     MOVWF 0x5, BANKED
5AD2  0E00     MOVLW 0x0
5AD4  6F06     MOVWF 0x6, BANKED
5AD6  0E00     MOVLW 0x0
5AD8  6F07     MOVWF 0x7, BANKED
5E88  0E00     MOVLW 0x0
5E8A  6E1E     MOVWF 0x1E, ACCESS
5E8C  0E00     MOVLW 0x0
5E8E  6E1F     MOVWF 0x1F, ACCESS
5E90  0E00     MOVLW 0x0
5E92  6E20     MOVWF 0x20, ACCESS
5E94  0E00     MOVLW 0x0
5E96  6E21     MOVWF 0x21, ACCESS
61:            		}
62:            		// OR in the hidden 1-bit to a's fraction
63:            		A_FRACTION.i |= (int32_t) 1 << SPFRCB;
5ADA  8F06     BSF 0x6, 7, BANKED
5E98  8E20     BSF 0x20, 7, ACCESS
64:            		// and zero out the upper bits so we can safely shift
65:            		A_FRACTION.fAsBytes.d = 0;
5ADC  0E00     MOVLW 0x0
5ADE  6F07     MOVWF 0x7, BANKED
5E9A  0E00     MOVLW 0x0
5E9C  6E21     MOVWF 0x21, ACCESS
66:            	}
5AE0  EF7A     GOTO 0x5AF4
5AE2  F02D     NOP
5E9E  EF59     GOTO 0x5EB2
5EA0  F02F     NOP
67:            	else {
68:            		/* Make it zero */
69:            		a = 0;
5AE4  0E00     MOVLW 0x0
5AE6  6F04     MOVWF 0x4, BANKED
5AE8  0E00     MOVLW 0x0
5AEA  6F05     MOVWF 0x5, BANKED
5AEC  0E00     MOVLW 0x0
5AEE  6F06     MOVWF 0x6, BANKED
5AF0  0E00     MOVLW 0x0
5AF2  6F07     MOVWF 0x7, BANKED
5EA2  0E00     MOVLW 0x0
5EA4  6E1E     MOVWF 0x1E, ACCESS
5EA6  0E00     MOVLW 0x0
5EA8  6E1F     MOVWF 0x1F, ACCESS
5EAA  0E00     MOVLW 0x0
5EAC  6E20     MOVWF 0x20, ACCESS
5EAE  0E00     MOVLW 0x0
5EB0  6E21     MOVWF 0x21, ACCESS
70:            	}
71:            
72:            	/* Special operand check */
73:            
74:            	/* Denominator zero ? Result infinity */
75:            	if (A_FRACTION.i == 0) {
5AF4  5104     MOVF 0x4, W, BANKED
5AF6  1105     IORWF 0x5, W, BANKED
5AF8  1106     IORWF 0x6, W, BANKED
5AFA  1107     IORWF 0x7, W, BANKED
5AFC  A4D8     BTFSS 0xFD8, 2, ACCESS
5AFE  EF83     GOTO 0x5B06
5B00  F02D     NOP
5B02  EF85     GOTO 0x5B0A
5B04  F02D     NOP
5B06  EFA1     GOTO 0x5B42
5B08  F02D     NOP
5EB2  501E     MOVF 0x1E, W, ACCESS
5EB4  101F     IORWF 0x1F, W, ACCESS
5EB6  1020     IORWF 0x20, W, ACCESS
5EB8  1021     IORWF 0x21, W, ACCESS
5EBA  A4D8     BTFSS 0xFD8, 2, ACCESS
5EBC  EF62     GOTO 0x5EC4
5EBE  F02F     NOP
5EC0  EF64     GOTO 0x5EC8
5EC2  F02F     NOP
5EC4  EF80     GOTO 0x5F00
5EC6  F02F     NOP
76:            		B_FRACTION.i = 0;
5B0A  0E00     MOVLW 0x0
5B0C  6F00     MOVWF txData, BANKED
5B0E  0E00     MOVLW 0x0
5B10  6F01     MOVWF 0x1, BANKED
5B12  0E00     MOVLW 0x0
5B14  6F02     MOVWF 0x2, BANKED
5B16  0E00     MOVLW 0x0
5B18  6F03     MOVWF 0x3, BANKED
5EC8  0E00     MOVLW 0x0
5ECA  6E1A     MOVWF 0x1A, ACCESS
5ECC  0E00     MOVLW 0x0
5ECE  6E1B     MOVWF 0x1B, ACCESS
5ED0  0E00     MOVLW 0x0
5ED2  6E1C     MOVWF 0x1C, ACCESS
5ED4  0E00     MOVLW 0x0
5ED6  6E1D     MOVWF 0x1D, ACCESS
77:            		B_FRACTION.fAsWords.wordB |= (SPEXPM << 7);
5B1A  0E80     MOVLW 0x80
5B1C  1302     IORWF 0x2, F, BANKED
5B1E  0E7F     MOVLW 0x7F
5B20  1303     IORWF 0x3, F, BANKED
5ED8  0E80     MOVLW 0x80
5EDA  121C     IORWF 0x1C, F, ACCESS
5EDC  0E7F     MOVLW 0x7F
5EDE  121D     IORWF 0x1D, F, ACCESS
78:            		B_FRACTION.fAsBytes.d |= sign;
5B22  5110     MOVF 0x10, W, BANKED
5B24  1303     IORWF 0x3, F, BANKED
5EE0  502A     MOVF 0x2A, W, ACCESS
5EE2  121D     IORWF 0x1D, F, ACCESS
79:            		return b;
5B28  F800     NOP
5B2A  F600     NOP
5B2E  F804     NOP
5B30  F601     NOP
5B34  F808     NOP
5B36  F602     NOP
5B3A  F80C     NOP
5B3C  F603     NOP
5B3E  EFF2     GOTO 0x5DE4
5B40  F02E     NOP
5EE6  F468     NOP
5EE8  F51A     NOP
5EEC  F46C     NOP
5EEE  F51B     NOP
5EF2  F470     NOP
5EF4  F51C     NOP
5EF8  F474     NOP
5EFA  F51D     NOP
5EFC  EFD1     GOTO 0x61A2
5EFE  F030     NOP
80:            	}
81:            
82:            	/* Numerator zero ? Result zero */
83:            	if (!bexp) {
5B42  5117     MOVF 0x17, W, BANKED
5B44  A4D8     BTFSS 0xFD8, 2, ACCESS
5B46  EFA7     GOTO 0x5B4E
5B48  F02D     NOP
5B4A  EFA9     GOTO 0x5B52
5B4C  F02D     NOP
5B4E  EFB3     GOTO 0x5B66
5B50  F02D     NOP
5F00  5031     MOVF 0x31, W, ACCESS
5F02  A4D8     BTFSS 0xFD8, 2, ACCESS
5F04  EF86     GOTO 0x5F0C
5F06  F02F     NOP
5F08  EF88     GOTO 0x5F10
5F0A  F02F     NOP
5F0C  EF92     GOTO 0x5F24
5F0E  F02F     NOP
84:            		B_FRACTION.i = 0;
85:            		return b;
5B52  0E00     MOVLW 0x0
5B54  6F00     MOVWF txData, BANKED
5B56  0E00     MOVLW 0x0
5B58  6F01     MOVWF 0x1, BANKED
5B5A  0E00     MOVLW 0x0
5B5C  6F02     MOVWF 0x2, BANKED
5B5E  0E00     MOVLW 0x0
5B60  6F03     MOVWF 0x3, BANKED
5B62  EFF2     GOTO 0x5DE4
5B64  F02E     NOP
5F10  0E00     MOVLW 0x0
5F12  6E1A     MOVWF 0x1A, ACCESS
5F14  0E00     MOVLW 0x0
5F16  6E1B     MOVWF 0x1B, ACCESS
5F18  0E00     MOVLW 0x0
5F1A  6E1C     MOVWF 0x1C, ACCESS
5F1C  0E00     MOVLW 0x0
5F1E  6E1D     MOVWF 0x1D, ACCESS
5F20  EFD1     GOTO 0x61A2
5F22  F030     NOP
86:            	}
87:            
88:            	/* Subtract denominator exponent, minus bias */
89:            	new_exp = bexp - aexp + 127;
5B66  5118     MOVF 0x18, W, BANKED
5B6A  F85C     NOP
5B6C  F608     NOP
5B6E  6B09     CLRF 0x9, BANKED
5B70  5F08     SUBWF 0x8, F, BANKED
5B72  0E00     MOVLW 0x0
5B74  5B09     SUBWFB 0x9, F, BANKED
5B76  0E7F     MOVLW 0x7F
5B78  2508     ADDWF 0x8, W, BANKED
5B7A  6F11     MOVWF 0x11, BANKED
5B7C  0E00     MOVLW 0x0
5B7E  2109     ADDWFC 0x9, W, BANKED
5B80  6F12     MOVWF 0x12, BANKED
5F24  5032     MOVF 0x32, W, ACCESS
5F28  F4C4     NOP
5F2A  F522     NOP
5F2C  6A23     CLRF 0x23, ACCESS
5F2E  5E22     SUBWF 0x22, F, ACCESS
5F30  0E00     MOVLW 0x0
5F32  5A23     SUBWFB 0x23, F, ACCESS
5F34  0E7F     MOVLW 0x7F
5F36  2422     ADDWF 0x22, W, ACCESS
5F38  6E2B     MOVWF 0x2B, ACCESS
5F3A  0E00     MOVLW 0x0
5F3C  2023     ADDWFC 0x23, W, ACCESS
5F3E  6E2C     MOVWF 0x2C, ACCESS
90:            
91:            	/* Divide loop */
92:            	rem = B_FRACTION.i;
5B84  F800     NOP
5B86  F60C     NOP
5B8A  F804     NOP
5B8C  F60D     NOP
5B90  F808     NOP
5B92  F60E     NOP
5B96  F80C     NOP
5B98  F60F     NOP
5F42  F468     NOP
5F44  F526     NOP
5F48  F46C     NOP
5F4A  F527     NOP
5F4E  F470     NOP
5F50  F528     NOP
5F54  F474     NOP
5F56  F529     NOP
93:            	B_FRACTION.i = 0;
5B9A  0E00     MOVLW 0x0
5B9C  6F00     MOVWF txData, BANKED
5B9E  0E00     MOVLW 0x0
5BA0  6F01     MOVWF 0x1, BANKED
5BA2  0E00     MOVLW 0x0
5BA4  6F02     MOVWF 0x2, BANKED
5BA6  0E00     MOVLW 0x0
5BA8  6F03     MOVWF 0x3, BANKED
5F58  0E00     MOVLW 0x0
5F5A  6E1A     MOVWF 0x1A, ACCESS
5F5C  0E00     MOVLW 0x0
5F5E  6E1B     MOVWF 0x1B, ACCESS
5F60  0E00     MOVLW 0x0
5F62  6E1C     MOVWF 0x1C, ACCESS
5F64  0E00     MOVLW 0x0
5F66  6E1D     MOVWF 0x1D, ACCESS
94:            	grs = 0;
5BAA  0E00     MOVLW 0x0
5BAC  6F13     MOVWF 0x13, BANKED
5BAE  0E00     MOVLW 0x0
5BB0  6F14     MOVWF 0x14, BANKED
5BB2  0E00     MOVLW 0x0
5BB4  6F15     MOVWF 0x15, BANKED
5BB6  0E00     MOVLW 0x0
5BB8  6F16     MOVWF 0x16, BANKED
5F68  0E00     MOVLW 0x0
5F6A  6E2D     MOVWF 0x2D, ACCESS
5F6C  0E00     MOVLW 0x0
5F6E  6E2E     MOVWF 0x2E, ACCESS
5F70  0E00     MOVLW 0x0
5F72  6E2F     MOVWF 0x2F, ACCESS
5F74  0E00     MOVLW 0x0
5F76  6E30     MOVWF 0x30, ACCESS
95:            	// reuse aexp as the loop counter ...
96:            	aexp = 0;
5BBA  0E00     MOVLW 0x0
5BBC  6F18     MOVWF 0x18, BANKED
5F78  0E00     MOVLW 0x0
5F7A  6E32     MOVWF 0x32, ACCESS
97:            	while (aexp < 26) {
5BBE  EF19     GOTO 0x5C32
5BC0  F02E     NOP
5F7C  EFF8     GOTO 0x5FF0
5F7E  F02F     NOP
98:            
99:            		/* Shift remainder, quotient left */
100:           		if (aexp) {
5BC2  5118     MOVF 0x18, W, BANKED
5BC4  B4D8     BTFSC 0xFD8, 2, ACCESS
5BC6  EFE7     GOTO 0x5BCE
5BC8  F02D     NOP
5BCA  EFE9     GOTO 0x5BD2
5BCC  F02D     NOP
5BCE  EF00     GOTO 0x5C00
5BD0  F02E     NOP
5F80  5032     MOVF 0x32, W, ACCESS
5F82  B4D8     BTFSC 0xFD8, 2, ACCESS
5F84  EFC6     GOTO 0x5F8C
5F86  F02F     NOP
5F88  EFC8     GOTO 0x5F90
5F8A  F02F     NOP
5F8C  EFDF     GOTO 0x5FBE
5F8E  F02F     NOP
101:           			rem <<= 1;
5BD2  90D8     BCF 0xFD8, 0, ACCESS
5BD4  370C     RLCF 0xC, F, BANKED
5BD6  370D     RLCF 0xD, F, BANKED
5BD8  370E     RLCF 0xE, F, BANKED
5BDA  370F     RLCF 0xF, F, BANKED
5F90  90D8     BCF 0xFD8, 0, ACCESS
5F92  3626     RLCF 0x26, F, ACCESS
5F94  3627     RLCF 0x27, F, ACCESS
5F96  3628     RLCF 0x28, F, ACCESS
5F98  3629     RLCF 0x29, F, ACCESS
102:           			B_FRACTION.i <<= 1;
5BDC  90D8     BCF 0xFD8, 0, ACCESS
5BDE  3700     RLCF txData, F, BANKED
5BE0  3701     RLCF 0x1, F, BANKED
5BE2  3702     RLCF 0x2, F, BANKED
5BE4  3703     RLCF 0x3, F, BANKED
5F9A  90D8     BCF 0xFD8, 0, ACCESS
5F9C  361A     RLCF 0x1A, F, ACCESS
5F9E  361B     RLCF 0x1B, F, ACCESS
5FA0  361C     RLCF 0x1C, F, ACCESS
5FA2  361D     RLCF 0x1D, F, ACCESS
103:           			if (grs & 0x80000000) {
5BE6  AF16     BTFSS 0x16, 7, BANKED
5BE8  EFF8     GOTO 0x5BF0
5BEA  F02D     NOP
5BEC  EFFA     GOTO 0x5BF4
5BEE  F02D     NOP
5BF0  EFFB     GOTO 0x5BF6
5BF2  F02D     NOP
5FA4  AE30     BTFSS 0x30, 7, ACCESS
5FA6  EFD7     GOTO 0x5FAE
5FA8  F02F     NOP
5FAA  EFD9     GOTO 0x5FB2
5FAC  F02F     NOP
5FAE  EFDA     GOTO 0x5FB4
5FB0  F02F     NOP
104:           				B_FRACTION.i |= 0x1;
5BF4  8100     BSF txData, 0, BANKED
5FB2  801A     BSF 0x1A, 0, ACCESS
105:           			}
106:           			grs <<= 1;
5BF6  90D8     BCF 0xFD8, 0, ACCESS
5BF8  3713     RLCF 0x13, F, BANKED
5BFA  3714     RLCF 0x14, F, BANKED
5BFC  3715     RLCF 0x15, F, BANKED
5BFE  3716     RLCF 0x16, F, BANKED
5FB4  90D8     BCF 0xFD8, 0, ACCESS
5FB6  362D     RLCF 0x2D, F, ACCESS
5FB8  362E     RLCF 0x2E, F, ACCESS
5FBA  362F     RLCF 0x2F, F, ACCESS
5FBC  3630     RLCF 0x30, F, ACCESS
107:           		}
108:           
109:           		/* Restoring divide */
110:           
111:           		/* Remainder not less than divisor ? */
112:           		if (!(rem < A_FRACTION.i)) {
5C00  5104     MOVF 0x4, W, BANKED
5C02  5D0C     SUBWF 0xC, W, BANKED
5C04  5105     MOVF 0x5, W, BANKED
5C06  590D     SUBWFB 0xD, W, BANKED
5C08  5106     MOVF 0x6, W, BANKED
5C0A  590E     SUBWFB 0xE, W, BANKED
5C0C  5107     MOVF 0x7, W, BANKED
5C0E  590F     SUBWFB 0xF, W, BANKED
5C10  A0D8     BTFSS 0xFD8, 0, ACCESS
5C12  EF0D     GOTO 0x5C1A
5C14  F02E     NOP
5C16  EF0F     GOTO 0x5C1E
5C18  F02E     NOP
5C1A  EF18     GOTO 0x5C30
5C1C  F02E     NOP
5FBE  501E     MOVF 0x1E, W, ACCESS
5FC0  5C26     SUBWF 0x26, W, ACCESS
5FC2  501F     MOVF 0x1F, W, ACCESS
5FC4  5827     SUBWFB 0x27, W, ACCESS
5FC6  5020     MOVF 0x20, W, ACCESS
5FC8  5828     SUBWFB 0x28, W, ACCESS
5FCA  5021     MOVF 0x21, W, ACCESS
5FCC  5829     SUBWFB 0x29, W, ACCESS
5FCE  A0D8     BTFSS 0xFD8, 0, ACCESS
5FD0  EFEC     GOTO 0x5FD8
5FD2  F02F     NOP
5FD4  EFEE     GOTO 0x5FDC
5FD6  F02F     NOP
5FD8  EFF7     GOTO 0x5FEE
5FDA  F02F     NOP
113:           
114:           			/* Set quotient bit, subtract divisor */
115:           			grs |= 0x40000000;
5C1E  8D16     BSF 0x16, 6, BANKED
5FDC  8C30     BSF 0x30, 6, ACCESS
116:           			rem -= A_FRACTION.i;
5C20  5104     MOVF 0x4, W, BANKED
5C22  5F0C     SUBWF 0xC, F, BANKED
5C24  5105     MOVF 0x5, W, BANKED
5C26  5B0D     SUBWFB 0xD, F, BANKED
5C28  5106     MOVF 0x6, W, BANKED
5C2A  5B0E     SUBWFB 0xE, F, BANKED
5C2C  5107     MOVF 0x7, W, BANKED
5C2E  5B0F     SUBWFB 0xF, F, BANKED
5FDE  501E     MOVF 0x1E, W, ACCESS
5FE0  5E26     SUBWF 0x26, F, ACCESS
5FE2  501F     MOVF 0x1F, W, ACCESS
5FE4  5A27     SUBWFB 0x27, F, ACCESS
5FE6  5020     MOVF 0x20, W, ACCESS
5FE8  5A28     SUBWFB 0x28, F, ACCESS
5FEA  5021     MOVF 0x21, W, ACCESS
5FEC  5A29     SUBWFB 0x29, F, ACCESS
117:           		}
118:           		++aexp;
5C30  2B18     INCF 0x18, F, BANKED
5FEE  2A32     INCF 0x32, F, ACCESS
119:           	}
5C32  0E19     MOVLW 0x19
5C34  6518     CPFSGT 0x18, BANKED
5C36  EF1F     GOTO 0x5C3E
5C38  F02E     NOP
5C3A  EF21     GOTO 0x5C42
5C3C  F02E     NOP
5C3E  EFE1     GOTO 0x5BC2
5C40  F02D     NOP
5FF0  0E19     MOVLW 0x19
5FF2  6432     CPFSGT 0x32, ACCESS
5FF4  EFFE     GOTO 0x5FFC
5FF6  F02F     NOP
5FF8  EF00     GOTO 0x6000
5FFA  F030     NOP
5FFC  EFC0     GOTO 0x5F80
5FFE  F02F     NOP
120:           
121:           	/* Sticky bit is nonzero remainder */
122:           	if (rem) {
5C42  510C     MOVF 0xC, W, BANKED
5C44  110D     IORWF 0xD, W, BANKED
5C46  110E     IORWF 0xE, W, BANKED
5C48  110F     IORWF 0xF, W, BANKED
5C4A  B4D8     BTFSC 0xFD8, 2, ACCESS
5C4C  EF2A     GOTO 0x5C54
5C4E  F02E     NOP
5C50  EF2C     GOTO 0x5C58
5C52  F02E     NOP
5C54  EF44     GOTO 0x5C88
5C56  F02E     NOP
6000  5026     MOVF 0x26, W, ACCESS
6002  1027     IORWF 0x27, W, ACCESS
6004  1028     IORWF 0x28, W, ACCESS
6006  1029     IORWF 0x29, W, ACCESS
6008  B4D8     BTFSC 0xFD8, 2, ACCESS
600A  EF09     GOTO 0x6012
600C  F030     NOP
600E  EF0B     GOTO 0x6016
6010  F030     NOP
6012  EF23     GOTO 0x6046
6014  F030     NOP
123:           		grs |= 1;
5C58  8113     BSF 0x13, 0, BANKED
5C5A  EF44     GOTO 0x5C88
5C5C  F02E     NOP
6016  802D     BSF 0x2D, 0, ACCESS
6018  EF23     GOTO 0x6046
601A  F030     NOP
124:           	}
125:           
126:           	/* Renormalize */
127:           	while (!(B_FRACTION.i & ((int32_t) 1 << SPFRCB))) {
5C88  AF02     BTFSS 0x2, 7, BANKED
5C8A  EF49     GOTO 0x5C92
5C8C  F02E     NOP
5C8E  EF4B     GOTO 0x5C96
5C90  F02E     NOP
5C92  EF2F     GOTO 0x5C5E
5C94  F02E     NOP
6046  AE1C     BTFSS 0x1C, 7, ACCESS
6048  EF28     GOTO 0x6050
604A  F030     NOP
604C  EF2A     GOTO 0x6054
604E  F030     NOP
6050  EF0E     GOTO 0x601C
6052  F030     NOP
128:           		B_FRACTION.i <<= 1;
5C5E  90D8     BCF 0xFD8, 0, ACCESS
5C60  3700     RLCF txData, F, BANKED
5C62  3701     RLCF 0x1, F, BANKED
5C64  3702     RLCF 0x2, F, BANKED
5C66  3703     RLCF 0x3, F, BANKED
601C  90D8     BCF 0xFD8, 0, ACCESS
601E  361A     RLCF 0x1A, F, ACCESS
6020  361B     RLCF 0x1B, F, ACCESS
6022  361C     RLCF 0x1C, F, ACCESS
6024  361D     RLCF 0x1D, F, ACCESS
129:           		if (grs & 0x80000000) {
5C68  AF16     BTFSS 0x16, 7, BANKED
5C6A  EF39     GOTO 0x5C72
5C6C  F02E     NOP
5C6E  EF3B     GOTO 0x5C76
5C70  F02E     NOP
5C72  EF3C     GOTO 0x5C78
5C74  F02E     NOP
6026  AE30     BTFSS 0x30, 7, ACCESS
6028  EF18     GOTO 0x6030
602A  F030     NOP
602C  EF1A     GOTO 0x6034
602E  F030     NOP
6030  EF1B     GOTO 0x6036
6032  F030     NOP
130:           			B_FRACTION.i |= 0x1;
5C76  8100     BSF txData, 0, BANKED
6034  801A     BSF 0x1A, 0, ACCESS
131:           		}
132:           		grs <<= 1;
5C78  90D8     BCF 0xFD8, 0, ACCESS
5C7A  3713     RLCF 0x13, F, BANKED
5C7C  3714     RLCF 0x14, F, BANKED
5C7E  3715     RLCF 0x15, F, BANKED
5C80  3716     RLCF 0x16, F, BANKED
6036  90D8     BCF 0xFD8, 0, ACCESS
6038  362D     RLCF 0x2D, F, ACCESS
603A  362E     RLCF 0x2E, F, ACCESS
603C  362F     RLCF 0x2F, F, ACCESS
603E  3630     RLCF 0x30, F, ACCESS
133:           		--new_exp;
5C82  0711     DECF 0x11, F, BANKED
5C84  A0D8     BTFSS 0xFD8, 0, ACCESS
5C86  0712     DECF 0x12, F, BANKED
6040  062B     DECF 0x2B, F, ACCESS
6042  A0D8     BTFSS 0xFD8, 0, ACCESS
6044  062C     DECF 0x2C, F, ACCESS
134:           	}
135:           
136:           	/* Round result and check overflow, underflow */
137:           	/* Round */
138:           	// reuse aexp again as the round-up flag ...
139:           	aexp = 0;
5C96  0E00     MOVLW 0x0
5C98  6F18     MOVWF 0x18, BANKED
6054  0E00     MOVLW 0x0
6056  6E32     MOVWF 0x32, ACCESS
140:           	if (grs & ((uint32_t) 1 << 31)) {
5C9A  AF16     BTFSS 0x16, 7, BANKED
5C9C  EF52     GOTO 0x5CA4
5C9E  F02E     NOP
5CA0  EF54     GOTO 0x5CA8
5CA2  F02E     NOP
5CA4  EF78     GOTO 0x5CF0
5CA6  F02E     NOP
6058  AE30     BTFSS 0x30, 7, ACCESS
605A  EF31     GOTO 0x6062
605C  F030     NOP
605E  EF33     GOTO 0x6066
6060  F030     NOP
6062  EF57     GOTO 0x60AE
6064  F030     NOP
141:           		if (grs & (((uint32_t) 1 << 31) - 1)) {
5CA8  0EFF     MOVLW 0xFF
5CAA  1513     ANDWF 0x13, W, BANKED
5CAC  6F08     MOVWF 0x8, BANKED
5CAE  0EFF     MOVLW 0xFF
5CB0  1514     ANDWF 0x14, W, BANKED
5CB2  6F09     MOVWF 0x9, BANKED
5CB4  0EFF     MOVLW 0xFF
5CB6  1515     ANDWF 0x15, W, BANKED
5CB8  6F0A     MOVWF 0xA, BANKED
5CBA  0E7F     MOVLW 0x7F
5CBC  1516     ANDWF 0x16, W, BANKED
5CBE  6F0B     MOVWF 0xB, BANKED
5CC0  5108     MOVF 0x8, W, BANKED
5CC2  1109     IORWF 0x9, W, BANKED
5CC4  110A     IORWF 0xA, W, BANKED
5CC6  110B     IORWF 0xB, W, BANKED
5CC8  B4D8     BTFSC 0xFD8, 2, ACCESS
5CCA  EF69     GOTO 0x5CD2
5CCC  F02E     NOP
5CCE  EF6B     GOTO 0x5CD6
5CD0  F02E     NOP
5CD2  EF6F     GOTO 0x5CDE
5CD4  F02E     NOP
6066  0EFF     MOVLW 0xFF
6068  142D     ANDWF 0x2D, W, ACCESS
606A  6E22     MOVWF 0x22, ACCESS
606C  0EFF     MOVLW 0xFF
606E  142E     ANDWF 0x2E, W, ACCESS
6070  6E23     MOVWF 0x23, ACCESS
6072  0EFF     MOVLW 0xFF
6074  142F     ANDWF 0x2F, W, ACCESS
6076  6E24     MOVWF 0x24, ACCESS
6078  0E7F     MOVLW 0x7F
607A  1430     ANDWF 0x30, W, ACCESS
607C  6E25     MOVWF 0x25, ACCESS
607E  5022     MOVF 0x22, W, ACCESS
6080  1023     IORWF 0x23, W, ACCESS
6082  1024     IORWF 0x24, W, ACCESS
6084  1025     IORWF 0x25, W, ACCESS
6086  B4D8     BTFSC 0xFD8, 2, ACCESS
6088  EF48     GOTO 0x6090
608A  F030     NOP
608C  EF4A     GOTO 0x6094
608E  F030     NOP
6090  EF4E     GOTO 0x609C
6092  F030     NOP
142:           			aexp = 1;
5CD6  0E01     MOVLW 0x1
5CD8  6F18     MOVWF 0x18, BANKED
6094  0E01     MOVLW 0x1
6096  6E32     MOVWF 0x32, ACCESS
143:           		}
5CDA  EF78     GOTO 0x5CF0
5CDC  F02E     NOP
6098  EF57     GOTO 0x60AE
609A  F030     NOP
144:           		else {
145:           			if (B_FRACTION.i & 1) {
5CDE  A100     BTFSS txData, 0, BANKED
5CE0  EF74     GOTO 0x5CE8
5CE2  F02E     NOP
5CE4  EF76     GOTO 0x5CEC
5CE6  F02E     NOP
5CE8  EF78     GOTO 0x5CF0
5CEA  F02E     NOP
5CEC  EF6B     GOTO 0x5CD6
5CEE  F02E     NOP
609C  A01A     BTFSS 0x1A, 0, ACCESS
609E  EF53     GOTO 0x60A6
60A0  F030     NOP
60A2  EF55     GOTO 0x60AA
60A4  F030     NOP
60A6  EF57     GOTO 0x60AE
60A8  F030     NOP
60AA  EF4A     GOTO 0x6094
60AC  F030     NOP
146:           				aexp = 1;
147:           			}
148:           		}
149:           	}
150:           	if (aexp) {
5CF0  5118     MOVF 0x18, W, BANKED
5CF2  B4D8     BTFSC 0xFD8, 2, ACCESS
5CF4  EF7E     GOTO 0x5CFC
5CF6  F02E     NOP
5CF8  EF80     GOTO 0x5D00
5CFA  F02E     NOP
5CFC  EFAC     GOTO 0x5D58
5CFE  F02E     NOP
60AE  5032     MOVF 0x32, W, ACCESS
60B0  B4D8     BTFSC 0xFD8, 2, ACCESS
60B2  EF5D     GOTO 0x60BA
60B4  F030     NOP
60B6  EF5F     GOTO 0x60BE
60B8  F030     NOP
60BA  EF8B     GOTO 0x6116
60BC  F030     NOP
151:           		++B_FRACTION.i;
5D00  0E01     MOVLW 0x1
5D02  2700     ADDWF txData, F, BANKED
5D04  0E00     MOVLW 0x0
5D06  2301     ADDWFC 0x1, F, BANKED
5D08  2302     ADDWFC 0x2, F, BANKED
5D0A  2303     ADDWFC 0x3, F, BANKED
60BE  0E01     MOVLW 0x1
60C0  261A     ADDWF 0x1A, F, ACCESS
60C2  0E00     MOVLW 0x0
60C4  221B     ADDWFC 0x1B, F, ACCESS
60C6  221C     ADDWFC 0x1C, F, ACCESS
60C8  221D     ADDWFC 0x1D, F, ACCESS
152:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
5D0C  A103     BTFSS 0x3, 0, BANKED
5D0E  EF8B     GOTO 0x5D16
5D10  F02E     NOP
5D12  EF8D     GOTO 0x5D1A
5D14  F02E     NOP
5D16  EFAC     GOTO 0x5D58
5D18  F02E     NOP
60CA  A01D     BTFSS 0x1D, 0, ACCESS
60CC  EF6A     GOTO 0x60D4
60CE  F030     NOP
60D0  EF6C     GOTO 0x60D8
60D2  F030     NOP
60D4  EF8B     GOTO 0x6116
60D6  F030     NOP
153:           			B_FRACTION.i = B_FRACTION.i >> 1;
5D1C  F800     NOP
5D1E  F608     NOP
5D22  F804     NOP
5D24  F609     NOP
5D28  F808     NOP
5D2A  F60A     NOP
5D2E  F80C     NOP
5D30  F60B     NOP
5D32  350B     RLCF 0xB, W, BANKED
5D34  330B     RRCF 0xB, F, BANKED
5D36  330A     RRCF 0xA, F, BANKED
5D38  3309     RRCF 0x9, F, BANKED
5D3A  3308     RRCF 0x8, F, BANKED
5D3E  F820     NOP
5D40  F600     NOP
5D44  F824     NOP
5D46  F601     NOP
5D4A  F828     NOP
5D4C  F602     NOP
5D50  F82C     NOP
5D52  F603     NOP
60DA  F468     NOP
60DC  F522     NOP
60E0  F46C     NOP
60E2  F523     NOP
60E6  F470     NOP
60E8  F524     NOP
60EC  F474     NOP
60EE  F525     NOP
60F0  3425     RLCF 0x25, W, ACCESS
60F2  3225     RRCF 0x25, F, ACCESS
60F4  3224     RRCF 0x24, F, ACCESS
60F6  3223     RRCF 0x23, F, ACCESS
60F8  3222     RRCF 0x22, F, ACCESS
60FC  F488     NOP
60FE  F51A     NOP
6102  F48C     NOP
6104  F51B     NOP
6108  F490     NOP
610A  F51C     NOP
610E  F494     NOP
6110  F51D     NOP
154:           			++new_exp;
5D54  4B11     INFSNZ 0x11, F, BANKED
5D56  2B12     INCF 0x12, F, BANKED
6112  4A2B     INFSNZ 0x2B, F, ACCESS
6114  2A2C     INCF 0x2C, F, ACCESS
155:           		}
156:           	}
157:           
158:           	/* Overflow ? Return infinity */
159:           	if (!(new_exp < SPEXPM)) {
5D58  BF12     BTFSC 0x12, 7, BANKED
5D5A  EFB7     GOTO 0x5D6E
5D5C  F02E     NOP
5D5E  5112     MOVF 0x12, W, BANKED
5D60  E108     BNZ 0x5D72
5D62  2911     INCF 0x11, W, BANKED
5D64  A0D8     BTFSS 0xFD8, 0, ACCESS
5D66  EFB7     GOTO 0x5D6E
5D68  F02E     NOP
5D6A  EFB9     GOTO 0x5D72
5D6C  F02E     NOP
5D6E  EFC4     GOTO 0x5D88
5D70  F02E     NOP
6116  BE2C     BTFSC 0x2C, 7, ACCESS
6118  EF96     GOTO 0x612C
611A  F030     NOP
611C  502C     MOVF 0x2C, W, ACCESS
611E  E108     BNZ 0x6130
6120  282B     INCF 0x2B, W, ACCESS
6122  A0D8     BTFSS 0xFD8, 0, ACCESS
6124  EF96     GOTO 0x612C
6126  F030     NOP
6128  EF98     GOTO 0x6130
612A  F030     NOP
612C  EFA3     GOTO 0x6146
612E  F030     NOP
160:           		new_exp = SPEXPM;
5D72  0E00     MOVLW 0x0
5D74  6F12     MOVWF 0x12, BANKED
5D76  6911     SETF 0x11, BANKED
6130  0E00     MOVLW 0x0
6132  6E2C     MOVWF 0x2C, ACCESS
6134  682B     SETF 0x2B, ACCESS
161:           		B_FRACTION.i = 0;
5D78  0E00     MOVLW 0x0
5D7A  6F00     MOVWF txData, BANKED
5D7C  0E00     MOVLW 0x0
5D7E  6F01     MOVWF 0x1, BANKED
5D80  0E00     MOVLW 0x0
5D82  6F02     MOVWF 0x2, BANKED
5D84  0E00     MOVLW 0x0
5D86  6F03     MOVWF 0x3, BANKED
6136  0E00     MOVLW 0x0
6138  6E1A     MOVWF 0x1A, ACCESS
613A  0E00     MOVLW 0x0
613C  6E1B     MOVWF 0x1B, ACCESS
613E  0E00     MOVLW 0x0
6140  6E1C     MOVWF 0x1C, ACCESS
6142  0E00     MOVLW 0x0
6144  6E1D     MOVWF 0x1D, ACCESS
162:           	}
163:           
164:           	/* Underflow ? Flush to zero */
165:           	if (!(0 < new_exp)) {
5D88  BF12     BTFSC 0x12, 7, BANKED
5D8A  EFD1     GOTO 0x5DA2
5D8C  F02E     NOP
5D8E  5112     MOVF 0x12, W, BANKED
5D90  E106     BNZ 0x5D9E
5D92  0511     DECF 0x11, W, BANKED
5D94  B0D8     BTFSC 0xFD8, 0, ACCESS
5D96  EFCF     GOTO 0x5D9E
5D98  F02E     NOP
5D9A  EFD1     GOTO 0x5DA2
5D9C  F02E     NOP
5D9E  EFDF     GOTO 0x5DBE
5DA0  F02E     NOP
6146  BE2C     BTFSC 0x2C, 7, ACCESS
6148  EFB0     GOTO 0x6160
614A  F030     NOP
614C  502C     MOVF 0x2C, W, ACCESS
614E  E106     BNZ 0x615C
6150  042B     DECF 0x2B, W, ACCESS
6152  B0D8     BTFSC 0xFD8, 0, ACCESS
6154  EFAE     GOTO 0x615C
6156  F030     NOP
6158  EFB0     GOTO 0x6160
615A  F030     NOP
615C  EFBE     GOTO 0x617C
615E  F030     NOP
166:           		new_exp = 0;
5DA2  0E00     MOVLW 0x0
5DA4  6F12     MOVWF 0x12, BANKED
5DA6  0E00     MOVLW 0x0
5DA8  6F11     MOVWF 0x11, BANKED
6160  0E00     MOVLW 0x0
6162  6E2C     MOVWF 0x2C, ACCESS
6164  0E00     MOVLW 0x0
6166  6E2B     MOVWF 0x2B, ACCESS
167:           		B_FRACTION.i = 0;
5DAA  0E00     MOVLW 0x0
5DAC  6F00     MOVWF txData, BANKED
5DAE  0E00     MOVLW 0x0
5DB0  6F01     MOVWF 0x1, BANKED
5DB2  0E00     MOVLW 0x0
5DB4  6F02     MOVWF 0x2, BANKED
5DB6  0E00     MOVLW 0x0
5DB8  6F03     MOVWF 0x3, BANKED
6168  0E00     MOVLW 0x0
616A  6E1A     MOVWF 0x1A, ACCESS
616C  0E00     MOVLW 0x0
616E  6E1B     MOVWF 0x1B, ACCESS
6170  0E00     MOVLW 0x0
6172  6E1C     MOVWF 0x1C, ACCESS
6174  0E00     MOVLW 0x0
6176  6E1D     MOVWF 0x1D, ACCESS
168:                           // no negative fp 0 for now
169:                           sign = 0;
5DBA  0E00     MOVLW 0x0
5DBC  6F10     MOVWF 0x10, BANKED
6178  0E00     MOVLW 0x0
617A  6E2A     MOVWF 0x2A, ACCESS
170:           	}
171:           
172:           	/* Pack and return result */
173:           	bexp = new_exp;
5DC0  F844     NOP
5DC2  F617     NOP
617E  F4AC     NOP
6180  F531     NOP
174:           	// set the low bit of the exponent ...
175:           	if (bexp & 0x1) {
5DC4  A117     BTFSS 0x17, 0, BANKED
5DC6  EFE7     GOTO 0x5DCE
5DC8  F02E     NOP
5DCA  EFE9     GOTO 0x5DD2
5DCC  F02E     NOP
5DCE  EFEC     GOTO 0x5DD8
5DD0  F02E     NOP
6182  A031     BTFSS 0x31, 0, ACCESS
6184  EFC6     GOTO 0x618C
6186  F030     NOP
6188  EFC8     GOTO 0x6190
618A  F030     NOP
618C  EFCB     GOTO 0x6196
618E  F030     NOP
176:           		B_FRACTION.fAsBytes.c |= 0x80;
5DD2  8F02     BSF 0x2, 7, BANKED
6190  8E1C     BSF 0x1C, 7, ACCESS
177:           	}
5DD4  EFED     GOTO 0x5DDA
5DD6  F02E     NOP
6192  EFCC     GOTO 0x6198
6194  F030     NOP
178:           	// AND out the leading 1
179:           	else {
180:           		B_FRACTION.fAsBytes.c &= 0x7F;
5DD8  9F02     BCF 0x2, 7, BANKED
6196  9E1C     BCF 0x1C, 7, ACCESS
181:           	}
182:           	B_FRACTION.fAsBytes.d = bexp >> 1;
5DDA  90D8     BCF 0xFD8, 0, ACCESS
5DDC  3117     RRCF 0x17, W, BANKED
5DDE  6F03     MOVWF 0x3, BANKED
5DE0  EF91     GOTO 0x5B22
5DE2  F02D     NOP
6198  90D8     BCF 0xFD8, 0, ACCESS
619A  3031     RRCF 0x31, W, ACCESS
619C  6E1D     MOVWF 0x1D, ACCESS
619E  EF70     GOTO 0x5EE0
61A0  F02F     NOP
183:           	B_FRACTION.fAsBytes.d |= sign;
184:           	return b;
185:           }
5DE4  0012     RETURN 0
61A2  0012     RETURN 0
186:           
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/sprcadd.c  -----------------------
1:             /* SP relaxed compliance floating point add intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             
6:             // single monlithic add function
7:             
8:             /* SP Add */
9:             SP
10:            SPADD(SP b, SP a) {
11:            #define A_FRACTION    (*(SFP *)&a)
12:            #define B_FRACTION    (*(SFP *)&b)
13:            	unsigned char signs;	/* leftmost bit stores sign of b, next bit stores
14:            				   0 if and only if a and b have the same sign  */
15:            	unsigned char bexp;	/* Dst exponent */
16:            	unsigned char aexp;	/* Src exponent */
17:            	unsigned char grs;	/* Guard, round, sticky */
18:            
19:            
20:            	/* Unpack and check operands */
21:            	signs = B_FRACTION.fAsBytes.d & 0x80;
4716  0106     MOVLB 0x6
4718  5103     MOVF 0x3, W, BANKED
471A  0B80     ANDLW 0x80
471C  6F0C     MOVWF 0xC, BANKED
4C14  5036     MOVF 0x36, W, ACCESS
22:            	bexp = B_FRACTION.fAsBytes.d << 1;
471E  5103     MOVF 0x3, W, BANKED
4720  2503     ADDWF 0x3, W, BANKED
4722  6F0E     MOVWF 0xE, BANKED
4C1A  5036     MOVF 0x36, W, ACCESS
4C1C  2436     ADDWF 0x36, W, ACCESS
4C1E  6E41     MOVWF NVMCON1, ACCESS
23:            	if (B_FRACTION.fAsBytes.c & 0x80) {
4724  AF02     BTFSS 0x2, 7, BANKED
4726  EF97     GOTO 0x472E
4728  F023     NOP
472A  EF99     GOTO 0x4732
472C  F023     NOP
472E  EF9A     GOTO 0x4734
4730  F023     NOP
4C20  AE35     BTFSS 0x35, 7, ACCESS
4C22  EF15     GOTO 0x4C2A
4C24  F026     NOP
4C26  EF17     GOTO 0x4C2E
4C28  F026     NOP
4C2A  EF18     GOTO 0x4C30
4C2C  F026     NOP
24:            		bexp |= 0x1;
4732  810E     BSF 0xE, 0, BANKED
4C2E  8041     BSF NVMCON1, 0, ACCESS
25:            	}
26:            
27:            	/* Destination normal ? */
28:            	if (bexp) {
4734  510E     MOVF 0xE, W, BANKED
4736  B4D8     BTFSC 0xFD8, 2, ACCESS
4738  EFA0     GOTO 0x4740
473A  F023     NOP
473C  EFA2     GOTO 0x4744
473E  F023     NOP
4740  EFB7     GOTO 0x476E
4742  F023     NOP
4C30  5041     MOVF NVMCON1, W, ACCESS
4C32  B4D8     BTFSC 0xFD8, 2, ACCESS
4C34  EF1E     GOTO 0x4C3C
4C36  F026     NOP
4C38  EF20     GOTO 0x4C40
4C3A  F026     NOP
4C3C  EF35     GOTO 0x4C6A
4C3E  F026     NOP
29:            		/* Destination inf or NaN ? */
30:            		if (bexp == 0xFF) {
4744  290E     INCF 0xE, W, BANKED
4746  A4D8     BTFSS 0xFD8, 2, ACCESS
4748  EFA8     GOTO 0x4750
474A  F023     NOP
474C  EFAA     GOTO 0x4754
474E  F023     NOP
4750  EFB2     GOTO 0x4764
4752  F023     NOP
4C40  2841     INCF NVMCON1, W, ACCESS
4C42  A4D8     BTFSS 0xFD8, 2, ACCESS
4C44  EF26     GOTO 0x4C4C
4C46  F026     NOP
4C48  EF28     GOTO 0x4C50
4C4A  F026     NOP
4C4C  EF30     GOTO 0x4C60
4C4E  F026     NOP
31:            			/* Make it inf */
32:            			b = 0;
4754  0E00     MOVLW 0x0
4756  6F00     MOVWF txData, BANKED
4758  0E00     MOVLW 0x0
475A  6F01     MOVWF 0x1, BANKED
475C  0E00     MOVLW 0x0
475E  6F02     MOVWF 0x2, BANKED
4760  0E00     MOVLW 0x0
4762  6F03     MOVWF 0x3, BANKED
4C50  0E00     MOVLW 0x0
4C52  6E33     MOVWF 0x33, ACCESS
4C54  0E00     MOVLW 0x0
4C56  6E34     MOVWF 0x34, ACCESS
4C58  0E00     MOVLW 0x0
4C5A  6E35     MOVWF 0x35, ACCESS
4C5C  0E00     MOVLW 0x0
4C5E  6E36     MOVWF 0x36, ACCESS
33:            		}
34:            		// OR in the hidden 1-bit to b's fraction
35:            		B_FRACTION.i |= (int32_t) 1 << SPFRCB;
4764  8F02     BSF 0x2, 7, BANKED
4C60  8E35     BSF 0x35, 7, ACCESS
36:            		// and zero out the upper byte so we can safely shift
37:            		B_FRACTION.fAsBytes.d = 0;
4766  0E00     MOVLW 0x0
4768  6F03     MOVWF 0x3, BANKED
4C62  0E00     MOVLW 0x0
4C64  6E36     MOVWF 0x36, ACCESS
38:            	}
476A  EFBF     GOTO 0x477E
476C  F023     NOP
4C66  EF3D     GOTO 0x4C7A
4C68  F026     NOP
39:            	else {
40:            		/* Make it zero */
41:            		b = 0;
476E  0E00     MOVLW 0x0
4770  6F00     MOVWF txData, BANKED
4772  0E00     MOVLW 0x0
4774  6F01     MOVWF 0x1, BANKED
4776  0E00     MOVLW 0x0
4778  6F02     MOVWF 0x2, BANKED
477A  0E00     MOVLW 0x0
477C  6F03     MOVWF 0x3, BANKED
4C6A  0E00     MOVLW 0x0
4C6C  6E33     MOVWF 0x33, ACCESS
4C6E  0E00     MOVLW 0x0
4C70  6E34     MOVWF 0x34, ACCESS
4C72  0E00     MOVLW 0x0
4C74  6E35     MOVWF 0x35, ACCESS
4C76  0E00     MOVLW 0x0
4C78  6E36     MOVWF 0x36, ACCESS
42:            	}
43:            
44:            	aexp = A_FRACTION.fAsBytes.d & 0x80;
477E  5107     MOVF 0x7, W, BANKED
4780  0B80     ANDLW 0x80
4782  6F0D     MOVWF 0xD, BANKED
4C7A  503A     MOVF CLKRCLK, W, ACCESS
4C7C  0B80     ANDLW 0x80
4C7E  6E40     MOVWF NVMCON0, ACCESS
45:            	// sign of a different from sign of b?
46:            	if (aexp != signs) {
4784  510C     MOVF 0xC, W, BANKED
4786  190D     XORWF 0xD, W, BANKED
4788  B4D8     BTFSC 0xFD8, 2, ACCESS
478A  EFC9     GOTO 0x4792
478C  F023     NOP
478E  EFCB     GOTO 0x4796
4790  F023     NOP
4792  EFCC     GOTO 0x4798
4794  F023     NOP
4C80  503F     MOVF 0x3F, W, ACCESS
4C82  1840     XORWF NVMCON0, W, ACCESS
4C84  B4D8     BTFSC 0xFD8, 2, ACCESS
4C86  EF47     GOTO 0x4C8E
4C88  F026     NOP
4C8A  EF49     GOTO 0x4C92
4C8C  F026     NOP
4C8E  EF4A     GOTO 0x4C94
4C90  F026     NOP
47:            		signs |= 0x40;
4796  8D0C     BSF 0xC, 6, BANKED
4C92  8C3F     BSF 0x3F, 6, ACCESS
48:            	}
49:            	aexp = A_FRACTION.fAsBytes.d << 1;
4798  5107     MOVF 0x7, W, BANKED
479A  2507     ADDWF 0x7, W, BANKED
479C  6F0D     MOVWF 0xD, BANKED
4C94  503A     MOVF CLKRCLK, W, ACCESS
4C96  243A     ADDWF CLKRCLK, W, ACCESS
4C98  6E40     MOVWF NVMCON0, ACCESS
50:            	if (A_FRACTION.fAsBytes.c & 0x80) {
479E  AF06     BTFSS 0x6, 7, BANKED
47A0  EFD4     GOTO 0x47A8
47A2  F023     NOP
47A4  EFD6     GOTO 0x47AC
47A6  F023     NOP
47A8  EFD7     GOTO 0x47AE
47AA  F023     NOP
4C9A  AE39     BTFSS CLKRCON, 7, ACCESS
4C9C  EF52     GOTO 0x4CA4
4C9E  F026     NOP
4CA0  EF54     GOTO 0x4CA8
4CA2  F026     NOP
4CA4  EF55     GOTO 0x4CAA
4CA6  F026     NOP
51:            		aexp |= 0x1;
47AC  810D     BSF 0xD, 0, BANKED
4CA8  8040     BSF NVMCON0, 0, ACCESS
52:            	}
53:            
54:            	/* Destination normal ? */
55:            	if (aexp) {
47AE  510D     MOVF 0xD, W, BANKED
47B0  B4D8     BTFSC 0xFD8, 2, ACCESS
47B2  EFDD     GOTO 0x47BA
47B4  F023     NOP
47B6  EFDF     GOTO 0x47BE
47B8  F023     NOP
47BA  EFF4     GOTO 0x47E8
47BC  F023     NOP
4CAA  5040     MOVF NVMCON0, W, ACCESS
4CAC  B4D8     BTFSC 0xFD8, 2, ACCESS
4CAE  EF5B     GOTO 0x4CB6
4CB0  F026     NOP
4CB2  EF5D     GOTO 0x4CBA
4CB4  F026     NOP
4CB6  EF72     GOTO 0x4CE4
4CB8  F026     NOP
56:            		/* Destination inf or NaN ? */
57:            		if (aexp == 0xFF) {
47BE  290D     INCF 0xD, W, BANKED
47C0  A4D8     BTFSS 0xFD8, 2, ACCESS
47C2  EFE5     GOTO 0x47CA
47C4  F023     NOP
47C6  EFE7     GOTO 0x47CE
47C8  F023     NOP
47CA  EFEF     GOTO 0x47DE
47CC  F023     NOP
4CBA  2840     INCF NVMCON0, W, ACCESS
4CBC  A4D8     BTFSS 0xFD8, 2, ACCESS
4CBE  EF63     GOTO 0x4CC6
4CC0  F026     NOP
4CC2  EF65     GOTO 0x4CCA
4CC4  F026     NOP
4CC6  EF6D     GOTO 0x4CDA
4CC8  F026     NOP
58:            			/* Make it inf */
59:            			a = 0;
47CE  0E00     MOVLW 0x0
47D0  6F04     MOVWF 0x4, BANKED
47D2  0E00     MOVLW 0x0
47D4  6F05     MOVWF 0x5, BANKED
47D6  0E00     MOVLW 0x0
47D8  6F06     MOVWF 0x6, BANKED
47DA  0E00     MOVLW 0x0
47DC  6F07     MOVWF 0x7, BANKED
4CCA  0E00     MOVLW 0x0
4CCC  6E37     MOVWF 0x37, ACCESS
4CCE  0E00     MOVLW 0x0
4CD0  6E38     MOVWF 0x38, ACCESS
4CD2  0E00     MOVLW 0x0
4CD4  6E39     MOVWF CLKRCON, ACCESS
4CD6  0E00     MOVLW 0x0
4CD8  6E3A     MOVWF CLKRCLK, ACCESS
60:            		}
61:            		// OR in the hidden 1-bit to a's fraction
62:            		A_FRACTION.i |= (int32_t) 1 << SPFRCB;
47DE  8F06     BSF 0x6, 7, BANKED
4CDA  8E39     BSF CLKRCON, 7, ACCESS
63:            		// and zero out the upper bits so we can safely shift
64:            		A_FRACTION.fAsBytes.d = 0;
47E0  0E00     MOVLW 0x0
47E2  6F07     MOVWF 0x7, BANKED
4CDC  0E00     MOVLW 0x0
4CDE  6E3A     MOVWF CLKRCLK, ACCESS
65:            	}
47E4  EFFC     GOTO 0x47F8
47E6  F023     NOP
4CE0  EF7A     GOTO 0x4CF4
4CE2  F026     NOP
66:            	else {
67:            		/* Make it zero */
68:            		a = 0;
47E8  0E00     MOVLW 0x0
47EA  6F04     MOVWF 0x4, BANKED
47EC  0E00     MOVLW 0x0
47EE  6F05     MOVWF 0x5, BANKED
47F0  0E00     MOVLW 0x0
47F2  6F06     MOVWF 0x6, BANKED
47F4  0E00     MOVLW 0x0
47F6  6F07     MOVWF 0x7, BANKED
4CE4  0E00     MOVLW 0x0
4CE6  6E37     MOVWF 0x37, ACCESS
4CE8  0E00     MOVLW 0x0
4CEA  6E38     MOVWF 0x38, ACCESS
4CEC  0E00     MOVLW 0x0
4CEE  6E39     MOVWF CLKRCON, ACCESS
4CF0  0E00     MOVLW 0x0
4CF2  6E3A     MOVWF CLKRCLK, ACCESS
69:            	}
70:            
71:            	/* Add */
72:            
73:            	/* Get smaller operand in b */
74:            
75:            	if (aexp < bexp) {
47F8  510E     MOVF 0xE, W, BANKED
47FA  5D0D     SUBWF 0xD, W, BANKED
47FC  B0D8     BTFSC 0xFD8, 0, ACCESS
47FE  EF03     GOTO 0x4806
4800  F024     NOP
4802  EF05     GOTO 0x480A
4804  F024     NOP
4806  EF3B     GOTO 0x4876
4808  F024     NOP
4CF4  5041     MOVF NVMCON1, W, ACCESS
4CF6  5C40     SUBWF NVMCON0, W, ACCESS
4CF8  B0D8     BTFSC 0xFD8, 0, ACCESS
4CFA  EF81     GOTO 0x4D02
4CFC  F026     NOP
4CFE  EF83     GOTO 0x4D06
4D00  F026     NOP
4D02  EFB9     GOTO 0x4D72
4D04  F026     NOP
76:            		// do I need to reverse the sign?
77:            		if (signs & 0x40) {
480A  AD0C     BTFSS 0xC, 6, BANKED
480C  EF0A     GOTO 0x4814
480E  F024     NOP
4810  EF0C     GOTO 0x4818
4812  F024     NOP
4814  EF0E     GOTO 0x481C
4816  F024     NOP
4D06  AC3F     BTFSS 0x3F, 6, ACCESS
4D08  EF88     GOTO 0x4D10
4D0A  F026     NOP
4D0C  EF8A     GOTO 0x4D14
4D0E  F026     NOP
4D10  EF8C     GOTO 0x4D18
4D12  F026     NOP
78:            			signs ^= 0x80;
4818  0E80     MOVLW 0x80
481A  1B0C     XORWF 0xC, F, BANKED
4D14  0E80     MOVLW 0x80
4D16  1A3F     XORWF 0x3F, F, ACCESS
79:            		}
80:            		// use  grs as swap space
81:            		grs = bexp;
481E  F838     NOP
4820  F60F     NOP
4D1A  F504     NOP
4D1C  F542     NOP
82:            		bexp = aexp;
4824  F834     NOP
4826  F60E     NOP
4D20  F500     NOP
4D22  F541     NOP
83:            		aexp = grs;
482A  F83C     NOP
482C  F60D     NOP
4D26  F508     NOP
4D28  F540     NOP
84:            		grs = B_FRACTION.fAsBytes.a;
4830  F800     NOP
4832  F60F     NOP
4D2C  F4CC     NOP
4D2E  F542     NOP
85:            		B_FRACTION.fAsBytes.a = A_FRACTION.fAsBytes.a;
4836  F810     NOP
4838  F600     NOP
4D32  F4DC     NOP
4D34  F533     NOP
86:            		A_FRACTION.fAsBytes.a = grs;
483C  F83C     NOP
483E  F604     NOP
4D38  F508     NOP
4D3A  F537     NOP
87:            		grs = B_FRACTION.fAsBytes.b;
4842  F804     NOP
4844  F60F     NOP
4D3E  F4D0     NOP
4D40  F542     NOP
88:            		B_FRACTION.fAsBytes.b = A_FRACTION.fAsBytes.b;
4848  F814     NOP
484A  F601     NOP
4D44  F4E0     NOP
4D46  F534     NOP
89:            		A_FRACTION.fAsBytes.b = grs;
484E  F83C     NOP
4850  F605     NOP
4D4A  F508     NOP
4D4C  F538     NOP
90:            		grs = B_FRACTION.fAsBytes.c;
4854  F808     NOP
4856  F60F     NOP
4D50  F4D4     NOP
4D52  F542     NOP
91:            		B_FRACTION.fAsBytes.c = A_FRACTION.fAsBytes.c;
485A  F818     NOP
485C  F602     NOP
4D56  F4E4     NOP
4D58  F535     NOP
92:            		A_FRACTION.fAsBytes.c = grs;
4860  F83C     NOP
4862  F606     NOP
4D5C  F508     NOP
4D5E  F539     NOP
93:            		grs = B_FRACTION.fAsBytes.d;
4866  F80C     NOP
4868  F60F     NOP
4D62  F4D8     NOP
4D64  F542     NOP
94:            		B_FRACTION.fAsBytes.d = A_FRACTION.fAsBytes.d;
486C  F81C     NOP
486E  F603     NOP
4D68  F4E8     NOP
4D6A  F536     NOP
95:            		A_FRACTION.fAsBytes.d = grs;
4872  F83C     NOP
4874  F607     NOP
4D6E  F508     NOP
4D70  F53A     NOP
96:            	}
97:            
98:            	grs = 0;
4876  0E00     MOVLW 0x0
4878  6F0F     MOVWF 0xF, BANKED
4D72  0E00     MOVLW 0x0
4D74  6E42     MOVWF NVMLOCK, ACCESS
99:            	/* If all ones will shift through G,R, then S = significand nonzero */
100:           	if ((aexp - bexp) > (SPFRCB + 2)) {
487A  510E     MOVF 0xE, W, BANKED
487E  F834     NOP
4880  F608     NOP
4882  6B09     CLRF 0x9, BANKED
4884  5F08     SUBWF 0x8, F, BANKED
4886  0E00     MOVLW 0x0
4888  5B09     SUBWFB 0x9, F, BANKED
488A  BF09     BTFSC 0x9, 7, BANKED
488C  EF51     GOTO 0x48A2
488E  F024     NOP
4890  5109     MOVF 0x9, W, BANKED
4892  E109     BNZ 0x48A6
4894  0E1A     MOVLW 0x1A
4896  5D08     SUBWF 0x8, W, BANKED
4898  A0D8     BTFSS 0xFD8, 0, ACCESS
489A  EF51     GOTO 0x48A2
489C  F024     NOP
489E  EF53     GOTO 0x48A6
48A0  F024     NOP
48A2  EF8B     GOTO 0x4916
48A4  F024     NOP
4D76  5041     MOVF NVMCON1, W, ACCESS
4D7A  F500     NOP
4D7C  F53B     NOP
4D7E  6A3C     CLRF 0x3C, ACCESS
4D80  5E3B     SUBWF 0x3B, F, ACCESS
4D82  0E00     MOVLW 0x0
4D84  5A3C     SUBWFB 0x3C, F, ACCESS
4D86  BE3C     BTFSC 0x3C, 7, ACCESS
4D88  EFCF     GOTO 0x4D9E
4D8A  F026     NOP
4D8C  503C     MOVF 0x3C, W, ACCESS
4D8E  E109     BNZ 0x4DA2
4D90  0E1A     MOVLW 0x1A
4D92  5C3B     SUBWF 0x3B, W, ACCESS
4D94  A0D8     BTFSS 0xFD8, 0, ACCESS
4D96  EFCF     GOTO 0x4D9E
4D98  F026     NOP
4D9A  EFD1     GOTO 0x4DA2
4D9C  F026     NOP
4D9E  EF09     GOTO 0x4E12
4DA0  F027     NOP
101:           		grs = B_FRACTION.i ? 1 : 0;
48A6  5100     MOVF txData, W, BANKED
48A8  1101     IORWF 0x1, W, BANKED
48AA  1102     IORWF 0x2, W, BANKED
48AC  1103     IORWF 0x3, W, BANKED
48AE  A4D8     BTFSS 0xFD8, 2, ACCESS
48B0  EF5C     GOTO 0x48B8
48B2  F024     NOP
48B4  EF5F     GOTO 0x48BE
48B6  F024     NOP
48B8  0E01     MOVLW 0x1
48BA  EF60     GOTO 0x48C0
48BC  F024     NOP
48BE  0E00     MOVLW 0x0
48C0  6F0F     MOVWF 0xF, BANKED
4DA2  5033     MOVF 0x33, W, ACCESS
4DA4  1034     IORWF 0x34, W, ACCESS
4DA6  1035     IORWF 0x35, W, ACCESS
4DA8  1036     IORWF 0x36, W, ACCESS
4DAA  A4D8     BTFSS 0xFD8, 2, ACCESS
4DAC  EFDA     GOTO 0x4DB4
4DAE  F026     NOP
4DB0  EFDD     GOTO 0x4DBA
4DB2  F026     NOP
4DB4  0E01     MOVLW 0x1
4DB6  EFDE     GOTO 0x4DBC
4DB8  F026     NOP
4DBA  0E00     MOVLW 0x0
4DBC  6E42     MOVWF NVMLOCK, ACCESS
102:           		B_FRACTION.i = 0;
48C2  0E00     MOVLW 0x0
48C4  6F00     MOVWF txData, BANKED
48C6  0E00     MOVLW 0x0
48C8  6F01     MOVWF 0x1, BANKED
48CA  0E00     MOVLW 0x0
48CC  6F02     MOVWF 0x2, BANKED
48CE  0E00     MOVLW 0x0
48D0  6F03     MOVWF 0x3, BANKED
4DBE  0E00     MOVLW 0x0
4DC0  6E33     MOVWF 0x33, ACCESS
4DC2  0E00     MOVLW 0x0
4DC4  6E34     MOVWF 0x34, ACCESS
4DC6  0E00     MOVLW 0x0
4DC8  6E35     MOVWF 0x35, ACCESS
4DCA  0E00     MOVLW 0x0
4DCC  6E36     MOVWF 0x36, ACCESS
103:           		bexp = aexp;
48D4  F834     NOP
48D6  F60E     NOP
4DD0  F500     NOP
4DD2  F541     NOP
104:           	}
48D8  EF94     GOTO 0x4928
48DA  F024     NOP
4DD4  EF12     GOTO 0x4E24
4DD6  F027     NOP
105:           	else {
106:           		while (bexp < aexp) {
107:           			/* Shift smaller operand right until exponents equal */
108:           			/* save the bits shifted out in grs    */
109:           			if (grs & 1) {
48DC  A10F     BTFSS 0xF, 0, BANKED
48DE  EF73     GOTO 0x48E6
48E0  F024     NOP
48E2  EF75     GOTO 0x48EA
48E4  F024     NOP
48E6  EF7B     GOTO 0x48F6
48E8  F024     NOP
4DD8  A042     BTFSS NVMLOCK, 0, ACCESS
4DDA  EFF1     GOTO 0x4DE2
4DDC  F026     NOP
4DDE  EFF3     GOTO 0x4DE6
4DE0  F026     NOP
4DE2  EFF9     GOTO 0x4DF2
4DE4  F026     NOP
110:           				grs = (grs >> 1) | 0x1;
48EA  90D8     BCF 0xFD8, 0, ACCESS
48EC  310F     RRCF 0xF, W, BANKED
48EE  0901     IORLW 0x1
48F0  6F0F     MOVWF 0xF, BANKED
4DE6  90D8     BCF 0xFD8, 0, ACCESS
4DE8  3042     RRCF NVMLOCK, W, ACCESS
4DEA  0901     IORLW 0x1
4DEC  6E42     MOVWF NVMLOCK, ACCESS
111:           			}
48F2  EF7D     GOTO 0x48FA
48F4  F024     NOP
4DEE  EFFB     GOTO 0x4DF6
4DF0  F026     NOP
112:           			else {
113:           				grs >>= 1;
48F6  90D8     BCF 0xFD8, 0, ACCESS
48F8  330F     RRCF 0xF, F, BANKED
4DF2  90D8     BCF 0xFD8, 0, ACCESS
4DF4  3242     RRCF NVMLOCK, F, ACCESS
114:           			}
115:           			if (B_FRACTION.i & 0x1) {
48FA  A100     BTFSS txData, 0, BANKED
48FC  EF82     GOTO 0x4904
48FE  F024     NOP
4900  EF84     GOTO 0x4908
4902  F024     NOP
4904  EF85     GOTO 0x490A
4906  F024     NOP
4DF6  A033     BTFSS 0x33, 0, ACCESS
4DF8  EF00     GOTO 0x4E00
4DFA  F027     NOP
4DFC  EF02     GOTO 0x4E04
4DFE  F027     NOP
4E00  EF03     GOTO 0x4E06
4E02  F027     NOP
116:           				grs |= 0x80;
4908  8F0F     BSF 0xF, 7, BANKED
4E04  8E42     BSF NVMLOCK, 7, ACCESS
117:           			}
118:           			B_FRACTION.i >>= 1;
490A  3503     RLCF 0x3, W, BANKED
490C  3303     RRCF 0x3, F, BANKED
490E  3302     RRCF 0x2, F, BANKED
4910  3301     RRCF 0x1, F, BANKED
4912  3300     RRCF txData, F, BANKED
4E06  3436     RLCF 0x36, W, ACCESS
4E08  3236     RRCF 0x36, F, ACCESS
4E0A  3235     RRCF 0x35, F, ACCESS
4E0C  3234     RRCF 0x34, F, ACCESS
4E0E  3233     RRCF 0x33, F, ACCESS
119:           			bexp++;
4914  2B0E     INCF 0xE, F, BANKED
4E10  2A41     INCF NVMCON1, F, ACCESS
120:           		}
4916  510D     MOVF 0xD, W, BANKED
4918  5D0E     SUBWF 0xE, W, BANKED
491A  A0D8     BTFSS 0xFD8, 0, ACCESS
491C  EF92     GOTO 0x4924
491E  F024     NOP
4920  EF94     GOTO 0x4928
4922  F024     NOP
4924  EF6E     GOTO 0x48DC
4926  F024     NOP
4E12  5040     MOVF NVMCON0, W, ACCESS
4E14  5C41     SUBWF NVMCON1, W, ACCESS
4E16  A0D8     BTFSS 0xFD8, 0, ACCESS
4E18  EF10     GOTO 0x4E20
4E1A  F027     NOP
4E1C  EF12     GOTO 0x4E24
4E1E  F027     NOP
4E20  EFEC     GOTO 0x4DD8
4E22  F026     NOP
121:           	}
122:           
123:           	/* Add or subtract magnitude ? */
124:           	if (!(signs & 0x40)) {
4928  BD0C     BTFSC 0xC, 6, BANKED
492A  EF99     GOTO 0x4932
492C  F024     NOP
492E  EF9B     GOTO 0x4936
4930  F024     NOP
4932  EFDB     GOTO 0x49B6
4934  F024     NOP
4E24  BC3F     BTFSC 0x3F, 6, ACCESS
4E26  EF17     GOTO 0x4E2E
4E28  F027     NOP
4E2A  EF19     GOTO 0x4E32
4E2C  F027     NOP
4E2E  EF59     GOTO 0x4EB2
4E30  F027     NOP
125:           
126:           		/* Quick exit for 0 + 0, same sign */
127:           		if (!bexp) {
4936  510E     MOVF 0xE, W, BANKED
4938  A4D8     BTFSS 0xFD8, 2, ACCESS
493A  EFA1     GOTO 0x4942
493C  F024     NOP
493E  EFA3     GOTO 0x4946
4940  F024     NOP
4942  EFAD     GOTO 0x495A
4944  F024     NOP
4E32  5041     MOVF NVMCON1, W, ACCESS
4E34  A4D8     BTFSS 0xFD8, 2, ACCESS
4E36  EF1F     GOTO 0x4E3E
4E38  F027     NOP
4E3A  EF21     GOTO 0x4E42
4E3C  F027     NOP
4E3E  EF2B     GOTO 0x4E56
4E40  F027     NOP
128:           			return 0.0;
4946  0E00     MOVLW 0x0
4948  6F00     MOVWF txData, BANKED
494A  0E00     MOVLW 0x0
494C  6F01     MOVWF 0x1, BANKED
494E  0E00     MOVLW 0x0
4950  6F02     MOVWF 0x2, BANKED
4952  0E00     MOVLW 0x0
4954  6F03     MOVWF 0x3, BANKED
4956  EF09     GOTO 0x4C12
4958  F026     NOP
4E42  0E00     MOVLW 0x0
4E44  6E33     MOVWF 0x33, ACCESS
4E46  0E00     MOVLW 0x0
4E48  6E34     MOVWF 0x34, ACCESS
4E4A  0E00     MOVLW 0x0
4E4C  6E35     MOVWF 0x35, ACCESS
4E4E  0E00     MOVLW 0x0
4E50  6E36     MOVWF 0x36, ACCESS
4E52  EF87     GOTO 0x510E
4E54  F028     NOP
129:           		}
130:           
131:           		/* Add magnitude */
132:           		B_FRACTION.i += A_FRACTION.i;
495A  5104     MOVF 0x4, W, BANKED
495C  2700     ADDWF txData, F, BANKED
495E  5105     MOVF 0x5, W, BANKED
4960  2301     ADDWFC 0x1, F, BANKED
4962  5106     MOVF 0x6, W, BANKED
4964  2302     ADDWFC 0x2, F, BANKED
4966  5107     MOVF 0x7, W, BANKED
4968  2303     ADDWFC 0x3, F, BANKED
4E56  5037     MOVF 0x37, W, ACCESS
4E58  2633     ADDWF 0x33, F, ACCESS
4E5A  5038     MOVF 0x38, W, ACCESS
4E5C  2234     ADDWFC 0x34, F, ACCESS
4E5E  5039     MOVF CLKRCON, W, ACCESS
4E60  2235     ADDWFC 0x35, F, ACCESS
4E62  503A     MOVF CLKRCLK, W, ACCESS
4E64  2236     ADDWFC 0x36, F, ACCESS
133:           		// did it overflow?
134:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
496A  A103     BTFSS 0x3, 0, BANKED
496C  EFBA     GOTO 0x4974
496E  F024     NOP
4970  EFBC     GOTO 0x4978
4972  F024     NOP
4974  EF68     GOTO 0x4AD0
4976  F025     NOP
4E66  A036     BTFSS 0x36, 0, ACCESS
4E68  EF38     GOTO 0x4E70
4E6A  F027     NOP
4E6C  EF3A     GOTO 0x4E74
4E6E  F027     NOP
4E70  EFE6     GOTO 0x4FCC
4E72  F027     NOP
135:           			if (grs & 1) {
4978  A10F     BTFSS 0xF, 0, BANKED
497A  EFC1     GOTO 0x4982
497C  F024     NOP
497E  EFC3     GOTO 0x4986
4980  F024     NOP
4982  EFC9     GOTO 0x4992
4984  F024     NOP
4E74  A042     BTFSS NVMLOCK, 0, ACCESS
4E76  EF3F     GOTO 0x4E7E
4E78  F027     NOP
4E7A  EF41     GOTO 0x4E82
4E7C  F027     NOP
4E7E  EF47     GOTO 0x4E8E
4E80  F027     NOP
136:           				grs = (grs >> 1) | 0x1;
4986  90D8     BCF 0xFD8, 0, ACCESS
4988  310F     RRCF 0xF, W, BANKED
498A  0901     IORLW 0x1
498C  6F0F     MOVWF 0xF, BANKED
4E82  90D8     BCF 0xFD8, 0, ACCESS
4E84  3042     RRCF NVMLOCK, W, ACCESS
4E86  0901     IORLW 0x1
4E88  6E42     MOVWF NVMLOCK, ACCESS
137:           			}
498E  EFCB     GOTO 0x4996
4990  F024     NOP
4E8A  EF49     GOTO 0x4E92
4E8C  F027     NOP
138:           			else {
139:           				grs >>= 1;
4992  90D8     BCF 0xFD8, 0, ACCESS
4994  330F     RRCF 0xF, F, BANKED
4E8E  90D8     BCF 0xFD8, 0, ACCESS
4E90  3242     RRCF NVMLOCK, F, ACCESS
140:           			}
141:           			if (B_FRACTION.i & 1) {
4996  A100     BTFSS txData, 0, BANKED
4998  EFD0     GOTO 0x49A0
499A  F024     NOP
499C  EFD2     GOTO 0x49A4
499E  F024     NOP
49A0  EFD3     GOTO 0x49A6
49A2  F024     NOP
4E92  A033     BTFSS 0x33, 0, ACCESS
4E94  EF4E     GOTO 0x4E9C
4E96  F027     NOP
4E98  EF50     GOTO 0x4EA0
4E9A  F027     NOP
4E9C  EF51     GOTO 0x4EA2
4E9E  F027     NOP
142:           				grs |= 0x80;
49A4  8F0F     BSF 0xF, 7, BANKED
4EA0  8E42     BSF NVMLOCK, 7, ACCESS
143:           			}
144:           			B_FRACTION.i >>= 1;
49A6  3503     RLCF 0x3, W, BANKED
49A8  3303     RRCF 0x3, F, BANKED
49AA  3302     RRCF 0x2, F, BANKED
49AC  3301     RRCF 0x1, F, BANKED
49AE  3300     RRCF txData, F, BANKED
4EA2  3436     RLCF 0x36, W, ACCESS
4EA4  3236     RRCF 0x36, F, ACCESS
4EA6  3235     RRCF 0x35, F, ACCESS
4EA8  3234     RRCF 0x34, F, ACCESS
4EAA  3233     RRCF 0x33, F, ACCESS
145:           			++bexp;
49B0  2B0E     INCF 0xE, F, BANKED
49B2  EF68     GOTO 0x4AD0
49B4  F025     NOP
4EAC  2A41     INCF NVMCON1, F, ACCESS
4EAE  EFE6     GOTO 0x4FCC
4EB0  F027     NOP
146:           		}
147:           
148:           	}
149:           	else {
150:           
151:           		/* Subtract magnitude */
152:           
153:           		if (B_FRACTION.i < A_FRACTION.i) {
49B6  5104     MOVF 0x4, W, BANKED
49B8  5D00     SUBWF txData, W, BANKED
49BA  5105     MOVF 0x5, W, BANKED
49BC  5901     SUBWFB 0x1, W, BANKED
49BE  5106     MOVF 0x6, W, BANKED
49C0  5902     SUBWFB 0x2, W, BANKED
49C2  5103     MOVF 0x3, W, BANKED
49C4  0A80     XORLW 0x80
49C6  6F08     MOVWF 0x8, BANKED
49C8  5107     MOVF 0x7, W, BANKED
49CA  0A80     XORLW 0x80
49CC  5908     SUBWFB 0x8, W, BANKED
49CE  B0D8     BTFSC 0xFD8, 0, ACCESS
49D0  EFEC     GOTO 0x49D8
49D2  F024     NOP
49D4  EFEE     GOTO 0x49DC
49D6  F024     NOP
49D8  EF19     GOTO 0x4A32
49DA  F025     NOP
4EB2  5037     MOVF 0x37, W, ACCESS
4EB4  5C33     SUBWF 0x33, W, ACCESS
4EB6  5038     MOVF 0x38, W, ACCESS
4EB8  5834     SUBWFB 0x34, W, ACCESS
4EBA  5039     MOVF CLKRCON, W, ACCESS
4EBC  5835     SUBWFB 0x35, W, ACCESS
4EBE  5036     MOVF 0x36, W, ACCESS
4EC0  0A80     XORLW 0x80
4EC2  6E3B     MOVWF 0x3B, ACCESS
4EC4  503A     MOVF CLKRCLK, W, ACCESS
4EC6  0A80     XORLW 0x80
4EC8  583B     SUBWFB 0x3B, W, ACCESS
4ECA  B0D8     BTFSC 0xFD8, 0, ACCESS
4ECC  EF6A     GOTO 0x4ED4
4ECE  F027     NOP
4ED0  EF6C     GOTO 0x4ED8
4ED2  F027     NOP
4ED4  EF97     GOTO 0x4F2E
4ED6  F027     NOP
154:           			B_FRACTION.i = A_FRACTION.i - B_FRACTION.i - 1;
49DC  5100     MOVF txData, W, BANKED
49DE  5D04     SUBWF 0x4, W, BANKED
49E0  6F08     MOVWF 0x8, BANKED
49E2  5101     MOVF 0x1, W, BANKED
49E4  5905     SUBWFB 0x5, W, BANKED
49E6  6F09     MOVWF 0x9, BANKED
49E8  5102     MOVF 0x2, W, BANKED
49EA  5906     SUBWFB 0x6, W, BANKED
49EC  6F0A     MOVWF 0xA, BANKED
49EE  5103     MOVF 0x3, W, BANKED
49F0  5907     SUBWFB 0x7, W, BANKED
49F2  6F0B     MOVWF 0xB, BANKED
49F4  0EFF     MOVLW 0xFF
49F6  2508     ADDWF 0x8, W, BANKED
49F8  6F00     MOVWF txData, BANKED
49FA  0EFF     MOVLW 0xFF
49FC  2109     ADDWFC 0x9, W, BANKED
49FE  6F01     MOVWF 0x1, BANKED
4A00  0EFF     MOVLW 0xFF
4A02  210A     ADDWFC 0xA, W, BANKED
4A04  6F02     MOVWF 0x2, BANKED
4A06  0EFF     MOVLW 0xFF
4A08  210B     ADDWFC 0xB, W, BANKED
4A0A  6F03     MOVWF 0x3, BANKED
4ED8  5033     MOVF 0x33, W, ACCESS
4EDA  5C37     SUBWF 0x37, W, ACCESS
4EDC  6E3B     MOVWF 0x3B, ACCESS
4EDE  5034     MOVF 0x34, W, ACCESS
4EE0  5838     SUBWFB 0x38, W, ACCESS
4EE2  6E3C     MOVWF 0x3C, ACCESS
4EE4  5035     MOVF 0x35, W, ACCESS
4EE6  5839     SUBWFB CLKRCON, W, ACCESS
4EE8  6E3D     MOVWF 0x3D, ACCESS
4EEA  5036     MOVF 0x36, W, ACCESS
4EEC  583A     SUBWFB CLKRCLK, W, ACCESS
4EEE  6E3E     MOVWF 0x3E, ACCESS
4EF0  0EFF     MOVLW 0xFF
4EF2  243B     ADDWF 0x3B, W, ACCESS
4EF4  6E33     MOVWF 0x33, ACCESS
4EF6  0EFF     MOVLW 0xFF
4EF8  203C     ADDWFC 0x3C, W, ACCESS
4EFA  6E34     MOVWF 0x34, ACCESS
4EFC  0EFF     MOVLW 0xFF
4EFE  203D     ADDWFC 0x3D, W, ACCESS
4F00  6E35     MOVWF 0x35, ACCESS
4F02  0EFF     MOVLW 0xFF
4F04  203E     ADDWFC 0x3E, W, ACCESS
4F06  6E36     MOVWF 0x36, ACCESS
155:           			signs ^= 0x80;
4A0C  0E80     MOVLW 0x80
4A0E  1B0C     XORWF 0xC, F, BANKED
4F08  0E80     MOVLW 0x80
4F0A  1A3F     XORWF 0x3F, F, ACCESS
156:           			grs = ~grs + 1;
4A10  6D0F     NEGF 0xF, BANKED
4F0C  6C42     NEGF NVMLOCK, ACCESS
157:           			if (!grs) {
4A12  510F     MOVF 0xF, W, BANKED
4A14  A4D8     BTFSS 0xFD8, 2, ACCESS
4A16  EF0F     GOTO 0x4A1E
4A18  F025     NOP
4A1A  EF11     GOTO 0x4A22
4A1C  F025     NOP
4A1E  EF21     GOTO 0x4A42
4A20  F025     NOP
4F0E  5042     MOVF NVMLOCK, W, ACCESS
4F10  A4D8     BTFSS 0xFD8, 2, ACCESS
4F12  EF8D     GOTO 0x4F1A
4F14  F027     NOP
4F16  EF8F     GOTO 0x4F1E
4F18  F027     NOP
4F1A  EF9F     GOTO 0x4F3E
4F1C  F027     NOP
158:           				++B_FRACTION.i;
4A22  0E01     MOVLW 0x1
4A24  2700     ADDWF txData, F, BANKED
4A26  0E00     MOVLW 0x0
4A28  2301     ADDWFC 0x1, F, BANKED
4A2A  2302     ADDWFC 0x2, F, BANKED
4A2C  2303     ADDWFC 0x3, F, BANKED
4A2E  EF21     GOTO 0x4A42
4A30  F025     NOP
4F1E  0E01     MOVLW 0x1
4F20  2633     ADDWF 0x33, F, ACCESS
4F22  0E00     MOVLW 0x0
4F24  2234     ADDWFC 0x34, F, ACCESS
4F26  2235     ADDWFC 0x35, F, ACCESS
4F28  2236     ADDWFC 0x36, F, ACCESS
4F2A  EF9F     GOTO 0x4F3E
4F2C  F027     NOP
159:           			}
160:           		}
161:           		else {
162:           			B_FRACTION.i -= A_FRACTION.i;
4A32  5104     MOVF 0x4, W, BANKED
4A34  5F00     SUBWF txData, F, BANKED
4A36  5105     MOVF 0x5, W, BANKED
4A38  5B01     SUBWFB 0x1, F, BANKED
4A3A  5106     MOVF 0x6, W, BANKED
4A3C  5B02     SUBWFB 0x2, F, BANKED
4A3E  5107     MOVF 0x7, W, BANKED
4A40  5B03     SUBWFB 0x3, F, BANKED
4F2E  5037     MOVF 0x37, W, ACCESS
4F30  5E33     SUBWF 0x33, F, ACCESS
4F32  5038     MOVF 0x38, W, ACCESS
4F34  5A34     SUBWFB 0x34, F, ACCESS
4F36  5039     MOVF CLKRCON, W, ACCESS
4F38  5A35     SUBWFB 0x35, F, ACCESS
4F3A  503A     MOVF CLKRCLK, W, ACCESS
4F3C  5A36     SUBWFB 0x36, F, ACCESS
163:           		}
164:           
165:           		/* True zero ? */
166:           		if (!B_FRACTION.i && !grs) {
4A42  5100     MOVF txData, W, BANKED
4A44  1101     IORWF 0x1, W, BANKED
4A46  1102     IORWF 0x2, W, BANKED
4A48  1103     IORWF 0x3, W, BANKED
4A4A  A4D8     BTFSS 0xFD8, 2, ACCESS
4A4C  EF2A     GOTO 0x4A54
4A4E  F025     NOP
4A50  EF2C     GOTO 0x4A58
4A52  F025     NOP
4A54  EF61     GOTO 0x4AC2
4A56  F025     NOP
4A58  510F     MOVF 0xF, W, BANKED
4A5A  A4D8     BTFSS 0xFD8, 2, ACCESS
4A5C  EF32     GOTO 0x4A64
4A5E  F025     NOP
4A60  EF34     GOTO 0x4A68
4A62  F025     NOP
4A64  EF61     GOTO 0x4AC2
4A66  F025     NOP
4F3E  5033     MOVF 0x33, W, ACCESS
4F40  1034     IORWF 0x34, W, ACCESS
4F42  1035     IORWF 0x35, W, ACCESS
4F44  1036     IORWF 0x36, W, ACCESS
4F46  A4D8     BTFSS 0xFD8, 2, ACCESS
4F48  EFA8     GOTO 0x4F50
4F4A  F027     NOP
4F4C  EFAA     GOTO 0x4F54
4F4E  F027     NOP
4F50  EFDF     GOTO 0x4FBE
4F52  F027     NOP
4F54  5042     MOVF NVMLOCK, W, ACCESS
4F56  A4D8     BTFSS 0xFD8, 2, ACCESS
4F58  EFB0     GOTO 0x4F60
4F5A  F027     NOP
4F5C  EFB2     GOTO 0x4F64
4F5E  F027     NOP
4F60  EFDF     GOTO 0x4FBE
4F62  F027     NOP
167:           			return 0.0;
4A68  0E00     MOVLW 0x0
4A6A  6F00     MOVWF txData, BANKED
4A6C  0E00     MOVLW 0x0
4A6E  6F01     MOVWF 0x1, BANKED
4A70  0E00     MOVLW 0x0
4A72  6F02     MOVWF 0x2, BANKED
4A74  0E00     MOVLW 0x0
4A76  6F03     MOVWF 0x3, BANKED
4A78  EF09     GOTO 0x4C12
4A7A  F026     NOP
4F64  0E00     MOVLW 0x0
4F66  6E33     MOVWF 0x33, ACCESS
4F68  0E00     MOVLW 0x0
4F6A  6E34     MOVWF 0x34, ACCESS
4F6C  0E00     MOVLW 0x0
4F6E  6E35     MOVWF 0x35, ACCESS
4F70  0E00     MOVLW 0x0
4F72  6E36     MOVWF 0x36, ACCESS
4F74  EF87     GOTO 0x510E
4F76  F028     NOP
168:           		}
169:           
170:           		/* Renormalize */
171:           		while (!(B_FRACTION.i & ((int32_t) 1 << SPFRCB))) {
4AC2  AF02     BTFSS 0x2, 7, BANKED
4AC4  EF66     GOTO 0x4ACC
4AC6  F025     NOP
4AC8  EF68     GOTO 0x4AD0
4ACA  F025     NOP
4ACC  EF3E     GOTO 0x4A7C
4ACE  F025     NOP
4FBE  AE35     BTFSS 0x35, 7, ACCESS
4FC0  EFE4     GOTO 0x4FC8
4FC2  F027     NOP
4FC4  EFE6     GOTO 0x4FCC
4FC6  F027     NOP
4FC8  EFBC     GOTO 0x4F78
4FCA  F027     NOP
172:           			B_FRACTION.i <<= 1;
4A7C  90D8     BCF 0xFD8, 0, ACCESS
4A7E  3700     RLCF txData, F, BANKED
4A80  3701     RLCF 0x1, F, BANKED
4A82  3702     RLCF 0x2, F, BANKED
4A84  3703     RLCF 0x3, F, BANKED
4F78  90D8     BCF 0xFD8, 0, ACCESS
4F7A  3633     RLCF 0x33, F, ACCESS
4F7C  3634     RLCF 0x34, F, ACCESS
4F7E  3635     RLCF 0x35, F, ACCESS
4F80  3636     RLCF 0x36, F, ACCESS
173:           			if (grs & 0x80) {
4A86  AF0F     BTFSS 0xF, 7, BANKED
4A88  EF48     GOTO 0x4A90
4A8A  F025     NOP
4A8C  EF4A     GOTO 0x4A94
4A8E  F025     NOP
4A90  EF4B     GOTO 0x4A96
4A92  F025     NOP
4F82  AE42     BTFSS NVMLOCK, 7, ACCESS
4F84  EFC6     GOTO 0x4F8C
4F86  F027     NOP
4F88  EFC8     GOTO 0x4F90
4F8A  F027     NOP
4F8C  EFC9     GOTO 0x4F92
4F8E  F027     NOP
174:           				B_FRACTION.i |= 0x1;
4A94  8100     BSF txData, 0, BANKED
4F90  8033     BSF 0x33, 0, ACCESS
175:           			}
176:           			if (grs & 1) {
4A96  A10F     BTFSS 0xF, 0, BANKED
4A98  EF50     GOTO 0x4AA0
4A9A  F025     NOP
4A9C  EF52     GOTO 0x4AA4
4A9E  F025     NOP
4AA0  EF56     GOTO 0x4AAC
4AA2  F025     NOP
4F92  A042     BTFSS NVMLOCK, 0, ACCESS
4F94  EFCE     GOTO 0x4F9C
4F96  F027     NOP
4F98  EFD0     GOTO 0x4FA0
4F9A  F027     NOP
4F9C  EFD4     GOTO 0x4FA8
4F9E  F027     NOP
177:           				grs = (grs << 1) | 0x1;
4AA4  80D8     BSF 0xFD8, 0, ACCESS
4AA6  370F     RLCF 0xF, F, BANKED
4FA0  80D8     BSF 0xFD8, 0, ACCESS
4FA2  3642     RLCF NVMLOCK, F, ACCESS
178:           			}
4AA8  EF58     GOTO 0x4AB0
4AAA  F025     NOP
4FA4  EFD6     GOTO 0x4FAC
4FA6  F027     NOP
179:           			else {
180:           				grs <<= 1;
4AAC  90D8     BCF 0xFD8, 0, ACCESS
4AAE  370F     RLCF 0xF, F, BANKED
4FA8  90D8     BCF 0xFD8, 0, ACCESS
4FAA  3642     RLCF NVMLOCK, F, ACCESS
181:           			}
182:           			if (bexp) {
4AB0  510E     MOVF 0xE, W, BANKED
4AB2  B4D8     BTFSC 0xFD8, 2, ACCESS
4AB4  EF5E     GOTO 0x4ABC
4AB6  F025     NOP
4AB8  EF60     GOTO 0x4AC0
4ABA  F025     NOP
4ABC  EF61     GOTO 0x4AC2
4ABE  F025     NOP
4FAC  5041     MOVF NVMCON1, W, ACCESS
4FAE  B4D8     BTFSC 0xFD8, 2, ACCESS
4FB0  EFDC     GOTO 0x4FB8
4FB2  F027     NOP
4FB4  EFDE     GOTO 0x4FBC
4FB6  F027     NOP
4FB8  EFDF     GOTO 0x4FBE
4FBA  F027     NOP
183:           				--bexp;
4AC0  070E     DECF 0xE, F, BANKED
4FBC  0641     DECF NVMCON1, F, ACCESS
184:           			}
185:           		}
186:           	}
187:           
188:           	/* Round, check overflow, underflow */
189:           
190:           	/* Round */
191:           	// reuse aexp as the rounding flag ...
192:           	aexp = 0;
4AD0  0E00     MOVLW 0x0
4AD2  6F0D     MOVWF 0xD, BANKED
4FCC  0E00     MOVLW 0x0
4FCE  6E40     MOVWF NVMCON0, ACCESS
193:           	if (grs & 0x80) {
4AD4  AF0F     BTFSS 0xF, 7, BANKED
4AD6  EF6F     GOTO 0x4ADE
4AD8  F025     NOP
4ADA  EF71     GOTO 0x4AE2
4ADC  F025     NOP
4ADE  EF8A     GOTO 0x4B14
4AE0  F025     NOP
4FD0  AE42     BTFSS NVMLOCK, 7, ACCESS
4FD2  EFED     GOTO 0x4FDA
4FD4  F027     NOP
4FD6  EFEF     GOTO 0x4FDE
4FD8  F027     NOP
4FDA  EF08     GOTO 0x5010
4FDC  F028     NOP
194:           		if (grs & 0x7f) {
4AE4  F83C     NOP
4AE6  F608     NOP
4AE8  0E7F     MOVLW 0x7F
4AEA  1708     ANDWF 0x8, F, BANKED
4AEC  B4D8     BTFSC 0xFD8, 2, ACCESS
4AEE  EF7B     GOTO 0x4AF6
4AF0  F025     NOP
4AF2  EF7D     GOTO 0x4AFA
4AF4  F025     NOP
4AF6  EF81     GOTO 0x4B02
4AF8  F025     NOP
4FE0  F508     NOP
4FE2  F53B     NOP
4FE4  0E7F     MOVLW 0x7F
4FE6  163B     ANDWF 0x3B, F, ACCESS
4FE8  B4D8     BTFSC 0xFD8, 2, ACCESS
4FEA  EFF9     GOTO 0x4FF2
4FEC  F027     NOP
4FEE  EFFB     GOTO 0x4FF6
4FF0  F027     NOP
4FF2  EFFF     GOTO 0x4FFE
4FF4  F027     NOP
195:           			aexp = 1;
4AFA  0E01     MOVLW 0x1
4AFC  6F0D     MOVWF 0xD, BANKED
4FF6  0E01     MOVLW 0x1
4FF8  6E40     MOVWF NVMCON0, ACCESS
196:           		}
4AFE  EF8A     GOTO 0x4B14
4B00  F025     NOP
4FFA  EF08     GOTO 0x5010
4FFC  F028     NOP
197:           		else {
198:           			if (B_FRACTION.i & 1) {
4B02  A100     BTFSS txData, 0, BANKED
4B04  EF86     GOTO 0x4B0C
4B06  F025     NOP
4B08  EF88     GOTO 0x4B10
4B0A  F025     NOP
4B0C  EF8A     GOTO 0x4B14
4B0E  F025     NOP
4B10  EF7D     GOTO 0x4AFA
4B12  F025     NOP
4FFE  A033     BTFSS 0x33, 0, ACCESS
5000  EF04     GOTO 0x5008
5002  F028     NOP
5004  EF06     GOTO 0x500C
5006  F028     NOP
5008  EF08     GOTO 0x5010
500A  F028     NOP
500C  EFFB     GOTO 0x4FF6
500E  F027     NOP
199:           				aexp = 1;
200:           			}
201:           		}
202:           	}
203:           	if (aexp) {
4B14  510D     MOVF 0xD, W, BANKED
4B16  B4D8     BTFSC 0xFD8, 2, ACCESS
4B18  EF90     GOTO 0x4B20
4B1A  F025     NOP
4B1C  EF92     GOTO 0x4B24
4B1E  F025     NOP
4B20  EFC5     GOTO 0x4B8A
4B22  F025     NOP
5010  5040     MOVF NVMCON0, W, ACCESS
5012  B4D8     BTFSC 0xFD8, 2, ACCESS
5014  EF0E     GOTO 0x501C
5016  F028     NOP
5018  EF10     GOTO 0x5020
501A  F028     NOP
501C  EF43     GOTO 0x5086
501E  F028     NOP
204:           		++B_FRACTION.i;
4B24  0E01     MOVLW 0x1
4B26  2700     ADDWF txData, F, BANKED
4B28  0E00     MOVLW 0x0
4B2A  2301     ADDWFC 0x1, F, BANKED
4B2C  2302     ADDWFC 0x2, F, BANKED
4B2E  2303     ADDWFC 0x3, F, BANKED
5020  0E01     MOVLW 0x1
5022  2633     ADDWF 0x33, F, ACCESS
5024  0E00     MOVLW 0x0
5026  2234     ADDWFC 0x34, F, ACCESS
5028  2235     ADDWFC 0x35, F, ACCESS
502A  2236     ADDWFC 0x36, F, ACCESS
205:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
4B30  A103     BTFSS 0x3, 0, BANKED
4B32  EF9D     GOTO 0x4B3A
4B34  F025     NOP
4B36  EF9F     GOTO 0x4B3E
4B38  F025     NOP
4B3A  EFC5     GOTO 0x4B8A
4B3C  F025     NOP
502C  A036     BTFSS 0x36, 0, ACCESS
502E  EF1B     GOTO 0x5036
5030  F028     NOP
5032  EF1D     GOTO 0x503A
5034  F028     NOP
5036  EF43     GOTO 0x5086
5038  F028     NOP
206:           			B_FRACTION.i = B_FRACTION.i >> 1;
4B40  F800     NOP
4B42  F608     NOP
4B46  F804     NOP
4B48  F609     NOP
4B4C  F808     NOP
4B4E  F60A     NOP
4B52  F80C     NOP
4B54  F60B     NOP
4B56  350B     RLCF 0xB, W, BANKED
4B58  330B     RRCF 0xB, F, BANKED
4B5A  330A     RRCF 0xA, F, BANKED
4B5C  3309     RRCF 0x9, F, BANKED
4B5E  3308     RRCF 0x8, F, BANKED
4B62  F820     NOP
4B64  F600     NOP
4B68  F824     NOP
4B6A  F601     NOP
4B6E  F828     NOP
4B70  F602     NOP
4B74  F82C     NOP
4B76  F603     NOP
503C  F4CC     NOP
503E  F53B     NOP
5042  F4D0     NOP
5044  F53C     NOP
5048  F4D4     NOP
504A  F53D     NOP
504E  F4D8     NOP
5050  F53E     NOP
5052  343E     RLCF 0x3E, W, ACCESS
5054  323E     RRCF 0x3E, F, ACCESS
5056  323D     RRCF 0x3D, F, ACCESS
5058  323C     RRCF 0x3C, F, ACCESS
505A  323B     RRCF 0x3B, F, ACCESS
505E  F4EC     NOP
5060  F533     NOP
5064  F4F0     NOP
5066  F534     NOP
506A  F4F4     NOP
506C  F535     NOP
5070  F4F8     NOP
5072  F536     NOP
207:           			if (!(bexp == 0xFF)) {
4B78  290E     INCF 0xE, W, BANKED
4B7A  B4D8     BTFSC 0xFD8, 2, ACCESS
4B7C  EFC2     GOTO 0x4B84
4B7E  F025     NOP
4B80  EFC4     GOTO 0x4B88
4B82  F025     NOP
4B84  EFC5     GOTO 0x4B8A
4B86  F025     NOP
5074  2841     INCF NVMCON1, W, ACCESS
5076  B4D8     BTFSC 0xFD8, 2, ACCESS
5078  EF40     GOTO 0x5080
507A  F028     NOP
507C  EF42     GOTO 0x5084
507E  F028     NOP
5080  EF43     GOTO 0x5086
5082  F028     NOP
208:           				++bexp;
4B88  2B0E     INCF 0xE, F, BANKED
5084  2A41     INCF NVMCON1, F, ACCESS
209:           			}
210:           		}
211:           	}
212:           
213:           	/* Overflow ? Return infinity */
214:           	/* Underflow ? Flush to zero */
215:           	if (bexp == 0xFF || bexp == 0) {
4B8A  290E     INCF 0xE, W, BANKED
4B8C  B4D8     BTFSC 0xFD8, 2, ACCESS
4B8E  EFCB     GOTO 0x4B96
4B90  F025     NOP
4B92  EFCD     GOTO 0x4B9A
4B94  F025     NOP
4B96  EFD5     GOTO 0x4BAA
4B98  F025     NOP
4B9A  510E     MOVF 0xE, W, BANKED
4B9C  A4D8     BTFSS 0xFD8, 2, ACCESS
4B9E  EFD3     GOTO 0x4BA6
4BA0  F025     NOP
4BA2  EFD5     GOTO 0x4BAA
4BA4  F025     NOP
4BA6  EFE7     GOTO 0x4BCE
4BA8  F025     NOP
5086  2841     INCF NVMCON1, W, ACCESS
5088  B4D8     BTFSC 0xFD8, 2, ACCESS
508A  EF49     GOTO 0x5092
508C  F028     NOP
508E  EF4B     GOTO 0x5096
5090  F028     NOP
5092  EF53     GOTO 0x50A6
5094  F028     NOP
5096  5041     MOVF NVMCON1, W, ACCESS
5098  A4D8     BTFSS 0xFD8, 2, ACCESS
509A  EF51     GOTO 0x50A2
509C  F028     NOP
509E  EF53     GOTO 0x50A6
50A0  F028     NOP
50A2  EF65     GOTO 0x50CA
50A4  F028     NOP
216:           		B_FRACTION.i = 0;
4BAA  0E00     MOVLW 0x0
4BAC  6F00     MOVWF txData, BANKED
4BAE  0E00     MOVLW 0x0
4BB0  6F01     MOVWF 0x1, BANKED
4BB2  0E00     MOVLW 0x0
4BB4  6F02     MOVWF 0x2, BANKED
4BB6  0E00     MOVLW 0x0
4BB8  6F03     MOVWF 0x3, BANKED
50A6  0E00     MOVLW 0x0
50A8  6E33     MOVWF 0x33, ACCESS
50AA  0E00     MOVLW 0x0
50AC  6E34     MOVWF 0x34, ACCESS
50AE  0E00     MOVLW 0x0
50B0  6E35     MOVWF 0x35, ACCESS
50B2  0E00     MOVLW 0x0
50B4  6E36     MOVWF 0x36, ACCESS
217:                           // no negative 0 for now
218:                           if (bexp == 0) {
4BBA  510E     MOVF 0xE, W, BANKED
4BBC  A4D8     BTFSS 0xFD8, 2, ACCESS
4BBE  EFE3     GOTO 0x4BC6
4BC0  F025     NOP
4BC2  EFE5     GOTO 0x4BCA
4BC4  F025     NOP
4BC6  EFE7     GOTO 0x4BCE
4BC8  F025     NOP
50B6  5041     MOVF NVMCON1, W, ACCESS
50B8  A4D8     BTFSS 0xFD8, 2, ACCESS
50BA  EF61     GOTO 0x50C2
50BC  F028     NOP
50BE  EF63     GOTO 0x50C6
50C0  F028     NOP
50C2  EF65     GOTO 0x50CA
50C4  F028     NOP
219:           		        signs=0;
4BCA  0E00     MOVLW 0x0
4BCC  6F0C     MOVWF 0xC, BANKED
50C6  0E00     MOVLW 0x0
50C8  6E3F     MOVWF 0x3F, ACCESS
220:                           }
221:           	}
222:           
223:           	/* Pack and return result */
224:           	// set the low bit of the exponent ...
225:           	if (bexp & 0x1) {
4BCE  A10E     BTFSS 0xE, 0, BANKED
4BD0  EFEC     GOTO 0x4BD8
4BD2  F025     NOP
4BD4  EFEE     GOTO 0x4BDC
4BD6  F025     NOP
4BD8  EFF1     GOTO 0x4BE2
4BDA  F025     NOP
50CA  A041     BTFSS NVMCON1, 0, ACCESS
50CC  EF6A     GOTO 0x50D4
50CE  F028     NOP
50D0  EF6C     GOTO 0x50D8
50D2  F028     NOP
50D4  EF6F     GOTO 0x50DE
50D6  F028     NOP
226:           		B_FRACTION.fAsBytes.c |= 0x80;
4BDC  8F02     BSF 0x2, 7, BANKED
50D8  8E35     BSF 0x35, 7, ACCESS
227:           	}
4BDE  EFF2     GOTO 0x4BE4
4BE0  F025     NOP
50DA  EF70     GOTO 0x50E0
50DC  F028     NOP
228:           	// AND out the leading 1
229:           	else {
230:           		B_FRACTION.fAsBytes.c &= 0x7F;
4BE2  9F02     BCF 0x2, 7, BANKED
50DE  9E35     BCF 0x35, 7, ACCESS
231:           	}
232:           	B_FRACTION.fAsBytes.d = bexp >> 1;
4BE4  90D8     BCF 0xFD8, 0, ACCESS
4BE6  310E     RRCF 0xE, W, BANKED
4BE8  6F03     MOVWF 0x3, BANKED
50E0  90D8     BCF 0xFD8, 0, ACCESS
50E2  3041     RRCF NVMCON1, W, ACCESS
50E4  6E36     MOVWF 0x36, ACCESS
233:           	if (signs & 0x80) {
4BEA  AF0C     BTFSS 0xC, 7, BANKED
4BEC  EFFA     GOTO 0x4BF4
4BEE  F025     NOP
4BF0  EFFC     GOTO 0x4BF8
4BF2  F025     NOP
4BF4  EFFD     GOTO 0x4BFA
4BF6  F025     NOP
50E6  AE3F     BTFSS 0x3F, 7, ACCESS
50E8  EF78     GOTO 0x50F0
50EA  F028     NOP
50EC  EF7A     GOTO 0x50F4
50EE  F028     NOP
50F0  EF7B     GOTO 0x50F6
50F2  F028     NOP
234:           		B_FRACTION.fAsBytes.d |= 0x80;
4BF8  8F03     BSF 0x3, 7, BANKED
50F4  8E36     BSF 0x36, 7, ACCESS
235:           	}
236:           	return b;
4BFC  F800     NOP
4BFE  F600     NOP
4C02  F804     NOP
4C04  F601     NOP
4C08  F808     NOP
4C0A  F602     NOP
4C0E  F80C     NOP
4C10  F603     NOP
50F8  F4CC     NOP
50FA  F533     NOP
50FE  F4D0     NOP
5100  F534     NOP
5104  F4D4     NOP
5106  F535     NOP
510A  F4D8     NOP
510C  F536     NOP
237:           }
4C12  0012     RETURN 0
510E  0012     RETURN 0
238:           
239:           /* SP Subtract */
240:           #ifdef __PICC__
241:           SP
242:           SPSUB(SP a, SP b)
243:           #else
244:           SP
245:           SPSUB(SP b, SP a)
246:           #endif
247:           {
248:           	(*(SFP *) & a).i ^= 0x80000000; 
8068  0E00     MOVLW 0x0
806A  0106     MOVLB 0x6
806C  1B1D     XORWF 0x1D, F, BANKED
806E  0E00     MOVLW 0x0
8070  1B1E     XORWF 0x1E, F, BANKED
8072  0E00     MOVLW 0x0
8074  1B1F     XORWF 0x1F, F, BANKED
8076  0E80     MOVLW 0x80
8078  1B20     XORWF 0x20, F, BANKED
8126  0E00     MOVLW 0x0
249:           	return __fladd(b, a);
807C  F864     NOP
807E  F600     NOP
8082  F868     NOP
8084  F601     NOP
8088  F86C     NOP
808A  F602     NOP
808E  F870     NOP
8090  F603     NOP
8094  F874     NOP
8096  F604     NOP
809A  F878     NOP
809C  F605     NOP
80A0  F87C     NOP
80A2  F606     NOP
80A6  F880     NOP
80A8  F607     NOP
80AA  EC8B     CALL 0x4716, 0
80AC  F023     NOP
80B0  F800     NOP
80B2  F619     NOP
80B6  F804     NOP
80B8  F61A     NOP
80BC  F808     NOP
80BE  F61B     NOP
80C2  F80C     NOP
80C4  F61C     NOP
8138  F50C     NOP
813A  F533     NOP
813E  F510     NOP
8140  F534     NOP
8144  F514     NOP
8146  F535     NOP
814A  F518     NOP
814C  F536     NOP
8150  F51C     NOP
8152  F537     NOP
8156  F520     NOP
8158  F538     NOP
815C  F524     NOP
815E  F539     NOP
8162  F528     NOP
8164  F53A     NOP
8166  EC0A     CALL 0x4C14, 0
8168  F026     NOP
816C  F4CC     NOP
816E  F543     NOP
8172  F4D0     NOP
8174  F544     NOP
8178  F4D4     NOP
817A  F545     NOP
817E  F4D8     NOP
8180  F546     NOP
250:           }
80C6  0012     RETURN 0
8182  0012     RETURN 0
251:           
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/printf.c  ------------------------
1:             #include <stdio.h>
2:             #include <stdarg.h>
3:             #include "stdio_impl.h"
4:             
5:             int printf(const char *restrict fmt, ...)
6:             {
7:             	int ret;
8:             	va_list ap;
9:             	va_start(ap, fmt);
856A  0E9B     MOVLW 0x9B
856C  0106     MOVLB 0x6
856E  6FA3     MOVWF 0xA3, BANKED
8570  0E06     MOVLW 0x6
8572  6FA4     MOVWF 0xA4, BANKED
10:            	ret = vfprintf(stdout, fmt, ap);
8574  0E00     MOVLW 0x0
8576  6F91     MOVWF SPI2CON0, BANKED
8578  0E00     MOVLW 0x0
857A  6F92     MOVWF SPI2CON1, BANKED
857E  FA64     NOP
8580  F693     NOP
8584  FA68     NOP
8586  F694     NOP
8588  0EA3     MOVLW 0xA3
858A  6F95     MOVWF SPI2TWIDTH, BANKED
858C  0E06     MOVLW 0x6
858E  6F96     MOVWF SPI2BAUD, BANKED
8590  EC4F     CALL 0x7E9E, 0
8592  F03F     NOP
11:            	va_end(ap);
12:            	return ret;
13:            }
8594  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/nf_fputs.c  ----------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
81DE  0E00     MOVLW 0x0
81E0  0106     MOVLB 0x6
81E2  6F11     MOVWF 0x11, BANKED
81E4  0E00     MOVLW 0x0
81E6  6F10     MOVWF 0x10, BANKED
14:                while ((c = *(s + i))) {
81E8  EF05     GOTO 0x820A
81EA  F041     NOP
820A  5110     MOVF 0x10, W, BANKED
820C  250B     ADDWF 0xB, W, BANKED
820E  6ED9     MOVWF 0xFD9, ACCESS
8210  5111     MOVF 0x11, W, BANKED
8212  210C     ADDWFC 0xC, W, BANKED
8214  6EDA     MOVWF 0xFDA, ACCESS
8216  50DF     MOVF 0xFDF, W, ACCESS
8218  6F0F     MOVWF 0xF, BANKED
821A  510F     MOVF 0xF, W, BANKED
821C  A4D8     BTFSS 0xFD8, 2, ACCESS
821E  EF13     GOTO 0x8226
8220  F041     NOP
8222  EF15     GOTO 0x822A
8224  F041     NOP
8226  EFF6     GOTO 0x81EC
8228  F040     NOP
15:            	fputc(c,fp);
81EE  F83C     NOP
81F0  F602     NOP
81F2  6B03     CLRF 0x3, BANKED
81F6  F834     NOP
81F8  F604     NOP
81FC  F838     NOP
81FE  F605     NOP
8200  EC5F     CALL 0x7ABE, 0
8202  F03D     NOP
16:                    ++i;
8204  0106     MOVLB 0x6
8206  4B10     INFSNZ 0x10, F, BANKED
8208  2B11     INCF 0x11, F, BANKED
17:                }
18:                return i;
19:            }
822A  0012     RETURN 0
20:            
21:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/nf_fputc.c  ----------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
7ABE  0106     MOVLB 0x6
7AC0  5104     MOVF 0x4, W, BANKED
7AC2  1105     IORWF 0x5, W, BANKED
7AC4  B4D8     BTFSC 0xFD8, 2, ACCESS
7AC6  EF67     GOTO 0x7ACE
7AC8  F03D     NOP
7ACA  EF69     GOTO 0x7AD2
7ACC  F03D     NOP
7ACE  EF72     GOTO 0x7AE4
7AD0  F03D     NOP
7AD2  5104     MOVF 0x4, W, BANKED
7AD4  1105     IORWF 0x5, W, BANKED
7AD6  A4D8     BTFSS 0xFD8, 2, ACCESS
7AD8  EF70     GOTO 0x7AE0
7ADA  F03D     NOP
7ADC  EF72     GOTO 0x7AE4
7ADE  F03D     NOP
7AE0  EF77     GOTO 0x7AEE
7AE2  F03D     NOP
13:                    putch(c);
7AE4  5102     MOVF 0x2, W, BANKED
7AE6  EC50     CALL 0x86A0, 0
7AE8  F043     NOP
14:                } else {
7AEA  EFAA     GOTO 0x7B54
7AEC  F03D     NOP
15:            	if((fp->limit == 0) || (fp->count < fp->limit)) {
7AEE  EE20     LFSR 2, 0x4
7AF0  F004     NOP
7AF2  5104     MOVF 0x4, W, BANKED
7AF4  26D9     ADDWF 0xFD9, F, ACCESS
7AF6  5105     MOVF 0x5, W, BANKED
7AF8  22DA     ADDWFC 0xFDA, F, ACCESS
7AFA  50DE     MOVF 0xFDE, W, ACCESS
7AFC  10DE     IORWF 0xFDE, W, ACCESS
7AFE  B4D8     BTFSC 0xFD8, 2, ACCESS
7B00  EF84     GOTO 0x7B08
7B02  F03D     NOP
7B04  EF86     GOTO 0x7B0C
7B06  F03D     NOP
7B08  EFA1     GOTO 0x7B42
7B0A  F03D     NOP
7B0C  EE20     LFSR 2, 0x4
7B0E  F004     NOP
7B10  5104     MOVF 0x4, W, BANKED
7B12  26D9     ADDWF 0xFD9, F, ACCESS
7B14  5105     MOVF 0x5, W, BANKED
7B16  22DA     ADDWFC 0xFDA, F, ACCESS
7B18  EE10     LFSR 1, 0x2
7B1A  F002     NOP
7B1C  5104     MOVF 0x4, W, BANKED
7B1E  26E1     ADDWF 0xFE1, F, ACCESS
7B20  5105     MOVF 0x5, W, BANKED
7B22  22E2     ADDWFC 0xFE2, F, ACCESS
7B24  50DE     MOVF 0xFDE, W, ACCESS
7B26  5CE6     SUBWF 0xFE6, W, ACCESS
7B28  50E6     MOVF 0xFE6, W, ACCESS
7B2A  0A80     XORLW 0x80
7B2C  6F0A     MOVWF 0xA, BANKED
7B2E  50DE     MOVF 0xFDE, W, ACCESS
7B30  0A80     XORLW 0x80
7B32  590A     SUBWFB 0xA, W, BANKED
7B34  B0D8     BTFSC 0xFD8, 0, ACCESS
7B36  EF9F     GOTO 0x7B3E
7B38  F03D     NOP
7B3A  EFA1     GOTO 0x7B42
7B3C  F03D     NOP
7B3E  EFAA     GOTO 0x7B54
7B40  F03D     NOP
16:            	        fp->buffer[fp->count] = (char)c;
17:            		++fp->count;
7B42  EE20     LFSR 2, 0x2
7B44  F002     NOP
7B46  5104     MOVF 0x4, W, BANKED
7B48  26D9     ADDWF 0xFD9, F, ACCESS
7B4A  5105     MOVF 0x5, W, BANKED
7B4C  22DA     ADDWFC 0xFDA, F, ACCESS
7B4E  2ADE     INCF 0xFDE, F, ACCESS
7B50  0E00     MOVLW 0x0
7B52  22DD     ADDWFC 0xFDD, F, ACCESS
18:            	}
19:                }
20:                return (unsigned char)c;
21:            }
7B54  0012     RETURN 0
22:            
23:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/log10f.c  ------------------------
1:             /* origin: FreeBSD /usr/src/lib/msun/src/e_log10f.c */
2:             /*
3:              * ====================================================
4:              * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
5:              *
6:              * Developed at SunPro, a Sun Microsystems, Inc. business.
7:              * Permission to use, copy, modify, and distribute this
8:              * software is freely granted, provided that this notice
9:              * is preserved.
10:             * ====================================================
11:             */
12:            /*
13:             * See comments in log10.c.
14:             */
15:            
16:            #include <math.h>
17:            #include <stdint.h>
18:            
19:            static const float
20:            ivln10hi  =  4.3432617188e-01, /* 0x3ede6000 */
3DBC  0E00     MOVLW 0x0
3DBE  6E05     MOVWF 0x5, ACCESS
3DC0  0E60     MOVLW 0x60
3DC2  6E06     MOVWF 0x6, ACCESS
3DC4  0EDE     MOVLW 0xDE
3DC6  6E07     MOVWF 0x7, ACCESS
3DC8  0E3E     MOVLW 0x3E
3DCA  6E08     MOVWF 0x8, ACCESS
3DCE  F618     NOP
3DD0  F501     NOP
3DD4  F61C     NOP
3DD6  F502     NOP
3DDA  F620     NOP
3DDC  F503     NOP
3DE0  F624     NOP
3DE2  F504     NOP
3DE4  ECCE     CALL 0x559C, 0
3DE6  F02A     NOP
3DEA  F404     NOP
3DEC  F537     NOP
3DF0  F408     NOP
3DF2  F538     NOP
3DF6  F40C     NOP
3DF8  F539     NOP
3DFC  F410     NOP
3DFE  F53A     NOP
3E02  F5E0     NOP
3E04  F533     NOP
3E08  F5E4     NOP
3E0A  F534     NOP
3E0E  F5E8     NOP
3E10  F535     NOP
3E14  F5EC     NOP
3E16  F536     NOP
3E18  EC0A     CALL 0x4C14, 0
3E1A  F026     NOP
3E1E  F4CC     NOP
3E20  F58A     NOP
3E24  F4D0     NOP
3E26  F58B     NOP
3E2A  F4D4     NOP
3E2C  F58C     NOP
3E30  F4D8     NOP
3E32  F58D     NOP
3E34  0E00     MOVLW 0x0
3E36  6E05     MOVWF 0x5, ACCESS
3E38  0E60     MOVLW 0x60
3E3A  6E06     MOVWF 0x6, ACCESS
3E3C  0EDE     MOVLW 0xDE
3E3E  6E07     MOVWF 0x7, ACCESS
3E40  0E3E     MOVLW 0x3E
3E42  6E08     MOVWF 0x8, ACCESS
3E46  F688     NOP
3E48  F501     NOP
3E4C  F68C     NOP
3E4E  F502     NOP
3E52  F690     NOP
3E54  F503     NOP
3E58  F694     NOP
3E5A  F504     NOP
3E5C  ECCE     CALL 0x559C, 0
3E5E  F02A     NOP
3E62  F404     NOP
3E64  F537     NOP
3E68  F408     NOP
3E6A  F538     NOP
3E6E  F40C     NOP
3E70  F539     NOP
3E74  F410     NOP
3E76  F53A     NOP
3E7A  F628     NOP
3E7C  F533     NOP
3E80  F62C     NOP
3E82  F534     NOP
3E86  F630     NOP
3E88  F535     NOP
3E8C  F634     NOP
3E8E  F536     NOP
3E90  EC0A     CALL 0x4C14, 0
3E92  F026     NOP
3E96  F4CC     NOP
3E98  F57C     NOP
3E9C  F4D0     NOP
3E9E  F57D     NOP
3EA2  F4D4     NOP
3EA4  F57E     NOP
3EA8  F4D8     NOP
3EAA  F57F     NOP
21:            ivln10lo  = -3.1689971365e-05, /* 0xb804ead9 */
3CCC  0ED9     MOVLW 0xD9
3CCE  6E05     MOVWF 0x5, ACCESS
3CD0  0EEA     MOVLW 0xEA
3CD2  6E06     MOVWF 0x6, ACCESS
3CD4  0E04     MOVLW 0x4
3CD6  6E07     MOVWF 0x7, ACCESS
3CD8  0EB8     MOVLW 0xB8
3CDA  6E08     MOVWF 0x8, ACCESS
3CDE  F688     NOP
3CE0  F537     NOP
3CE4  F68C     NOP
3CE6  F538     NOP
3CEA  F690     NOP
3CEC  F539     NOP
3CF0  F694     NOP
3CF2  F53A     NOP
3CF6  F618     NOP
3CF8  F533     NOP
3CFC  F61C     NOP
3CFE  F534     NOP
3D02  F620     NOP
3D04  F535     NOP
3D08  F624     NOP
3D0A  F536     NOP
3D0C  EC0A     CALL 0x4C14, 0
3D0E  F026     NOP
3D12  F4CC     NOP
3D14  F501     NOP
3D18  F4D0     NOP
3D1A  F502     NOP
3D1E  F4D4     NOP
3D20  F503     NOP
3D24  F4D8     NOP
3D26  F504     NOP
3D28  ECCE     CALL 0x559C, 0
3D2A  F02A     NOP
3D2E  F404     NOP
3D30  F574     NOP
3D34  F408     NOP
3D36  F575     NOP
3D3A  F40C     NOP
3D3C  F576     NOP
3D40  F410     NOP
3D42  F577     NOP
3D46  F5D0     NOP
3D48  F537     NOP
3D4C  F5D4     NOP
3D4E  F538     NOP
3D52  F5D8     NOP
3D54  F539     NOP
3D58  F5DC     NOP
3D5A  F53A     NOP
3D5C  0EDB     MOVLW 0xDB
3D5E  6E05     MOVWF 0x5, ACCESS
3D60  0E27     MOVLW 0x27
3D62  6E06     MOVWF 0x6, ACCESS
3D64  0E54     MOVLW 0x54
3D66  6E07     MOVWF 0x7, ACCESS
3D68  0E35     MOVLW 0x35
3D6A  6E08     MOVWF 0x8, ACCESS
3D6E  F608     NOP
3D70  F501     NOP
3D74  F60C     NOP
3D76  F502     NOP
3D7A  F610     NOP
3D7C  F503     NOP
3D80  F614     NOP
3D82  F504     NOP
3D84  ECCE     CALL 0x559C, 0
3D86  F02A     NOP
3D8A  F404     NOP
3D8C  F533     NOP
3D90  F408     NOP
3D92  F534     NOP
3D96  F40C     NOP
3D98  F535     NOP
3D9C  F410     NOP
3D9E  F536     NOP
3DA0  EC0A     CALL 0x4C14, 0
3DA2  F026     NOP
3DA6  F4CC     NOP
3DA8  F578     NOP
3DAC  F4D0     NOP
3DAE  F579     NOP
3DB2  F4D4     NOP
3DB4  F57A     NOP
3DB8  F4D8     NOP
3DBA  F57B     NOP
22:            log10_2hi =  3.0102920532e-01, /* 0x3e9a2080 */
3EAE  F5F0     NOP
3EB0  F533     NOP
3EB4  F5F4     NOP
3EB6  F534     NOP
3EBA  F5F8     NOP
3EBC  F535     NOP
3EC0  F5FC     NOP
3EC2  F536     NOP
3EC4  0E80     MOVLW 0x80
3EC6  6E05     MOVWF 0x5, ACCESS
3EC8  0E20     MOVLW 0x20
3ECA  6E06     MOVWF 0x6, ACCESS
3ECC  0E9A     MOVLW 0x9A
3ECE  6E07     MOVWF 0x7, ACCESS
3ED0  0E3E     MOVLW 0x3E
3ED2  6E08     MOVWF 0x8, ACCESS
3ED6  F608     NOP
3ED8  F501     NOP
3EDC  F60C     NOP
3EDE  F502     NOP
3EE2  F610     NOP
3EE4  F503     NOP
3EE8  F614     NOP
3EEA  F504     NOP
3EEC  ECCE     CALL 0x559C, 0
3EEE  F02A     NOP
3EF2  F404     NOP
3EF4  F537     NOP
3EF8  F408     NOP
3EFA  F538     NOP
3EFE  F40C     NOP
3F00  F539     NOP
3F04  F410     NOP
3F06  F53A     NOP
3F08  EC0A     CALL 0x4C14, 0
3F0A  F026     NOP
3F0E  F4CC     NOP
3F10  F54B     NOP
3F14  F4D0     NOP
3F16  F54C     NOP
3F1A  F4D4     NOP
3F1C  F54D     NOP
3F20  F4D8     NOP
3F22  F54E     NOP
23:            log10_2lo =  7.9034151668e-07, /* 0x355427db */
24:            /* |(log(1+s)-log(1-s))/s - Lg(s)| < 2**-34.24 (~[-4.95e-11, 4.97e-11]). */
25:            Lg1 = 0xaaaaaa.0p-24, /* 0.66666662693 */
390E  0EAA     MOVLW 0xAA
3910  6E37     MOVWF 0x37, ACCESS
3912  0EAA     MOVLW 0xAA
3914  6E38     MOVWF 0x38, ACCESS
3916  0E2A     MOVLW 0x2A
3918  6E39     MOVWF CLKRCON, ACCESS
391A  0E3F     MOVLW 0x3F
391C  6E3A     MOVWF CLKRCLK, ACCESS
391E  0EEE     MOVLW 0xEE
3920  6E05     MOVWF 0x5, ACCESS
3922  0EE9     MOVLW 0xE9
3924  6E06     MOVWF 0x6, ACCESS
3926  0E91     MOVLW 0x91
3928  6E07     MOVWF 0x7, ACCESS
392A  0E3E     MOVLW 0x3E
392C  6E08     MOVWF 0x8, ACCESS
3930  F668     NOP
3932  F501     NOP
3936  F66C     NOP
3938  F502     NOP
393C  F670     NOP
393E  F503     NOP
3942  F674     NOP
3944  F504     NOP
3946  ECCE     CALL 0x559C, 0
3948  F02A     NOP
394C  F404     NOP
394E  F533     NOP
3952  F408     NOP
3954  F534     NOP
3958  F40C     NOP
395A  F535     NOP
395E  F410     NOP
3960  F536     NOP
3962  EC0A     CALL 0x4C14, 0
3964  F026     NOP
3968  F4CC     NOP
396A  F59E     NOP
396E  F4D0     NOP
3970  F59F     NOP
3974  F4D4     NOP
3976  F5A0     NOP
397A  F4D8     NOP
397C  F5A1     NOP
26:            Lg2 = 0xccce13.0p-25, /* 0.40000972152 */
3852  0E13     MOVLW 0x13
3854  6E37     MOVWF 0x37, ACCESS
3856  0ECE     MOVLW 0xCE
3858  6E38     MOVWF 0x38, ACCESS
385A  0ECC     MOVLW 0xCC
385C  6E39     MOVWF CLKRCON, ACCESS
385E  0E3E     MOVLW 0x3E
3860  6E3A     MOVWF CLKRCLK, ACCESS
3862  0E26     MOVLW 0x26
3864  6E05     MOVWF 0x5, ACCESS
3866  0E9E     MOVLW 0x9E
3868  6E06     MOVWF 0x6, ACCESS
386A  0E78     MOVLW 0x78
386C  6E07     MOVWF 0x7, ACCESS
386E  0E3E     MOVLW 0x3E
3870  6E08     MOVWF 0x8, ACCESS
3874  F668     NOP
3876  F501     NOP
387A  F66C     NOP
387C  F502     NOP
3880  F670     NOP
3882  F503     NOP
3886  F674     NOP
3888  F504     NOP
388A  ECCE     CALL 0x559C, 0
388C  F02A     NOP
3890  F404     NOP
3892  F533     NOP
3896  F408     NOP
3898  F534     NOP
389C  F40C     NOP
389E  F535     NOP
38A2  F410     NOP
38A4  F536     NOP
38A6  EC0A     CALL 0x4C14, 0
38A8  F026     NOP
38AC  F4CC     NOP
38AE  F59E     NOP
38B2  F4D0     NOP
38B4  F59F     NOP
38B8  F4D4     NOP
38BA  F5A0     NOP
38BE  F4D8     NOP
38C0  F5A1     NOP
27:            Lg3 = 0x91e9ee.0p-25, /* 0.28498786688 */
28:            Lg4 = 0xf89e26.0p-26; /* 0.24279078841 */
29:            
30:            float log10f(float x)
31:            {
32:            	union {float f; uint32_t i;} u = {x};
3356  F6C8     NOP
3358  F5A6     NOP
335C  F6CC     NOP
335E  F5A7     NOP
3362  F6D0     NOP
3364  F5A8     NOP
3368  F6D4     NOP
336A  F5A9     NOP
336E  F52C     NOP
3370  F5A6     NOP
3374  F530     NOP
3376  F5A7     NOP
337A  F534     NOP
337C  F5A8     NOP
3380  F538     NOP
3382  F5A9     NOP
33:            	float_t hfsq,f,s,z,R,w,t1,t2,dk,hi,lo;
34:            	uint32_t ix;
35:            	int k;
36:            
37:            	ix = u.i;
3386  F698     NOP
3388  F5AE     NOP
338C  F69C     NOP
338E  F5AF     NOP
3392  F6A0     NOP
3394  F5B0     NOP
3398  F6A4     NOP
339A  F5B1     NOP
38:            	k = 0;
339C  0E00     MOVLW 0x0
339E  0105     MOVLB 0x5
33A0  6F81     MOVWF SPI1TXB, BANKED
33A2  0E00     MOVLW 0x0
33A4  6F80     MOVWF SPI1RXB, BANKED
39:            	if (ix < 0x00800000 || ix>>31) {  /* x < 2**-126  */
33A6  51B1     MOVF OSCFRQ, W, BANKED
33A8  E109     BNZ 0x33BC
33AA  0E80     MOVLW 0x80
33AC  5DB0     SUBWF OSCTUNE, W, BANKED
33AE  A0D8     BTFSS 0xFD8, 0, ACCESS
33B0  EFDC     GOTO 0x33B8
33B2  F019     NOP
33B4  EFDE     GOTO 0x33BC
33B6  F019     NOP
33B8  EF00     GOTO 0x3400
33BA  F01A     NOP
33BE  F6B8     NOP
33C0  F54F     NOP
33C4  F6BC     NOP
33C6  F550     NOP
33CA  F6C0     NOP
33CC  F551     NOP
33D0  F6C4     NOP
33D2  F552     NOP
33D4  0E20     MOVLW 0x20
33D6  EFF2     GOTO 0x33E4
33D8  F019     NOP
33DA  90D8     BCF 0xFD8, 0, ACCESS
33DC  3252     RRCF 0x52, F, ACCESS
33DE  3251     RRCF 0x51, F, ACCESS
33E0  3250     RRCF 0x50, F, ACCESS
33E2  324F     RRCF 0x4F, F, ACCESS
33E4  2EE8     DECFSZ 0xFE8, F, ACCESS
33E6  EFED     GOTO 0x33DA
33E8  F019     NOP
33EA  504F     MOVF 0x4F, W, ACCESS
33EC  1050     IORWF 0x50, W, ACCESS
33EE  1051     IORWF 0x51, W, ACCESS
33F0  1052     IORWF 0x52, W, ACCESS
33F2  B4D8     BTFSC 0xFD8, 2, ACCESS
33F4  EFFE     GOTO 0x33FC
33F6  F019     NOP
33F8  EF00     GOTO 0x3400
33FA  F01A     NOP
33FC  EFF2     GOTO 0x35E4
33FE  F01A     NOP
40:            		if (ix<<1 == 0)
3400  90D8     BCF 0xFD8, 0, ACCESS
3402  35AE     RLCF OSCCON2, W, BANKED
3404  6E4F     MOVWF 0x4F, ACCESS
3406  35AF     RLCF OSCCON3, W, BANKED
3408  6E50     MOVWF 0x50, ACCESS
340A  35B0     RLCF OSCTUNE, W, BANKED
340C  6E51     MOVWF 0x51, ACCESS
340E  35B1     RLCF OSCFRQ, W, BANKED
3410  6E52     MOVWF 0x52, ACCESS
3412  504F     MOVF 0x4F, W, ACCESS
3414  1050     IORWF 0x50, W, ACCESS
3416  1051     IORWF 0x51, W, ACCESS
3418  1052     IORWF 0x52, W, ACCESS
341A  A4D8     BTFSS 0xFD8, 2, ACCESS
341C  EF12     GOTO 0x3424
341E  F01A     NOP
3420  EF14     GOTO 0x3428
3422  F01A     NOP
3424  EF52     GOTO 0x34A4
3426  F01A     NOP
41:            			return -1/(x*x);  /* log(+-0)=-inf */
3428  0E00     MOVLW 0x0
342A  6E1A     MOVWF 0x1A, ACCESS
342C  0E00     MOVLW 0x0
342E  6E1B     MOVWF 0x1B, ACCESS
3430  0E80     MOVLW 0x80
3432  6E1C     MOVWF 0x1C, ACCESS
3434  0EBF     MOVLW 0xBF
3436  6E1D     MOVWF 0x1D, ACCESS
343A  F52C     NOP
343C  F505     NOP
3440  F530     NOP
3442  F506     NOP
3446  F534     NOP
3448  F507     NOP
344C  F538     NOP
344E  F508     NOP
3452  F52C     NOP
3454  F501     NOP
3458  F530     NOP
345A  F502     NOP
345E  F534     NOP
3460  F503     NOP
3464  F538     NOP
3466  F504     NOP
3468  ECCE     CALL 0x559C, 0
346A  F02A     NOP
346E  F404     NOP
3470  F51E     NOP
3474  F408     NOP
3476  F51F     NOP
347A  F40C     NOP
347C  F520     NOP
3480  F410     NOP
3482  F521     NOP
3484  ECF3     CALL 0x5DE6, 0
3486  F02E     NOP
348A  F468     NOP
348C  F54B     NOP
3490  F46C     NOP
3492  F54C     NOP
3496  F470     NOP
3498  F54D     NOP
349C  F474     NOP
349E  F54E     NOP
34A0  EF92     GOTO 0x3F24
34A2  F01F     NOP
42:            		if (ix>>31)
34A6  F6B8     NOP
34A8  F54F     NOP
34AC  F6BC     NOP
34AE  F550     NOP
34B2  F6C0     NOP
34B4  F551     NOP
34B8  F6C4     NOP
34BA  F552     NOP
34BC  0E20     MOVLW 0x20
34BE  EF66     GOTO 0x34CC
34C0  F01A     NOP
34C2  90D8     BCF 0xFD8, 0, ACCESS
34C4  3252     RRCF 0x52, F, ACCESS
34C6  3251     RRCF 0x51, F, ACCESS
34C8  3250     RRCF 0x50, F, ACCESS
34CA  324F     RRCF 0x4F, F, ACCESS
34CC  2EE8     DECFSZ 0xFE8, F, ACCESS
34CE  EF61     GOTO 0x34C2
34D0  F01A     NOP
34D2  504F     MOVF 0x4F, W, ACCESS
34D4  1050     IORWF 0x50, W, ACCESS
34D6  1051     IORWF 0x51, W, ACCESS
34D8  1052     IORWF 0x52, W, ACCESS
34DA  B4D8     BTFSC 0xFD8, 2, ACCESS
34DC  EF72     GOTO 0x34E4
34DE  F01A     NOP
34E0  EF74     GOTO 0x34E8
34E2  F01A     NOP
34E4  EFB2     GOTO 0x3564
34E6  F01A     NOP
43:            			return (x-x)/0.0f; /* log(-#) = NaN */
34EA  F52C     NOP
34EC  F547     NOP
34F0  F530     NOP
34F2  F548     NOP
34F6  F534     NOP
34F8  F549     NOP
34FC  F538     NOP
34FE  F54A     NOP
3502  F52C     NOP
3504  F543     NOP
3508  F530     NOP
350A  F544     NOP
350E  F534     NOP
3510  F545     NOP
3514  F538     NOP
3516  F546     NOP
3518  EC93     CALL 0x8126, 0
351A  F040     NOP
351E  F50C     NOP
3520  F51A     NOP
3524  F510     NOP
3526  F51B     NOP
352A  F514     NOP
352C  F51C     NOP
3530  F518     NOP
3532  F51D     NOP
3534  0E00     MOVLW 0x0
3536  6E1E     MOVWF 0x1E, ACCESS
3538  0E00     MOVLW 0x0
353A  6E1F     MOVWF 0x1F, ACCESS
353C  0E00     MOVLW 0x0
353E  6E20     MOVWF 0x20, ACCESS
3540  0E00     MOVLW 0x0
3542  6E21     MOVWF 0x21, ACCESS
3544  ECF3     CALL 0x5DE6, 0
3546  F02E     NOP
354A  F468     NOP
354C  F54B     NOP
3550  F46C     NOP
3552  F54C     NOP
3556  F470     NOP
3558  F54D     NOP
355C  F474     NOP
355E  F54E     NOP
3560  EF92     GOTO 0x3F24
3562  F01F     NOP
44:            		/* subnormal number, scale up x */
45:            		k -= 25;
3564  0EE7     MOVLW 0xE7
3566  2780     ADDWF SPI1RXB, F, BANKED
3568  0EFF     MOVLW 0xFF
356A  2381     ADDWFC SPI1TXB, F, BANKED
46:            		x *= 0x1p25f;
356E  F52C     NOP
3570  F501     NOP
3574  F530     NOP
3576  F502     NOP
357A  F534     NOP
357C  F503     NOP
3580  F538     NOP
3582  F504     NOP
3584  0E00     MOVLW 0x0
3586  6E05     MOVWF 0x5, ACCESS
3588  0E00     MOVLW 0x0
358A  6E06     MOVWF 0x6, ACCESS
358C  0E00     MOVLW 0x0
358E  6E07     MOVWF 0x7, ACCESS
3590  0E4C     MOVLW 0x4C
3592  6E08     MOVWF 0x8, ACCESS
3594  ECCE     CALL 0x559C, 0
3596  F02A     NOP
359A  F404     NOP
359C  F54B     NOP
35A0  F408     NOP
35A2  F54C     NOP
35A6  F40C     NOP
35A8  F54D     NOP
35AC  F410     NOP
35AE  F54E     NOP
47:            		u.f = x;
35B2  F52C     NOP
35B4  F5A6     NOP
35B8  F530     NOP
35BA  F5A7     NOP
35BE  F534     NOP
35C0  F5A8     NOP
35C4  F538     NOP
35C6  F5A9     NOP
48:            		ix = u.i;
35CA  F698     NOP
35CC  F5AE     NOP
35D0  F69C     NOP
35D2  F5AF     NOP
35D6  F6A0     NOP
35D8  F5B0     NOP
35DC  F6A4     NOP
35DE  F5B1     NOP
49:            	} else if (ix >= 0x7f800000) {
35E0  EF23     GOTO 0x3646
35E2  F01B     NOP
35E4  0E80     MOVLW 0x80
35E6  5DB0     SUBWF OSCTUNE, W, BANKED
35E8  0E7F     MOVLW 0x7F
35EA  59B1     SUBWFB OSCFRQ, W, BANKED
35EC  A0D8     BTFSS 0xFD8, 0, ACCESS
35EE  EFFB     GOTO 0x35F6
35F0  F01A     NOP
35F2  EFFD     GOTO 0x35FA
35F4  F01A     NOP
35F6  EF0B     GOTO 0x3616
35F8  F01B     NOP
50:            		return x;
35FC  F52C     NOP
35FE  F54B     NOP
3602  F530     NOP
3604  F54C     NOP
3608  F534     NOP
360A  F54D     NOP
360E  F538     NOP
3610  F54E     NOP
3612  EF92     GOTO 0x3F24
3614  F01F     NOP
51:            	} else if (ix == 0x3f800000)
3616  0E80     MOVLW 0x80
3618  19B0     XORWF OSCTUNE, W, BANKED
361A  E109     BNZ 0x362E
361C  0E3F     MOVLW 0x3F
361E  19B1     XORWF OSCFRQ, W, BANKED
3620  11AE     IORWF OSCCON2, W, BANKED
3622  11AF     IORWF OSCCON3, W, BANKED
3624  A4D8     BTFSS 0xFD8, 2, ACCESS
3626  EF17     GOTO 0x362E
3628  F01B     NOP
362A  EF19     GOTO 0x3632
362C  F01B     NOP
362E  EF23     GOTO 0x3646
3630  F01B     NOP
52:            		return 0;
3632  0E00     MOVLW 0x0
3634  6E4B     MOVWF HLVDCON1, ACCESS
3636  0E00     MOVLW 0x0
3638  6E4C     MOVWF ZCDCON, ACCESS
363A  0E00     MOVLW 0x0
363C  6E4D     MOVWF 0x4D, ACCESS
363E  0E00     MOVLW 0x0
3640  6E4E     MOVWF 0x4E, ACCESS
3642  EF92     GOTO 0x3F24
3644  F01F     NOP
53:            
54:            	/* reduce x into [sqrt(2)/2, sqrt(2)] */
55:            	ix += 0x3f800000 - 0x3f3504f3;
3646  0E0D     MOVLW 0xD
3648  0105     MOVLB 0x5
364A  27AE     ADDWF OSCCON2, F, BANKED
364C  0EFB     MOVLW 0xFB
364E  23AF     ADDWFC OSCCON3, F, BANKED
3650  0E4A     MOVLW 0x4A
3652  23B0     ADDWFC OSCTUNE, F, BANKED
3654  0E00     MOVLW 0x0
3656  23B1     ADDWFC OSCFRQ, F, BANKED
56:            	k += (int)(ix>>23) - 0x7f;
3658  0E81     MOVLW 0x81
365A  6E4F     MOVWF 0x4F, ACCESS
365C  0EFF     MOVLW 0xFF
365E  6E50     MOVWF 0x50, ACCESS
3662  F6B8     NOP
3664  F551     NOP
3668  F6BC     NOP
366A  F552     NOP
366E  F6C0     NOP
3670  F553     NOP
3674  F6C4     NOP
3676  F554     NOP
3678  0E18     MOVLW 0x18
367A  EF44     GOTO 0x3688
367C  F01B     NOP
367E  90D8     BCF 0xFD8, 0, ACCESS
3680  3254     RRCF 0x54, F, ACCESS
3682  3253     RRCF 0x53, F, ACCESS
3684  3252     RRCF 0x52, F, ACCESS
3686  3251     RRCF 0x51, F, ACCESS
3688  2EE8     DECFSZ 0xFE8, F, ACCESS
368A  EF3F     GOTO 0x367E
368C  F01B     NOP
368E  504F     MOVF 0x4F, W, ACCESS
3690  2651     ADDWF 0x51, F, ACCESS
3692  5050     MOVF 0x50, W, ACCESS
3694  2252     ADDWFC 0x52, F, ACCESS
3696  5051     MOVF 0x51, W, ACCESS
3698  2780     ADDWF SPI1RXB, F, BANKED
369A  5052     MOVF 0x52, W, ACCESS
369C  2381     ADDWFC SPI1TXB, F, BANKED
57:            	ix = (ix&0x007fffff) + 0x3f3504f3;
369E  0EFF     MOVLW 0xFF
36A0  15AE     ANDWF OSCCON2, W, BANKED
36A2  6E4F     MOVWF 0x4F, ACCESS
36A4  0EFF     MOVLW 0xFF
36A6  15AF     ANDWF OSCCON3, W, BANKED
36A8  6E50     MOVWF 0x50, ACCESS
36AA  0E7F     MOVLW 0x7F
36AC  15B0     ANDWF OSCTUNE, W, BANKED
36AE  6E51     MOVWF 0x51, ACCESS
36B0  0E00     MOVLW 0x0
36B2  15B1     ANDWF OSCFRQ, W, BANKED
36B4  6E52     MOVWF 0x52, ACCESS
36B6  0EF3     MOVLW 0xF3
36B8  244F     ADDWF 0x4F, W, ACCESS
36BA  6FAE     MOVWF OSCCON2, BANKED
36BC  0E04     MOVLW 0x4
36BE  2050     ADDWFC 0x50, W, ACCESS
36C0  6FAF     MOVWF OSCCON3, BANKED
36C2  0E35     MOVLW 0x35
36C4  2051     ADDWFC 0x51, W, ACCESS
36C6  6FB0     MOVWF OSCTUNE, BANKED
36C8  0E3F     MOVLW 0x3F
36CA  2052     ADDWFC 0x52, W, ACCESS
36CC  6FB1     MOVWF OSCFRQ, BANKED
58:            	u.i = ix;
36D0  F6B8     NOP
36D2  F5A6     NOP
36D6  F6BC     NOP
36D8  F5A7     NOP
36DC  F6C0     NOP
36DE  F5A8     NOP
36E2  F6C4     NOP
36E4  F5A9     NOP
59:            	x = u.f;
36E8  F698     NOP
36EA  F54B     NOP
36EE  F69C     NOP
36F0  F54C     NOP
36F4  F6A0     NOP
36F6  F54D     NOP
36FA  F6A4     NOP
36FC  F54E     NOP
60:            
61:            	f = x - 1.0f;
3700  F52C     NOP
3702  F533     NOP
3706  F530     NOP
3708  F534     NOP
370C  F534     NOP
370E  F535     NOP
3712  F538     NOP
3714  F536     NOP
3716  0E00     MOVLW 0x0
3718  6E37     MOVWF 0x37, ACCESS
371A  0E00     MOVLW 0x0
371C  6E38     MOVWF 0x38, ACCESS
371E  0E80     MOVLW 0x80
3720  6E39     MOVWF CLKRCON, ACCESS
3722  0EBF     MOVLW 0xBF
3724  6E3A     MOVWF CLKRCLK, ACCESS
3726  EC0A     CALL 0x4C14, 0
3728  F026     NOP
372C  F4CC     NOP
372E  F5AA     NOP
3732  F4D0     NOP
3734  F5AB     NOP
3738  F4D4     NOP
373A  F5AC     NOP
373E  F4D8     NOP
3740  F5AD     NOP
62:            	s = f/(2.0f + f);
3744  F6A8     NOP
3746  F51A     NOP
374A  F6AC     NOP
374C  F51B     NOP
3750  F6B0     NOP
3752  F51C     NOP
3756  F6B4     NOP
3758  F51D     NOP
375A  0E00     MOVLW 0x0
375C  6E37     MOVWF 0x37, ACCESS
375E  0E00     MOVLW 0x0
3760  6E38     MOVWF 0x38, ACCESS
3762  0E00     MOVLW 0x0
3764  6E39     MOVWF CLKRCON, ACCESS
3766  0E40     MOVLW 0x40
3768  6E3A     MOVWF CLKRCLK, ACCESS
376C  F6A8     NOP
376E  F533     NOP
3772  F6AC     NOP
3774  F534     NOP
3778  F6B0     NOP
377A  F535     NOP
377E  F6B4     NOP
3780  F536     NOP
3782  EC0A     CALL 0x4C14, 0
3784  F026     NOP
3788  F4CC     NOP
378A  F51E     NOP
378E  F4D0     NOP
3790  F51F     NOP
3794  F4D4     NOP
3796  F520     NOP
379A  F4D8     NOP
379C  F521     NOP
379E  ECF3     CALL 0x5DE6, 0
37A0  F02E     NOP
37A4  F468     NOP
37A6  F592     NOP
37AA  F46C     NOP
37AC  F593     NOP
37B0  F470     NOP
37B2  F594     NOP
37B6  F474     NOP
37B8  F595     NOP
63:            	z = s*s;
37BC  F648     NOP
37BE  F501     NOP
37C2  F64C     NOP
37C4  F502     NOP
37C8  F650     NOP
37CA  F503     NOP
37CE  F654     NOP
37D0  F504     NOP
37D4  F648     NOP
37D6  F505     NOP
37DA  F64C     NOP
37DC  F506     NOP
37E0  F650     NOP
37E2  F507     NOP
37E6  F654     NOP
37E8  F508     NOP
37EA  ECCE     CALL 0x559C, 0
37EC  F02A     NOP
37F0  F404     NOP
37F2  F596     NOP
37F6  F408     NOP
37F8  F597     NOP
37FC  F40C     NOP
37FE  F598     NOP
3802  F410     NOP
3804  F599     NOP
64:            	w = z*z;
3808  F658     NOP
380A  F501     NOP
380E  F65C     NOP
3810  F502     NOP
3814  F660     NOP
3816  F503     NOP
381A  F664     NOP
381C  F504     NOP
3820  F658     NOP
3822  F505     NOP
3826  F65C     NOP
3828  F506     NOP
382C  F660     NOP
382E  F507     NOP
3832  F664     NOP
3834  F508     NOP
3836  ECCE     CALL 0x559C, 0
3838  F02A     NOP
383C  F404     NOP
383E  F59A     NOP
3842  F408     NOP
3844  F59B     NOP
3848  F40C     NOP
384A  F59C     NOP
384E  F410     NOP
3850  F59D     NOP
65:            	t1= w*(Lg2+w*Lg4);
38C4  F678     NOP
38C6  F501     NOP
38CA  F67C     NOP
38CC  F502     NOP
38D0  F680     NOP
38D2  F503     NOP
38D6  F684     NOP
38D8  F504     NOP
38DC  F668     NOP
38DE  F505     NOP
38E2  F66C     NOP
38E4  F506     NOP
38E8  F670     NOP
38EA  F507     NOP
38EE  F674     NOP
38F0  F508     NOP
38F2  ECCE     CALL 0x559C, 0
38F4  F02A     NOP
38F8  F404     NOP
38FA  F564     NOP
38FE  F408     NOP
3900  F565     NOP
3904  F40C     NOP
3906  F566     NOP
390A  F410     NOP
390C  F567     NOP
66:            	t2= z*(Lg1+w*Lg3);
3980  F678     NOP
3982  F501     NOP
3986  F67C     NOP
3988  F502     NOP
398C  F680     NOP
398E  F503     NOP
3992  F684     NOP
3994  F504     NOP
3998  F658     NOP
399A  F505     NOP
399E  F65C     NOP
39A0  F506     NOP
39A4  F660     NOP
39A6  F507     NOP
39AA  F664     NOP
39AC  F508     NOP
39AE  ECCE     CALL 0x559C, 0
39B0  F02A     NOP
39B4  F404     NOP
39B6  F568     NOP
39BA  F408     NOP
39BC  F569     NOP
39C0  F40C     NOP
39C2  F56A     NOP
39C6  F410     NOP
39C8  F56B     NOP
67:            	R = t2 + t1;
39CC  F5A0     NOP
39CE  F533     NOP
39D2  F5A4     NOP
39D4  F534     NOP
39D8  F5A8     NOP
39DA  F535     NOP
39DE  F5AC     NOP
39E0  F536     NOP
39E4  F590     NOP
39E6  F537     NOP
39EA  F594     NOP
39EC  F538     NOP
39F0  F598     NOP
39F2  F539     NOP
39F6  F59C     NOP
39F8  F53A     NOP
39FA  EC0A     CALL 0x4C14, 0
39FC  F026     NOP
3A00  F4CC     NOP
3A02  F560     NOP
3A06  F4D0     NOP
3A08  F561     NOP
3A0C  F4D4     NOP
3A0E  F562     NOP
3A12  F4D8     NOP
3A14  F563     NOP
68:            	hfsq = 0.5f*f*f;
3A16  0E00     MOVLW 0x0
3A18  6E05     MOVWF 0x5, ACCESS
3A1A  0E00     MOVLW 0x0
3A1C  6E06     MOVWF 0x6, ACCESS
3A1E  0E00     MOVLW 0x0
3A20  6E07     MOVWF 0x7, ACCESS
3A22  0E3F     MOVLW 0x3F
3A24  6E08     MOVWF 0x8, ACCESS
3A28  F6A8     NOP
3A2A  F501     NOP
3A2E  F6AC     NOP
3A30  F502     NOP
3A34  F6B0     NOP
3A36  F503     NOP
3A3A  F6B4     NOP
3A3C  F504     NOP
3A3E  ECCE     CALL 0x559C, 0
3A40  F02A     NOP
3A44  F404     NOP
3A46  F59E     NOP
3A4A  F408     NOP
3A4C  F59F     NOP
3A50  F40C     NOP
3A52  F5A0     NOP
3A56  F410     NOP
3A58  F5A1     NOP
3A5C  F678     NOP
3A5E  F501     NOP
3A62  F67C     NOP
3A64  F502     NOP
3A68  F680     NOP
3A6A  F503     NOP
3A6E  F684     NOP
3A70  F504     NOP
3A74  F6A8     NOP
3A76  F505     NOP
3A7A  F6AC     NOP
3A7C  F506     NOP
3A80  F6B0     NOP
3A82  F507     NOP
3A86  F6B4     NOP
3A88  F508     NOP
3A8A  ECCE     CALL 0x559C, 0
3A8C  F02A     NOP
3A90  F404     NOP
3A92  F58E     NOP
3A96  F408     NOP
3A98  F58F     NOP
3A9C  F40C     NOP
3A9E  F590     NOP
3AA2  F410     NOP
3AA4  F591     NOP
69:            
70:            	hi = f - hfsq;
3AA8  F6A8     NOP
3AAA  F543     NOP
3AAE  F6AC     NOP
3AB0  F544     NOP
3AB4  F6B0     NOP
3AB6  F545     NOP
3ABA  F6B4     NOP
3ABC  F546     NOP
3AC0  F638     NOP
3AC2  F547     NOP
3AC6  F63C     NOP
3AC8  F548     NOP
3ACC  F640     NOP
3ACE  F549     NOP
3AD2  F644     NOP
3AD4  F54A     NOP
3AD6  EC93     CALL 0x8126, 0
3AD8  F040     NOP
3ADC  F50C     NOP
3ADE  F5A2     NOP
3AE2  F510     NOP
3AE4  F5A3     NOP
3AE8  F514     NOP
3AEA  F5A4     NOP
3AEE  F518     NOP
3AF0  F5A5     NOP
71:            	u.f = hi;
3AF4  F688     NOP
3AF6  F5A6     NOP
3AFA  F68C     NOP
3AFC  F5A7     NOP
3B00  F690     NOP
3B02  F5A8     NOP
3B06  F694     NOP
3B08  F5A9     NOP
72:            	u.i &= 0xfffff000;
3B0A  0E00     MOVLW 0x0
3B0C  0105     MOVLB 0x5
3B0E  17A6     ANDWF 0xA6, F, BANKED
3B10  0EF0     MOVLW 0xF0
3B12  17A7     ANDWF 0xA7, F, BANKED
3B14  0EFF     MOVLW 0xFF
3B16  17A8     ANDWF 0xA8, F, BANKED
3B18  0EFF     MOVLW 0xFF
3B1A  17A9     ANDWF 0xA9, F, BANKED
73:            	hi = u.f;
3B1E  F698     NOP
3B20  F5A2     NOP
3B24  F69C     NOP
3B26  F5A3     NOP
3B2A  F6A0     NOP
3B2C  F5A4     NOP
3B30  F6A4     NOP
3B32  F5A5     NOP
74:            	lo = f - hi - hfsq + s*(hfsq+R);
3B36  F688     NOP
3B38  F547     NOP
3B3C  F68C     NOP
3B3E  F548     NOP
3B42  F690     NOP
3B44  F549     NOP
3B48  F694     NOP
3B4A  F54A     NOP
3B4E  F6A8     NOP
3B50  F543     NOP
3B54  F6AC     NOP
3B56  F544     NOP
3B5A  F6B0     NOP
3B5C  F545     NOP
3B60  F6B4     NOP
3B62  F546     NOP
3B64  EC93     CALL 0x8126, 0
3B66  F040     NOP
3B6A  F50C     NOP
3B6C  F56C     NOP
3B70  F510     NOP
3B72  F56D     NOP
3B76  F514     NOP
3B78  F56E     NOP
3B7C  F518     NOP
3B7E  F56F     NOP
3B82  F638     NOP
3B84  F547     NOP
3B88  F63C     NOP
3B8A  F548     NOP
3B8E  F640     NOP
3B90  F549     NOP
3B94  F644     NOP
3B96  F54A     NOP
3B9A  F5B0     NOP
3B9C  F543     NOP
3BA0  F5B4     NOP
3BA2  F544     NOP
3BA6  F5B8     NOP
3BA8  F545     NOP
3BAC  F5BC     NOP
3BAE  F546     NOP
3BB0  EC93     CALL 0x8126, 0
3BB2  F040     NOP
3BB6  F50C     NOP
3BB8  F570     NOP
3BBC  F510     NOP
3BBE  F571     NOP
3BC2  F514     NOP
3BC4  F572     NOP
3BC8  F518     NOP
3BCA  F573     NOP
3BCE  F648     NOP
3BD0  F505     NOP
3BD4  F64C     NOP
3BD6  F506     NOP
3BDA  F650     NOP
3BDC  F507     NOP
3BE0  F654     NOP
3BE2  F508     NOP
3BE6  F580     NOP
3BE8  F537     NOP
3BEC  F584     NOP
3BEE  F538     NOP
3BF2  F588     NOP
3BF4  F539     NOP
3BF8  F58C     NOP
3BFA  F53A     NOP
3BFE  F638     NOP
3C00  F533     NOP
3C04  F63C     NOP
3C06  F534     NOP
3C0A  F640     NOP
3C0C  F535     NOP
3C10  F644     NOP
3C12  F536     NOP
3C14  EC0A     CALL 0x4C14, 0
3C16  F026     NOP
3C1A  F4CC     NOP
3C1C  F501     NOP
3C20  F4D0     NOP
3C22  F502     NOP
3C26  F4D4     NOP
3C28  F503     NOP
3C2C  F4D8     NOP
3C2E  F504     NOP
3C30  ECCE     CALL 0x559C, 0
3C32  F02A     NOP
3C36  F404     NOP
3C38  F58A     NOP
3C3C  F408     NOP
3C3E  F58B     NOP
3C42  F40C     NOP
3C44  F58C     NOP
3C48  F410     NOP
3C4A  F58D     NOP
3C4E  F5C0     NOP
3C50  F533     NOP
3C54  F5C4     NOP
3C56  F534     NOP
3C5A  F5C8     NOP
3C5C  F535     NOP
3C60  F5CC     NOP
3C62  F536     NOP
3C66  F628     NOP
3C68  F537     NOP
3C6C  F62C     NOP
3C6E  F538     NOP
3C72  F630     NOP
3C74  F539     NOP
3C78  F634     NOP
3C7A  F53A     NOP
3C7C  EC0A     CALL 0x4C14, 0
3C7E  F026     NOP
3C82  F4CC     NOP
3C84  F586     NOP
3C88  F4D0     NOP
3C8A  F587     NOP
3C8E  F4D4     NOP
3C90  F588     NOP
3C94  F4D8     NOP
3C96  F589     NOP
75:            	dk = k;
3C9A  F600     NOP
3C9C  F501     NOP
3CA0  F604     NOP
3CA2  F502     NOP
3CA4  0E00     MOVLW 0x0
3CA6  BE02     BTFSC 0x2, 7, ACCESS
3CA8  0EFF     MOVLW 0xFF
3CAA  6E03     MOVWF 0x3, ACCESS
3CAC  6E04     MOVWF 0x4, ACCESS
3CAE  0E01     MOVLW 0x1
3CB0  ECCD     CALL 0x699A, 0
3CB2  F034     NOP
3CB6  F404     NOP
3CB8  F582     NOP
3CBC  F408     NOP
3CBE  F583     NOP
3CC2  F40C     NOP
3CC4  F584     NOP
3CC8  F410     NOP
3CCA  F585     NOP
76:            	return dk*log10_2lo + (lo+hi)*ivln10lo + lo*ivln10hi + hi*ivln10hi + dk*log10_2hi;
77:            }
3F24  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/isupper.c  -----------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isupper
4:             
5:             int isupper(int c)
6:             {
7:             	return (unsigned)c-'A' < 26;
8340  0EBF     MOVLW 0xBF
8342  0106     MOVLB 0x6
8344  6F02     MOVWF 0x2, BANKED
8346  0EFF     MOVLW 0xFF
8348  6F03     MOVWF 0x3, BANKED
834C  F800     NOP
834E  F604     NOP
8352  F804     NOP
8354  F605     NOP
8356  5102     MOVF 0x2, W, BANKED
8358  2704     ADDWF 0x4, F, BANKED
835A  5103     MOVF 0x3, W, BANKED
835C  2305     ADDWFC 0x5, F, BANKED
835E  5105     MOVF 0x5, W, BANKED
8360  E10A     BNZ 0x8376
8362  0E1A     MOVLW 0x1A
8364  5D04     SUBWF 0x4, W, BANKED
8366  A0D8     BTFSS 0xFD8, 0, ACCESS
8368  EFB8     GOTO 0x8370
836A  F041     NOP
836C  EFBB     GOTO 0x8376
836E  F041     NOP
8370  0E01     MOVLW 0x1
8372  EFBC     GOTO 0x8378
8374  F041     NOP
8376  0E00     MOVLW 0x0
8378  6F00     MOVWF txData, BANKED
837A  6B01     CLRF 0x1, BANKED
8:             }
837C  0012     RETURN 0
9:             
10:            int __isupper_l(int c, locale_t l)
11:            {
12:            	return isupper(c);
13:            }
14:            
15:            weak_alias(__isupper_l, isupper_l);
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/isspace.c  -----------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isspace
4:             
5:             int isspace(int c)
6:             {
7:             	return c == ' ' || (unsigned)c-'\t' < 5;
8184  0E01     MOVLW 0x1
8186  0106     MOVLB 0x6
8188  6F06     MOVWF 0x6, BANKED
818A  0E20     MOVLW 0x20
818C  1900     XORWF txData, W, BANKED
818E  1101     IORWF 0x1, W, BANKED
8190  B4D8     BTFSC 0xFD8, 2, ACCESS
8192  EFCD     GOTO 0x819A
8194  F040     NOP
8196  EFCF     GOTO 0x819E
8198  F040     NOP
819A  EFEA     GOTO 0x81D4
819C  F040     NOP
819E  0EF7     MOVLW 0xF7
81A0  6F02     MOVWF 0x2, BANKED
81A2  0EFF     MOVLW 0xFF
81A4  6F03     MOVWF 0x3, BANKED
81A8  F800     NOP
81AA  F604     NOP
81AE  F804     NOP
81B0  F605     NOP
81B2  5102     MOVF 0x2, W, BANKED
81B4  2704     ADDWF 0x4, F, BANKED
81B6  5103     MOVF 0x3, W, BANKED
81B8  2305     ADDWFC 0x5, F, BANKED
81BA  5105     MOVF 0x5, W, BANKED
81BC  E109     BNZ 0x81D0
81BE  0E05     MOVLW 0x5
81C0  5D04     SUBWF 0x4, W, BANKED
81C2  A0D8     BTFSS 0xFD8, 0, ACCESS
81C4  EFE6     GOTO 0x81CC
81C6  F040     NOP
81C8  EFE8     GOTO 0x81D0
81CA  F040     NOP
81CC  EFEA     GOTO 0x81D4
81CE  F040     NOP
81D0  0E00     MOVLW 0x0
81D2  6F06     MOVWF 0x6, BANKED
81D6  F818     NOP
81D8  F600     NOP
81DA  6B01     CLRF 0x1, BANKED
8:             }
81DC  0012     RETURN 0
9:             
10:            int __isspace_l(int c, locale_t l)
11:            {
12:            	return isspace(c);
13:            }
14:            
15:            weak_alias(__isspace_l, isspace_l);
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/isdigit.c  -----------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isdigit
4:             
5:             int isdigit(int c)
6:             {
7:             	return (unsigned)c-'0' < 10;
837E  0ED0     MOVLW 0xD0
8380  0106     MOVLB 0x6
8382  6F02     MOVWF 0x2, BANKED
8384  0EFF     MOVLW 0xFF
8386  6F03     MOVWF 0x3, BANKED
838A  F800     NOP
838C  F604     NOP
8390  F804     NOP
8392  F605     NOP
8394  5102     MOVF 0x2, W, BANKED
8396  2704     ADDWF 0x4, F, BANKED
8398  5103     MOVF 0x3, W, BANKED
839A  2305     ADDWFC 0x5, F, BANKED
839C  5105     MOVF 0x5, W, BANKED
839E  E10A     BNZ 0x83B4
83A0  0E0A     MOVLW 0xA
83A2  5D04     SUBWF 0x4, W, BANKED
83A4  A0D8     BTFSS 0xFD8, 0, ACCESS
83A6  EFD7     GOTO 0x83AE
83A8  F041     NOP
83AA  EFDA     GOTO 0x83B4
83AC  F041     NOP
83AE  0E01     MOVLW 0x1
83B0  EFDB     GOTO 0x83B6
83B2  F041     NOP
83B4  0E00     MOVLW 0x0
83B6  6F00     MOVWF txData, BANKED
83B8  6B01     CLRF 0x1, BANKED
8:             }
83BA  0012     RETURN 0
9:             
10:            int __isdigit_l(int c, locale_t l)
11:            {
12:            	return isdigit(c);
13:            }
14:            
15:            weak_alias(__isdigit_l, isdigit_l);
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/fltol.c  -------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned long *)&f1)
11:            
12:            // Convert float to long
13:            #ifdef _OLDLIB
14:            long
15:            __fltol(double f1)
16:            {
17:            	unsigned char	sign1, exp1;
18:            	unsigned long	lval;
19:            
20:            	sign1 = __flunpack(&f1_as_mant1, &exp1);
21:            	lval = f1_as_mant1;
22:            	exp1 -= 127+23;
23:            	if((signed char)exp1 < 0) {
24:            		if((signed char)exp1 < -23)
25:            			return 0;
26:            		do
27:            			lval >>= 1;
28:            		while(++exp1 != 0);
29:            	} else {
30:            		if(exp1 >= 32)
31:            			return 00;
32:            		while(exp1 != 0) {
33:            			lval <<= 1;
34:            			exp1--;
35:            		}
36:            	}
37:            	if(sign1)
38:            		lval = -lval;
39:            	return lval;
40:            }
41:            #else
42:            long
43:            __fltol(double f1)
44:            {
45:            	unsigned char	sign1, exp1;
46:            
47:            	if((exp1 = f1_as_mant1 >> 23) == 0)
72CE  0106     MOVLB 0x6
72D0  3502     RLCF 0x2, W, BANKED
72D2  3503     RLCF 0x3, W, BANKED
72D4  6F09     MOVWF 0x9, BANKED
72D6  5109     MOVF 0x9, W, BANKED
72D8  A4D8     BTFSS 0xFD8, 2, ACCESS
72DA  EF71     GOTO 0x72E2
72DC  F039     NOP
72DE  EF73     GOTO 0x72E6
72E0  F039     NOP
72E2  EF7D     GOTO 0x72FA
72E4  F039     NOP
48:            		return 0;
72E6  0E00     MOVLW 0x0
72E8  6F00     MOVWF txData, BANKED
72EA  0E00     MOVLW 0x0
72EC  6F01     MOVWF 0x1, BANKED
72EE  0E00     MOVLW 0x0
72F0  6F02     MOVWF 0x2, BANKED
72F2  0E00     MOVLW 0x0
72F4  6F03     MOVWF 0x3, BANKED
72F6  EFF2     GOTO 0x73E4
72F8  F039     NOP
49:            	sign1 = f1_as_mant1 >> 31;
72FC  F800     NOP
72FE  F604     NOP
7302  F804     NOP
7304  F605     NOP
7308  F808     NOP
730A  F606     NOP
730E  F80C     NOP
7310  F607     NOP
7312  0E20     MOVLW 0x20
7314  EF91     GOTO 0x7322
7316  F039     NOP
7318  90D8     BCF 0xFD8, 0, ACCESS
731A  3307     RRCF 0x7, F, BANKED
731C  3306     RRCF 0x6, F, BANKED
731E  3305     RRCF 0x5, F, BANKED
7320  3304     RRCF 0x4, F, BANKED
7322  2EE8     DECFSZ 0xFE8, F, ACCESS
7324  EF8C     GOTO 0x7318
7326  F039     NOP
7328  5104     MOVF 0x4, W, BANKED
732A  6F08     MOVWF 0x8, BANKED
50:            	f1_as_mant1 |= 0x800000UL;
732C  8F02     BSF 0x2, 7, BANKED
51:            	f1_as_mant1 &= 0xFFFFFFUL;
732E  0EFF     MOVLW 0xFF
7330  1700     ANDWF txData, F, BANKED
7332  0EFF     MOVLW 0xFF
7334  1701     ANDWF 0x1, F, BANKED
7336  0EFF     MOVLW 0xFF
7338  1702     ANDWF 0x2, F, BANKED
733A  0E00     MOVLW 0x0
733C  1703     ANDWF 0x3, F, BANKED
52:            	exp1 -= 127+23;
733E  0E96     MOVLW 0x96
7340  5F09     SUBWF 0x9, F, BANKED
53:            	if((signed char)exp1 < 0) {
7342  BF09     BTFSC 0x9, 7, BANKED
7344  EFA8     GOTO 0x7350
7346  F039     NOP
7348  EFA6     GOTO 0x734C
734A  F039     NOP
734C  EFBE     GOTO 0x737C
734E  F039     NOP
54:            		if((signed char)exp1 < -23)
7350  5109     MOVF 0x9, W, BANKED
7352  0A80     XORLW 0x80
7354  0F97     ADDLW 0x97
7356  B0D8     BTFSC 0xFD8, 0, ACCESS
7358  EFB0     GOTO 0x7360
735A  F039     NOP
735C  EFB2     GOTO 0x7364
735E  F039     NOP
7360  EFB4     GOTO 0x7368
7362  F039     NOP
7364  EF73     GOTO 0x72E6
7366  F039     NOP
55:            			return 0;
56:            		do
57:            			f1_as_mant1 >>= 1;
7368  90D8     BCF 0xFD8, 0, ACCESS
736A  3303     RRCF 0x3, F, BANKED
736C  3302     RRCF 0x2, F, BANKED
736E  3301     RRCF 0x1, F, BANKED
7370  3300     RRCF txData, F, BANKED
7372  3F09     INCFSZ 0x9, F, BANKED
7374  EFB4     GOTO 0x7368
7376  F039     NOP
7378  EFD6     GOTO 0x73AC
737A  F039     NOP
58:            		while(++exp1 != 0);
59:            	} else {
60:            		if(exp1 >= 32)
737C  0E1F     MOVLW 0x1F
737E  6509     CPFSGT 0x9, BANKED
7380  EFC4     GOTO 0x7388
7382  F039     NOP
7384  EFC6     GOTO 0x738C
7386  F039     NOP
7388  EFCE     GOTO 0x739C
738A  F039     NOP
738C  EF73     GOTO 0x72E6
738E  F039     NOP
61:            			return 00;
62:            		while(exp1 != 0) {
739C  5109     MOVF 0x9, W, BANKED
739E  A4D8     BTFSS 0xFD8, 2, ACCESS
73A0  EFD4     GOTO 0x73A8
73A2  F039     NOP
73A4  EFD6     GOTO 0x73AC
73A6  F039     NOP
73A8  EFC8     GOTO 0x7390
73AA  F039     NOP
63:            			f1_as_mant1 <<= 1;
7390  90D8     BCF 0xFD8, 0, ACCESS
7392  3700     RLCF txData, F, BANKED
7394  3701     RLCF 0x1, F, BANKED
7396  3702     RLCF 0x2, F, BANKED
7398  3703     RLCF 0x3, F, BANKED
64:            			exp1--;
739A  0709     DECF 0x9, F, BANKED
65:            		}
66:            	}
67:            	if(sign1)
73AC  5108     MOVF 0x8, W, BANKED
73AE  B4D8     BTFSC 0xFD8, 2, ACCESS
73B0  EFDC     GOTO 0x73B8
73B2  F039     NOP
73B4  EFDE     GOTO 0x73BC
73B6  F039     NOP
73B8  EFE6     GOTO 0x73CC
73BA  F039     NOP
68:            		f1_as_mant1 = -f1_as_mant1;
73BC  1F03     COMF 0x3, F, BANKED
73BE  1F02     COMF 0x2, F, BANKED
73C0  1F01     COMF 0x1, F, BANKED
73C2  6D00     NEGF txData, BANKED
73C4  0E00     MOVLW 0x0
73C6  2301     ADDWFC 0x1, F, BANKED
73C8  2302     ADDWFC 0x2, F, BANKED
73CA  2303     ADDWFC 0x3, F, BANKED
69:            	return f1_as_mant1;
73CE  F800     NOP
73D0  F600     NOP
73D4  F804     NOP
73D6  F601     NOP
73DA  F808     NOP
73DC  F602     NOP
73E0  F80C     NOP
73E2  F603     NOP
70:            }
73E4  0012     RETURN 0
71:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/floorf.c  ------------------------
1:             #include "libm.h"
2:             
3:             float floorf(float x)
4:             {
5:             	union {float f; uint32_t i;} u = {x};
64F4  FA9C     NOP
64F6  F629     NOP
64FA  FAA0     NOP
64FC  F62A     NOP
6500  FAA4     NOP
6502  F62B     NOP
6506  FAA8     NOP
6508  F62C     NOP
650C  F864     NOP
650E  F629     NOP
6512  F868     NOP
6514  F62A     NOP
6518  F86C     NOP
651A  F62B     NOP
651E  F870     NOP
6520  F62C     NOP
6:             	int e = (int)(u.i >> 23 & 0xff) - 0x7f;
6522  0E81     MOVLW 0x81
6524  0106     MOVLB 0x6
6526  6F1D     MOVWF 0x1D, BANKED
6528  0EFF     MOVLW 0xFF
652A  6F1E     MOVWF 0x1E, BANKED
652E  F8A4     NOP
6530  F61F     NOP
6534  F8A8     NOP
6536  F620     NOP
653A  F8AC     NOP
653C  F621     NOP
6540  F8B0     NOP
6542  F622     NOP
6544  0E18     MOVLW 0x18
6546  EFAA     GOTO 0x6554
6548  F032     NOP
654A  90D8     BCF 0xFD8, 0, ACCESS
654C  3322     RRCF 0x22, F, BANKED
654E  3321     RRCF 0x21, F, BANKED
6550  3320     RRCF 0x20, F, BANKED
6552  331F     RRCF 0x1F, F, BANKED
6554  2EE8     DECFSZ 0xFE8, F, ACCESS
6556  EFA5     GOTO 0x654A
6558  F032     NOP
655A  511F     MOVF 0x1F, W, BANKED
655C  251D     ADDWF 0x1D, W, BANKED
655E  6F27     MOVWF 0x27, BANKED
6560  0E00     MOVLW 0x0
6562  211E     ADDWFC 0x1E, W, BANKED
6564  6F28     MOVWF 0x28, BANKED
7:             	uint32_t m;
8:             
9:             	if (e >= 23)
6566  BF28     BTFSC 0x28, 7, BANKED
6568  EFBF     GOTO 0x657E
656A  F032     NOP
656C  5128     MOVF 0x28, W, BANKED
656E  E109     BNZ 0x6582
6570  0E17     MOVLW 0x17
6572  5D27     SUBWF 0x27, W, BANKED
6574  A0D8     BTFSS 0xFD8, 0, ACCESS
6576  EFBF     GOTO 0x657E
6578  F032     NOP
657A  EFC1     GOTO 0x6582
657C  F032     NOP
657E  EFCF     GOTO 0x659E
6580  F032     NOP
10:            		return x;
6584  F864     NOP
6586  F619     NOP
658A  F868     NOP
658C  F61A     NOP
6590  F86C     NOP
6592  F61B     NOP
6596  F870     NOP
6598  F61C     NOP
659A  EFA4     GOTO 0x6748
659C  F033     NOP
11:            	if (e >= 0) {
659E  BF28     BTFSC 0x28, 7, BANKED
65A0  EFD4     GOTO 0x65A8
65A2  F032     NOP
65A4  EFD6     GOTO 0x65AC
65A6  F032     NOP
65A8  EF50     GOTO 0x66A0
65AA  F033     NOP
12:            		m = 0x007fffff >> e;
65AE  F89C     NOP
65B0  F61D     NOP
65B2  0EFF     MOVLW 0xFF
65B4  6F1E     MOVWF 0x1E, BANKED
65B6  0EFF     MOVLW 0xFF
65B8  6F1F     MOVWF 0x1F, BANKED
65BA  0E7F     MOVLW 0x7F
65BC  6F20     MOVWF 0x20, BANKED
65BE  0E00     MOVLW 0x0
65C0  6F21     MOVWF 0x21, BANKED
65C2  671D     TSTFSZ 0x1D, BANKED
65C4  EFE6     GOTO 0x65CC
65C6  F032     NOP
65C8  EFEE     GOTO 0x65DC
65CA  F032     NOP
65CC  3521     RLCF 0x21, W, BANKED
65CE  3321     RRCF 0x21, F, BANKED
65D0  3320     RRCF 0x20, F, BANKED
65D2  331F     RRCF 0x1F, F, BANKED
65D4  331E     RRCF 0x1E, F, BANKED
65D6  2F1D     DECFSZ 0x1D, F, BANKED
65D8  EFE1     GOTO 0x65C2
65DA  F032     NOP
65DE  F878     NOP
65E0  F623     NOP
65E4  F87C     NOP
65E6  F624     NOP
65EA  F880     NOP
65EC  F625     NOP
65F0  F884     NOP
65F2  F626     NOP
13:            		if ((u.i & m) == 0)
65F4  0106     MOVLB 0x6
65F6  5123     MOVF 0x23, W, BANKED
65F8  1529     ANDWF 0x29, W, BANKED
65FA  6F1D     MOVWF 0x1D, BANKED
65FC  5124     MOVF 0x24, W, BANKED
65FE  152A     ANDWF 0x2A, W, BANKED
6600  6F1E     MOVWF 0x1E, BANKED
6602  5125     MOVF 0x25, W, BANKED
6604  152B     ANDWF 0x2B, W, BANKED
6606  6F1F     MOVWF 0x1F, BANKED
6608  5126     MOVF 0x26, W, BANKED
660A  152C     ANDWF 0x2C, W, BANKED
660C  6F20     MOVWF 0x20, BANKED
660E  511D     MOVF 0x1D, W, BANKED
6610  111E     IORWF 0x1E, W, BANKED
6612  111F     IORWF 0x1F, W, BANKED
6614  1120     IORWF 0x20, W, BANKED
6616  A4D8     BTFSS 0xFD8, 2, ACCESS
6618  EF10     GOTO 0x6620
661A  F033     NOP
661C  EF12     GOTO 0x6624
661E  F033     NOP
6620  EF14     GOTO 0x6628
6622  F033     NOP
6624  EFC1     GOTO 0x6582
6626  F032     NOP
14:            			return x;
15:            		FORCE_EVAL(x + 0x1p120f);
16:            		if (u.i >> 31)
662A  F8A4     NOP
662C  F61D     NOP
6630  F8A8     NOP
6632  F61E     NOP
6636  F8AC     NOP
6638  F61F     NOP
663C  F8B0     NOP
663E  F620     NOP
6640  0E20     MOVLW 0x20
6642  EF28     GOTO 0x6650
6644  F033     NOP
6646  90D8     BCF 0xFD8, 0, ACCESS
6648  3320     RRCF 0x20, F, BANKED
664A  331F     RRCF 0x1F, F, BANKED
664C  331E     RRCF 0x1E, F, BANKED
664E  331D     RRCF 0x1D, F, BANKED
6650  2EE8     DECFSZ 0xFE8, F, ACCESS
6652  EF23     GOTO 0x6646
6654  F033     NOP
6656  511D     MOVF 0x1D, W, BANKED
6658  111E     IORWF 0x1E, W, BANKED
665A  111F     IORWF 0x1F, W, BANKED
665C  1120     IORWF 0x20, W, BANKED
665E  B4D8     BTFSC 0xFD8, 2, ACCESS
6660  EF34     GOTO 0x6668
6662  F033     NOP
6664  EF36     GOTO 0x666C
6666  F033     NOP
6668  EF3E     GOTO 0x667C
666A  F033     NOP
17:            			u.i += m;
666C  5123     MOVF 0x23, W, BANKED
666E  2729     ADDWF 0x29, F, BANKED
6670  5124     MOVF 0x24, W, BANKED
6672  232A     ADDWFC 0x2A, F, BANKED
6674  5125     MOVF 0x25, W, BANKED
6676  232B     ADDWFC 0x2B, F, BANKED
6678  5126     MOVF 0x26, W, BANKED
667A  232C     ADDWFC 0x2C, F, BANKED
18:            		u.i &= ~m;
667C  1D23     COMF 0x23, W, BANKED
667E  6F1D     MOVWF 0x1D, BANKED
6680  1D24     COMF 0x24, W, BANKED
6682  6F1E     MOVWF 0x1E, BANKED
6684  1D25     COMF 0x25, W, BANKED
6686  6F1F     MOVWF 0x1F, BANKED
6688  1D26     COMF 0x26, W, BANKED
668A  6F20     MOVWF 0x20, BANKED
668C  511D     MOVF 0x1D, W, BANKED
668E  1729     ANDWF 0x29, F, BANKED
6690  511E     MOVF 0x1E, W, BANKED
6692  172A     ANDWF 0x2A, F, BANKED
6694  511F     MOVF 0x1F, W, BANKED
6696  172B     ANDWF 0x2B, F, BANKED
6698  5120     MOVF 0x20, W, BANKED
669A  172C     ANDWF 0x2C, F, BANKED
19:            	} else {
669C  EF98     GOTO 0x6730
669E  F033     NOP
20:            		FORCE_EVAL(x + 0x1p120f);
21:            		if (u.i >> 31 == 0)
66A2  F8A4     NOP
66A4  F61D     NOP
66A8  F8A8     NOP
66AA  F61E     NOP
66AE  F8AC     NOP
66B0  F61F     NOP
66B4  F8B0     NOP
66B6  F620     NOP
66B8  0E20     MOVLW 0x20
66BA  EF64     GOTO 0x66C8
66BC  F033     NOP
66BE  90D8     BCF 0xFD8, 0, ACCESS
66C0  3320     RRCF 0x20, F, BANKED
66C2  331F     RRCF 0x1F, F, BANKED
66C4  331E     RRCF 0x1E, F, BANKED
66C6  331D     RRCF 0x1D, F, BANKED
66C8  2EE8     DECFSZ 0xFE8, F, ACCESS
66CA  EF5F     GOTO 0x66BE
66CC  F033     NOP
66CE  511D     MOVF 0x1D, W, BANKED
66D0  111E     IORWF 0x1E, W, BANKED
66D2  111F     IORWF 0x1F, W, BANKED
66D4  1120     IORWF 0x20, W, BANKED
66D6  A4D8     BTFSS 0xFD8, 2, ACCESS
66D8  EF70     GOTO 0x66E0
66DA  F033     NOP
66DC  EF72     GOTO 0x66E4
66DE  F033     NOP
66E0  EF7C     GOTO 0x66F8
66E2  F033     NOP
22:            			u.i = 0;
66E4  0E00     MOVLW 0x0
66E6  6F29     MOVWF 0x29, BANKED
66E8  0E00     MOVLW 0x0
66EA  6F2A     MOVWF 0x2A, BANKED
66EC  0E00     MOVLW 0x0
66EE  6F2B     MOVWF 0x2B, BANKED
66F0  0E00     MOVLW 0x0
66F2  6F2C     MOVWF 0x2C, BANKED
66F4  EF98     GOTO 0x6730
66F6  F033     NOP
23:            		else if (u.i << 1)
66F8  90D8     BCF 0xFD8, 0, ACCESS
66FA  3529     RLCF 0x29, W, BANKED
66FC  6F1D     MOVWF 0x1D, BANKED
66FE  352A     RLCF 0x2A, W, BANKED
6700  6F1E     MOVWF 0x1E, BANKED
6702  352B     RLCF 0x2B, W, BANKED
6704  6F1F     MOVWF 0x1F, BANKED
6706  352C     RLCF 0x2C, W, BANKED
6708  6F20     MOVWF 0x20, BANKED
670A  511D     MOVF 0x1D, W, BANKED
670C  111E     IORWF 0x1E, W, BANKED
670E  111F     IORWF 0x1F, W, BANKED
6710  1120     IORWF 0x20, W, BANKED
6712  B4D8     BTFSC 0xFD8, 2, ACCESS
6714  EF8E     GOTO 0x671C
6716  F033     NOP
6718  EF90     GOTO 0x6720
671A  F033     NOP
671C  EF98     GOTO 0x6730
671E  F033     NOP
24:            			u.f = -1.0;
6720  0E00     MOVLW 0x0
6722  6F29     MOVWF 0x29, BANKED
6724  0E00     MOVLW 0x0
6726  6F2A     MOVWF 0x2A, BANKED
6728  0E80     MOVLW 0x80
672A  6F2B     MOVWF 0x2B, BANKED
672C  0EBF     MOVLW 0xBF
672E  6F2C     MOVWF 0x2C, BANKED
25:            	}
26:            	return u.f;
6732  F8A4     NOP
6734  F619     NOP
6738  F8A8     NOP
673A  F61A     NOP
673E  F8AC     NOP
6740  F61B     NOP
6744  F8B0     NOP
6746  F61C     NOP
27:            }
6748  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/flneg.c  -------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	mant1	(*(unsigned long *)&f1)
11:            
12:            // Negate a float
13:            
14:            double
15:            __flneg(double f1)
16:            {
17:            	if(mant1 != 0x0)
827A  0106     MOVLB 0x6
827C  5100     MOVF txData, W, BANKED
827E  1101     IORWF 0x1, W, BANKED
8280  1102     IORWF 0x2, W, BANKED
8282  1103     IORWF 0x3, W, BANKED
8284  B4D8     BTFSC 0xFD8, 2, ACCESS
8286  EF47     GOTO 0x828E
8288  F041     NOP
828A  EF49     GOTO 0x8292
828C  F041     NOP
828E  EF51     GOTO 0x82A2
8290  F041     NOP
18:            		mant1 ^= 0x80000000UL;
8292  0E00     MOVLW 0x0
8294  1B00     XORWF txData, F, BANKED
8296  0E00     MOVLW 0x0
8298  1B01     XORWF 0x1, F, BANKED
829A  0E00     MOVLW 0x0
829C  1B02     XORWF 0x2, F, BANKED
829E  0E80     MOVLW 0x80
82A0  1B03     XORWF 0x3, F, BANKED
19:            	return f1;
82A4  F800     NOP
82A6  F600     NOP
82AA  F804     NOP
82AC  F601     NOP
82B0  F808     NOP
82B2  F602     NOP
82B6  F80C     NOP
82B8  F603     NOP
20:            }
82BA  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/flge.c  --------------------------
1:             #define	f1	(*(unsigned long *)&ff1)
2:             #define	f2	(*(unsigned long *)&ff2)
3:             __bit
4:             __flge(double ff1, double ff2)
5:             {
6:                     // flush denorms and zeroes to +ve 0.0
7:                     if((f1 &  0x7F800000UL)== 0)
74FA  0E00     MOVLW 0x0
74FC  0106     MOVLB 0x6
74FE  1519     ANDWF 0x19, W, BANKED
7500  6F21     MOVWF 0x21, BANKED
7502  0E00     MOVLW 0x0
7504  151A     ANDWF 0x1A, W, BANKED
7506  6F22     MOVWF 0x22, BANKED
7508  0E80     MOVLW 0x80
750A  151B     ANDWF 0x1B, W, BANKED
750C  6F23     MOVWF 0x23, BANKED
750E  0E7F     MOVLW 0x7F
7510  151C     ANDWF 0x1C, W, BANKED
7512  6F24     MOVWF 0x24, BANKED
7514  5121     MOVF 0x21, W, BANKED
7516  1122     IORWF 0x22, W, BANKED
7518  1123     IORWF 0x23, W, BANKED
751A  1124     IORWF 0x24, W, BANKED
751C  A4D8     BTFSS 0xFD8, 2, ACCESS
751E  EF93     GOTO 0x7526
7520  F03A     NOP
7522  EF95     GOTO 0x752A
7524  F03A     NOP
7526  EF9D     GOTO 0x753A
7528  F03A     NOP
8:             		f1 = 0x00000000UL;
752A  0E00     MOVLW 0x0
752C  6F19     MOVWF 0x19, BANKED
752E  0E00     MOVLW 0x0
7530  6F1A     MOVWF 0x1A, BANKED
7532  0E00     MOVLW 0x0
7534  6F1B     MOVWF 0x1B, BANKED
7536  0E00     MOVLW 0x0
7538  6F1C     MOVWF 0x1C, BANKED
9:             	if((f2 &  0x7F800000UL)== 0)
753A  0E00     MOVLW 0x0
753C  151D     ANDWF 0x1D, W, BANKED
753E  6F21     MOVWF 0x21, BANKED
7540  0E00     MOVLW 0x0
7542  151E     ANDWF 0x1E, W, BANKED
7544  6F22     MOVWF 0x22, BANKED
7546  0E80     MOVLW 0x80
7548  151F     ANDWF 0x1F, W, BANKED
754A  6F23     MOVWF 0x23, BANKED
754C  0E7F     MOVLW 0x7F
754E  1520     ANDWF 0x20, W, BANKED
7550  6F24     MOVWF 0x24, BANKED
7552  5121     MOVF 0x21, W, BANKED
7554  1122     IORWF 0x22, W, BANKED
7556  1123     IORWF 0x23, W, BANKED
7558  1124     IORWF 0x24, W, BANKED
755A  A4D8     BTFSS 0xFD8, 2, ACCESS
755C  EFB2     GOTO 0x7564
755E  F03A     NOP
7560  EFB4     GOTO 0x7568
7562  F03A     NOP
7564  EFBC     GOTO 0x7578
7566  F03A     NOP
10:            	        f2 = 0x00000000UL;
7568  0E00     MOVLW 0x0
756A  6F1D     MOVWF 0x1D, BANKED
756C  0E00     MOVLW 0x0
756E  6F1E     MOVWF 0x1E, BANKED
7570  0E00     MOVLW 0x0
7572  6F1F     MOVWF 0x1F, BANKED
7574  0E00     MOVLW 0x0
7576  6F20     MOVWF 0x20, BANKED
11:            	// compute >= a clever way
12:            	if(f1 &  0x80000000UL)
7578  AF1C     BTFSS 0x1C, 7, BANKED
757A  EFC1     GOTO 0x7582
757C  F03A     NOP
757E  EFC3     GOTO 0x7586
7580  F03A     NOP
7582  EFCC     GOTO 0x7598
7584  F03A     NOP
13:            		f1 = 0x80000000UL - f1;
7586  6D19     NEGF 0x19, BANKED
7588  1F1A     COMF 0x1A, F, BANKED
758A  B0D8     BTFSC 0xFD8, 0, ACCESS
758C  2B1A     INCF 0x1A, F, BANKED
758E  1F1B     COMF 0x1B, F, BANKED
7590  B0D8     BTFSC 0xFD8, 0, ACCESS
7592  2B1B     INCF 0x1B, F, BANKED
7594  0E80     MOVLW 0x80
7596  571C     SUBFWB 0x1C, F, BANKED
14:            	if(f2 &  0x80000000UL)
7598  AF20     BTFSS 0x20, 7, BANKED
759A  EFD1     GOTO 0x75A2
759C  F03A     NOP
759E  EFD3     GOTO 0x75A6
75A0  F03A     NOP
75A2  EFDC     GOTO 0x75B8
75A4  F03A     NOP
15:            		f2 = 0x80000000UL - f2;
75A6  6D1D     NEGF 0x1D, BANKED
75A8  1F1E     COMF 0x1E, F, BANKED
75AA  B0D8     BTFSC 0xFD8, 0, ACCESS
75AC  2B1E     INCF 0x1E, F, BANKED
75AE  1F1F     COMF 0x1F, F, BANKED
75B0  B0D8     BTFSC 0xFD8, 0, ACCESS
75B2  2B1F     INCF 0x1F, F, BANKED
75B4  0E80     MOVLW 0x80
75B6  5720     SUBFWB 0x20, F, BANKED
16:            	f1 ^= 0x80000000UL;
75B8  0E00     MOVLW 0x0
75BA  1B19     XORWF 0x19, F, BANKED
75BC  0E00     MOVLW 0x0
75BE  1B1A     XORWF 0x1A, F, BANKED
75C0  0E00     MOVLW 0x0
75C2  1B1B     XORWF 0x1B, F, BANKED
75C4  0E80     MOVLW 0x80
75C6  1B1C     XORWF 0x1C, F, BANKED
17:            	f2 ^= 0x80000000UL;
75C8  0E00     MOVLW 0x0
75CA  1B1D     XORWF 0x1D, F, BANKED
75CC  0E00     MOVLW 0x0
75CE  1B1E     XORWF 0x1E, F, BANKED
75D0  0E00     MOVLW 0x0
75D2  1B1F     XORWF 0x1F, F, BANKED
75D4  0E80     MOVLW 0x80
75D6  1B20     XORWF 0x20, F, BANKED
18:            	return f1 >= f2;
75D8  511D     MOVF 0x1D, W, BANKED
75DA  5D19     SUBWF 0x19, W, BANKED
75DC  511E     MOVF 0x1E, W, BANKED
75DE  591A     SUBWFB 0x1A, W, BANKED
75E0  511F     MOVF 0x1F, W, BANKED
75E2  591B     SUBWFB 0x1B, W, BANKED
75E4  5120     MOVF 0x20, W, BANKED
75E6  591C     SUBWFB 0x1C, W, BANKED
75E8  B0D8     BTFSC 0xFD8, 0, ACCESS
75EA  EFF9     GOTO 0x75F2
75EC  F03A     NOP
75EE  EFFB     GOTO 0x75F6
75F0  F03A     NOP
75F2  EFFE     GOTO 0x75FC
75F4  F03A     NOP
75F6  90D8     BCF 0xFD8, 0, ACCESS
75F8  EFFF     GOTO 0x75FE
75FA  F03A     NOP
75FC  80D8     BSF 0xFD8, 0, ACCESS
19:            }
75FE  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/fleq.c  --------------------------
1:             #define	f1	(*(unsigned long *)&ff1)
2:             #define	f2	(*(unsigned long *)&ff2)
3:             __bit
4:             __fleq(double ff1, double ff2)
5:             {
6:                     // flush denorms and zeroes to +ve 0.0
7:                     if((f1 &  0x7F800000UL)== 0)
796A  0E00     MOVLW 0x0
796C  0106     MOVLB 0x6
796E  1500     ANDWF txData, W, BANKED
7970  6F08     MOVWF 0x8, BANKED
7972  0E00     MOVLW 0x0
7974  1501     ANDWF 0x1, W, BANKED
7976  6F09     MOVWF 0x9, BANKED
7978  0E80     MOVLW 0x80
797A  1502     ANDWF 0x2, W, BANKED
797C  6F0A     MOVWF 0xA, BANKED
797E  0E7F     MOVLW 0x7F
7980  1503     ANDWF 0x3, W, BANKED
7982  6F0B     MOVWF 0xB, BANKED
7984  5108     MOVF 0x8, W, BANKED
7986  1109     IORWF 0x9, W, BANKED
7988  110A     IORWF 0xA, W, BANKED
798A  110B     IORWF 0xB, W, BANKED
798C  A4D8     BTFSS 0xFD8, 2, ACCESS
798E  EFCB     GOTO 0x7996
7990  F03C     NOP
7992  EFCD     GOTO 0x799A
7994  F03C     NOP
7996  EFD5     GOTO 0x79AA
7998  F03C     NOP
8:             		f1 = 0x00000000UL;
799A  0E00     MOVLW 0x0
799C  6F00     MOVWF txData, BANKED
799E  0E00     MOVLW 0x0
79A0  6F01     MOVWF 0x1, BANKED
79A2  0E00     MOVLW 0x0
79A4  6F02     MOVWF 0x2, BANKED
79A6  0E00     MOVLW 0x0
79A8  6F03     MOVWF 0x3, BANKED
9:             	if((f2 &  0x7F800000UL)== 0)
79AA  0E00     MOVLW 0x0
79AC  1504     ANDWF 0x4, W, BANKED
79AE  6F08     MOVWF 0x8, BANKED
79B0  0E00     MOVLW 0x0
79B2  1505     ANDWF 0x5, W, BANKED
79B4  6F09     MOVWF 0x9, BANKED
79B6  0E80     MOVLW 0x80
79B8  1506     ANDWF 0x6, W, BANKED
79BA  6F0A     MOVWF 0xA, BANKED
79BC  0E7F     MOVLW 0x7F
79BE  1507     ANDWF 0x7, W, BANKED
79C0  6F0B     MOVWF 0xB, BANKED
79C2  5108     MOVF 0x8, W, BANKED
79C4  1109     IORWF 0x9, W, BANKED
79C6  110A     IORWF 0xA, W, BANKED
79C8  110B     IORWF 0xB, W, BANKED
79CA  A4D8     BTFSS 0xFD8, 2, ACCESS
79CC  EFEA     GOTO 0x79D4
79CE  F03C     NOP
79D0  EFEC     GOTO 0x79D8
79D2  F03C     NOP
79D4  EFF4     GOTO 0x79E8
79D6  F03C     NOP
10:            	        f2 = 0x00000000UL;
79D8  0E00     MOVLW 0x0
79DA  6F04     MOVWF 0x4, BANKED
79DC  0E00     MOVLW 0x0
79DE  6F05     MOVWF 0x5, BANKED
79E0  0E00     MOVLW 0x0
79E2  6F06     MOVWF 0x6, BANKED
79E4  0E00     MOVLW 0x0
79E6  6F07     MOVWF 0x7, BANKED
11:            	return f1 == f2;
79E8  5104     MOVF 0x4, W, BANKED
79EA  1900     XORWF txData, W, BANKED
79EC  E10F     BNZ 0x7A0C
79EE  5105     MOVF 0x5, W, BANKED
79F0  1901     XORWF 0x1, W, BANKED
79F2  E10C     BNZ 0x7A0C
79F4  5106     MOVF 0x6, W, BANKED
79F6  1902     XORWF 0x2, W, BANKED
79F8  E109     BNZ 0x7A0C
79FA  5107     MOVF 0x7, W, BANKED
79FC  1903     XORWF 0x3, W, BANKED
79FE  B4D8     BTFSC 0xFD8, 2, ACCESS
7A00  EF04     GOTO 0x7A08
7A02  F03D     NOP
7A04  EF06     GOTO 0x7A0C
7A06  F03D     NOP
7A08  EF09     GOTO 0x7A12
7A0A  F03D     NOP
7A0C  90D8     BCF 0xFD8, 0, ACCESS
7A0E  EF0A     GOTO 0x7A14
7A10  F03D     NOP
7A12  80D8     BSF 0xFD8, 0, ACCESS
12:            }
7A14  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/doprnt.c  ------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
7704  0106     MOVLB 0x6
7706  A1B5     BTFSS SCANPR, 0, BANKED
7708  EF88     GOTO 0x7710
770A  F03B     NOP
770C  EF8A     GOTO 0x7714
770E  F03B     NOP
7710  EF98     GOTO 0x7730
7712  F03B     NOP
78:                    fputs((const char *)buf, fp);
7716  F850     NOP
7718  F60B     NOP
771C  F854     NOP
771E  F60C     NOP
7722  F848     NOP
7724  F60D     NOP
7728  F84C     NOP
772A  F60E     NOP
772C  ECEF     CALL 0x81DE, 0
772E  F040     NOP
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
7730  0106     MOVLB 0x6
7732  BF17     BTFSC 0x17, 7, BANKED
7734  EF9E     GOTO 0x773C
7736  F03B     NOP
7738  EFA0     GOTO 0x7740
773A  F03B     NOP
773C  EFA8     GOTO 0x7750
773E  F03B     NOP
7742  F858     NOP
7744  F61B     NOP
7748  F85C     NOP
774A  F61C     NOP
774C  EFAC     GOTO 0x7758
774E  F03B     NOP
7750  0E00     MOVLW 0x0
7752  6F1C     MOVWF 0x1C, BANKED
7754  0E00     MOVLW 0x0
7756  6F1B     MOVWF 0x1B, BANKED
83:                i = 0;
7758  0E00     MOVLW 0x0
775A  6F1A     MOVWF 0x1A, BANKED
775C  0E00     MOVLW 0x0
775E  6F19     MOVWF 0x19, BANKED
84:                while (i < w) {
7760  EFC1     GOTO 0x7782
7762  F03B     NOP
7782  511B     MOVF 0x1B, W, BANKED
7784  5D19     SUBWF 0x19, W, BANKED
7786  511A     MOVF 0x1A, W, BANKED
7788  0A80     XORLW 0x80
778A  6F18     MOVWF 0x18, BANKED
778C  511C     MOVF 0x1C, W, BANKED
778E  0A80     XORLW 0x80
7790  5918     SUBWFB 0x18, W, BANKED
7792  A0D8     BTFSS 0xFD8, 0, ACCESS
7794  EFCE     GOTO 0x779C
7796  F03B     NOP
7798  EFD0     GOTO 0x77A0
779A  F03B     NOP
779C  EFB2     GOTO 0x7764
779E  F03B     NOP
85:                    fputc(' ', fp);
7764  0E00     MOVLW 0x0
7766  6F03     MOVWF 0x3, BANKED
7768  0E20     MOVLW 0x20
776A  6F02     MOVWF 0x2, BANKED
776E  F848     NOP
7770  F604     NOP
7774  F84C     NOP
7776  F605     NOP
7778  EC5F     CALL 0x7ABE, 0
777A  F03D     NOP
86:                    ++i;
777C  0106     MOVLB 0x6
777E  4B19     INFSNZ 0x19, F, BANKED
7780  2B1A     INCF 0x1A, F, BANKED
87:                }
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
77A0  B1B5     BTFSC SCANPR, 0, BANKED
77A2  EFD5     GOTO 0x77AA
77A4  F03B     NOP
77A6  EFD7     GOTO 0x77AE
77A8  F03B     NOP
77AA  EFE5     GOTO 0x77CA
77AC  F03B     NOP
91:                    fputs((const char *)buf, fp);
77B0  F850     NOP
77B2  F60B     NOP
77B6  F854     NOP
77B8  F60C     NOP
77BC  F848     NOP
77BE  F60D     NOP
77C2  F84C     NOP
77C4  F60E     NOP
77C6  ECEF     CALL 0x81DE, 0
77C8  F040     NOP
92:                }
93:            
94:                return strlen(buf) + w;
77CC  F850     NOP
77CE  F600     NOP
77D2  F854     NOP
77D4  F601     NOP
77D6  EC5E     CALL 0x82BC, 0
77D8  F041     NOP
77DA  0106     MOVLB 0x6
77DC  511B     MOVF 0x1B, W, BANKED
77DE  2500     ADDWF txData, W, BANKED
77E0  6F12     MOVWF 0x12, BANKED
77E2  511C     MOVF 0x1C, W, BANKED
77E4  2101     ADDWFC 0x1, W, BANKED
77E6  6F13     MOVWF 0x13, BANKED
95:            }
77E8  0012     RETURN 0
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? '0' + d : 'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
265:           
266:               /* Put out padded string */
267:               dbuf[0] = c;
268:               dbuf[1] = '\0';
269:               return pad(fp, &dbuf[0], w);
270:           }
271:           #endif
272:           
273:           #ifdef _VFPF_D
274:           static _INLINE int dtoa(FILE *fp, long long d)
275:           {
276:               int i, p, s, w;
277:               long long n;
278:           
279:               /* Record sign, get absolute value */
280:               n = d;
61A6  F87C     NOP
61A8  F637     NOP
61AC  F880     NOP
61AE  F638     NOP
61B2  F884     NOP
61B4  F639     NOP
61B8  F888     NOP
61BA  F63A     NOP
61BE  F88C     NOP
61C0  F63B     NOP
61C4  F890     NOP
61C6  F63C     NOP
61CA  F894     NOP
61CC  F63D     NOP
61D0  F898     NOP
61D2  F63E     NOP
281:               s = n < 0 ? 1 : 0;
61D4  0106     MOVLB 0x6
61D6  BF3E     BTFSC 0x3E, 7, BANKED
61D8  EFF0     GOTO 0x61E0
61DA  F030     NOP
61DC  EFF3     GOTO 0x61E6
61DE  F030     NOP
61E0  0E01     MOVLW 0x1
61E2  EFF4     GOTO 0x61E8
61E4  F030     NOP
61E6  0E00     MOVLW 0x0
61E8  6F35     MOVWF 0x35, BANKED
61EA  6B36     CLRF 0x36, BANKED
282:               if (s) {
61EC  5135     MOVF 0x35, W, BANKED
61EE  1136     IORWF 0x36, W, BANKED
61F0  B4D8     BTFSC 0xFD8, 2, ACCESS
61F2  EFFD     GOTO 0x61FA
61F4  F030     NOP
61F6  EFFF     GOTO 0x61FE
61F8  F030     NOP
61FA  EF0F     GOTO 0x621E
61FC  F031     NOP
283:                   n = -n;
61FE  1F3E     COMF 0x3E, F, BANKED
6200  1F3D     COMF 0x3D, F, BANKED
6202  1F3C     COMF 0x3C, F, BANKED
6204  1F3B     COMF 0x3B, F, BANKED
6206  1F3A     COMF CLKRCLK, F, BANKED
6208  1F39     COMF CLKRCON, F, BANKED
620A  1F38     COMF 0x38, F, BANKED
620C  6D37     NEGF 0x37, BANKED
620E  0E00     MOVLW 0x0
6210  2338     ADDWFC 0x38, F, BANKED
6212  2339     ADDWFC CLKRCON, F, BANKED
6214  233A     ADDWFC CLKRCLK, F, BANKED
6216  233B     ADDWFC 0x3B, F, BANKED
6218  233C     ADDWFC 0x3C, F, BANKED
621A  233D     ADDWFC 0x3D, F, BANKED
621C  233E     ADDWFC 0x3E, F, BANKED
284:               }
285:           
286:               /* Adjust flags, precision, width */
287:               if (!(prec < 0)) {
621E  BFB4     BTFSC PRLOCK, 7, BANKED
6220  EF14     GOTO 0x6228
6222  F031     NOP
6224  EF16     GOTO 0x622C
6226  F031     NOP
6228  EF17     GOTO 0x622E
622A  F031     NOP
288:                   flags &= ~ZERO_FLAG;
622C  93B5     BCF SCANPR, 1, BANKED
289:               }
290:               p = (0 < prec) ? prec : 1;
622E  BFB4     BTFSC PRLOCK, 7, BANKED
6230  EF24     GOTO 0x6248
6232  F031     NOP
6234  51B4     MOVF PRLOCK, W, BANKED
6236  E106     BNZ 0x6244
6238  05B3     DECF OSCEN, W, BANKED
623A  B0D8     BTFSC 0xFD8, 0, ACCESS
623C  EF22     GOTO 0x6244
623E  F031     NOP
6240  EF24     GOTO 0x6248
6242  F031     NOP
6244  EF2A     GOTO 0x6254
6246  F031     NOP
6248  0E00     MOVLW 0x0
624A  6F32     MOVWF 0x32, BANKED
624C  0E01     MOVLW 0x1
624E  6F31     MOVWF 0x31, BANKED
6250  EF30     GOTO 0x6260
6252  F031     NOP
6256  FACC     NOP
6258  F631     NOP
625C  FAD0     NOP
625E  F632     NOP
291:               w = width;
6262  FAC4     NOP
6264  F633     NOP
6268  FAC8     NOP
626A  F634     NOP
292:               if (s || (flags & PLUS_FLAG)) {
626C  5135     MOVF 0x35, W, BANKED
626E  1136     IORWF 0x36, W, BANKED
6270  A4D8     BTFSS 0xFD8, 2, ACCESS
6272  EF3D     GOTO 0x627A
6274  F031     NOP
6276  EF3F     GOTO 0x627E
6278  F031     NOP
627A  EF46     GOTO 0x628C
627C  F031     NOP
627E  A5B5     BTFSS SCANPR, 2, BANKED
6280  EF44     GOTO 0x6288
6282  F031     NOP
6284  EF46     GOTO 0x628C
6286  F031     NOP
6288  EF49     GOTO 0x6292
628A  F031     NOP
293:                   --w;
628C  0733     DECF 0x33, F, BANKED
628E  A0D8     BTFSS 0xFD8, 0, ACCESS
6290  0734     DECF 0x34, F, BANKED
294:               }
295:           
296:               /* Convert to decimal, possibly filling on the left with zeroes */
297:               i = sizeof(dbuf) - 1;
6292  0E00     MOVLW 0x0
6294  6F40     MOVWF NVMCON0, BANKED
6296  0E4F     MOVLW 0x4F
6298  6F3F     MOVWF 0x3F, BANKED
298:               dbuf[i] = '\0';
629A  0E00     MOVLW 0x0
629C  0107     MOVLB 0x7
629E  6F4F     MOVWF 0x4F, BANKED
299:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
62A0  EFF1     GOTO 0x63E2
62A2  F031     NOP
63E2  0106     MOVLB 0x6
63E4  BF40     BTFSC NVMCON0, 7, BANKED
63E6  EFFD     GOTO 0x63FA
63E8  F031     NOP
63EA  5140     MOVF NVMCON0, W, BANKED
63EC  E108     BNZ 0x63FE
63EE  053F     DECF 0x3F, W, BANKED
63F0  A0D8     BTFSS 0xFD8, 0, ACCESS
63F2  EFFD     GOTO 0x63FA
63F4  F031     NOP
63F6  EFFF     GOTO 0x63FE
63F8  F031     NOP
63FA  EF2F     GOTO 0x645E
63FC  F032     NOP
63FE  5137     MOVF 0x37, W, BANKED
6400  1138     IORWF 0x38, W, BANKED
6402  1139     IORWF CLKRCON, W, BANKED
6404  113A     IORWF CLKRCLK, W, BANKED
6406  113B     IORWF 0x3B, W, BANKED
6408  113C     IORWF 0x3C, W, BANKED
640A  113D     IORWF 0x3D, W, BANKED
640C  113E     IORWF 0x3E, W, BANKED
640E  A4D8     BTFSS 0xFD8, 2, ACCESS
6410  EF0C     GOTO 0x6418
6412  F032     NOP
6414  EF0E     GOTO 0x641C
6416  F032     NOP
6418  EF52     GOTO 0x62A4
641A  F031     NOP
641C  BF32     BTFSC 0x32, 7, BANKED
641E  EF1B     GOTO 0x6436
6420  F032     NOP
6422  5132     MOVF 0x32, W, BANKED
6424  E106     BNZ 0x6432
6426  0531     DECF 0x31, W, BANKED
6428  B0D8     BTFSC 0xFD8, 0, ACCESS
642A  EF19     GOTO 0x6432
642C  F032     NOP
642E  EF1B     GOTO 0x6436
6430  F032     NOP
6432  EF52     GOTO 0x62A4
6434  F031     NOP
6436  BF34     BTFSC 0x34, 7, BANKED
6438  EF26     GOTO 0x644C
643A  F032     NOP
643C  5134     MOVF 0x34, W, BANKED
643E  E108     BNZ 0x6450
6440  0533     DECF 0x33, W, BANKED
6442  A0D8     BTFSS 0xFD8, 0, ACCESS
6444  EF26     GOTO 0x644C
6446  F032     NOP
6448  EF28     GOTO 0x6450
644A  F032     NOP
644C  EF2F     GOTO 0x645E
644E  F032     NOP
6450  B3B5     BTFSC SCANPR, 1, BANKED
6452  EF2D     GOTO 0x645A
6454  F032     NOP
6456  EF2F     GOTO 0x645E
6458  F032     NOP
645A  EF52     GOTO 0x62A4
645C  F031     NOP
300:                   --i;
62A4  073F     DECF 0x3F, F, BANKED
62A6  A0D8     BTFSS 0xFD8, 0, ACCESS
62A8  0740     DECF NVMCON0, F, BANKED
301:                   dbuf[i] = '0' + abs(n % 10);
62AA  0E00     MOVLW 0x0
62AC  253F     ADDWF 0x3F, W, BANKED
62AE  6ED9     MOVWF 0xFD9, ACCESS
62B0  0E07     MOVLW 0x7
62B2  2140     ADDWFC NVMCON0, W, BANKED
62B4  6EDA     MOVWF 0xFDA, ACCESS
62B8  F8DC     NOP
62BA  F600     NOP
62BE  F8E0     NOP
62C0  F601     NOP
62C4  F8E4     NOP
62C6  F602     NOP
62CA  F8E8     NOP
62CC  F603     NOP
62D0  F8EC     NOP
62D2  F604     NOP
62D6  F8F0     NOP
62D8  F605     NOP
62DC  F8F4     NOP
62DE  F606     NOP
62E2  F8F8     NOP
62E4  F607     NOP
62E6  0E0A     MOVLW 0xA
62E8  6F08     MOVWF 0x8, BANKED
62EA  0E00     MOVLW 0x0
62EC  6F09     MOVWF 0x9, BANKED
62EE  0E00     MOVLW 0x0
62F0  6F0A     MOVWF 0xA, BANKED
62F2  0E00     MOVLW 0x0
62F4  6F0B     MOVWF 0xB, BANKED
62F6  0E00     MOVLW 0x0
62F8  6F0C     MOVWF 0xC, BANKED
62FA  0E00     MOVLW 0x0
62FC  6F0D     MOVWF 0xD, BANKED
62FE  0E00     MOVLW 0x0
6300  6F0E     MOVWF 0xE, BANKED
6302  0E00     MOVLW 0x0
6304  6F0F     MOVWF 0xF, BANKED
6306  EC6D     CALL 0x6EDA, 0
6308  F037     NOP
630C  F800     NOP
630E  F627     NOP
6312  F804     NOP
6314  F628     NOP
6318  F808     NOP
631A  F629     NOP
631E  F80C     NOP
6320  F62A     NOP
6324  F810     NOP
6326  F62B     NOP
632A  F814     NOP
632C  F62C     NOP
6330  F818     NOP
6332  F62D     NOP
6336  F81C     NOP
6338  F62E     NOP
633C  F89C     NOP
633E  F612     NOP
6342  F8A4     NOP
6344  F613     NOP
6346  EC16     CALL 0x822C, 0
6348  F041     NOP
634A  0106     MOVLB 0x6
634C  5112     MOVF 0x12, W, BANKED
634E  0F30     ADDLW 0x30
6350  6EDF     MOVWF 0xFDF, ACCESS
302:                   --p;
6352  0731     DECF 0x31, F, BANKED
6354  A0D8     BTFSS 0xFD8, 0, ACCESS
6356  0732     DECF 0x32, F, BANKED
303:                   --w;
6358  0733     DECF 0x33, F, BANKED
635A  A0D8     BTFSS 0xFD8, 0, ACCESS
635C  0734     DECF 0x34, F, BANKED
304:                   n = n / 10;
6360  F8DC     NOP
6362  F600     NOP
6366  F8E0     NOP
6368  F601     NOP
636C  F8E4     NOP
636E  F602     NOP
6372  F8E8     NOP
6374  F603     NOP
6378  F8EC     NOP
637A  F604     NOP
637E  F8F0     NOP
6380  F605     NOP
6384  F8F4     NOP
6386  F606     NOP
638A  F8F8     NOP
638C  F607     NOP
638E  0E0A     MOVLW 0xA
6390  6F08     MOVWF 0x8, BANKED
6392  0E00     MOVLW 0x0
6394  6F09     MOVWF 0x9, BANKED
6396  0E00     MOVLW 0x0
6398  6F0A     MOVWF 0xA, BANKED
639A  0E00     MOVLW 0x0
639C  6F0B     MOVWF 0xB, BANKED
639E  0E00     MOVLW 0x0
63A0  6F0C     MOVWF 0xC, BANKED
63A2  0E00     MOVLW 0x0
63A4  6F0D     MOVWF 0xD, BANKED
63A6  0E00     MOVLW 0x0
63A8  6F0E     MOVWF 0xE, BANKED
63AA  0E00     MOVLW 0x0
63AC  6F0F     MOVWF 0xF, BANKED
63AE  ECA0     CALL 0x6D40, 0
63B0  F036     NOP
63B4  F800     NOP
63B6  F637     NOP
63BA  F804     NOP
63BC  F638     NOP
63C0  F808     NOP
63C2  F639     NOP
63C6  F80C     NOP
63C8  F63A     NOP
63CC  F810     NOP
63CE  F63B     NOP
63D2  F814     NOP
63D4  F63C     NOP
63D8  F818     NOP
63DA  F63D     NOP
63DE  F81C     NOP
63E0  F63E     NOP
305:               }
306:           
307:               /* Display sign if required */
308:               if (s || (flags & PLUS_FLAG)) {
645E  5135     MOVF 0x35, W, BANKED
6460  1136     IORWF 0x36, W, BANKED
6462  A4D8     BTFSS 0xFD8, 2, ACCESS
6464  EF36     GOTO 0x646C
6466  F032     NOP
6468  EF38     GOTO 0x6470
646A  F032     NOP
646C  EF3F     GOTO 0x647E
646E  F032     NOP
6470  A5B5     BTFSS SCANPR, 2, BANKED
6472  EF3D     GOTO 0x647A
6474  F032     NOP
6476  EF3F     GOTO 0x647E
6478  F032     NOP
647A  EF5E     GOTO 0x64BC
647C  F032     NOP
309:                   --i;
647E  073F     DECF 0x3F, F, BANKED
6480  A0D8     BTFSS 0xFD8, 0, ACCESS
6482  0740     DECF NVMCON0, F, BANKED
310:                   dbuf[i] = s ? '-' : '+';
6484  5135     MOVF 0x35, W, BANKED
6486  1136     IORWF 0x36, W, BANKED
6488  A4D8     BTFSS 0xFD8, 2, ACCESS
648A  EF49     GOTO 0x6492
648C  F032     NOP
648E  EF4B     GOTO 0x6496
6490  F032     NOP
6492  EF51     GOTO 0x64A2
6494  F032     NOP
6496  0E00     MOVLW 0x0
6498  6F30     MOVWF 0x30, BANKED
649A  0E2B     MOVLW 0x2B
649C  6F2F     MOVWF 0x2F, BANKED
649E  EF55     GOTO 0x64AA
64A0  F032     NOP
64A2  0E00     MOVLW 0x0
64A4  6F30     MOVWF 0x30, BANKED
64A6  0E2D     MOVLW 0x2D
64A8  6F2F     MOVWF 0x2F, BANKED
64AA  0E00     MOVLW 0x0
64AC  253F     ADDWF 0x3F, W, BANKED
64AE  6ED9     MOVWF 0xFD9, ACCESS
64B0  0E07     MOVLW 0x7
64B2  2140     ADDWFC NVMCON0, W, BANKED
64B4  6EDA     MOVWF 0xFDA, ACCESS
64B8  F8BC     NOP
64BA  F4DF     NOP
311:               }
312:           
313:               /* Put out padded string */
314:               return pad(fp, &dbuf[i], w);
64BE  F874     NOP
64C0  F612     NOP
64C4  F878     NOP
64C6  F613     NOP
64C8  0E00     MOVLW 0x0
64CA  253F     ADDWF 0x3F, W, BANKED
64CC  6F14     MOVWF 0x14, BANKED
64CE  0E07     MOVLW 0x7
64D0  2140     ADDWFC NVMCON0, W, BANKED
64D2  6F15     MOVWF 0x15, BANKED
64D6  F8CC     NOP
64D8  F616     NOP
64DC  F8D0     NOP
64DE  F617     NOP
64E0  EC82     CALL 0x7704, 0
64E2  F03B     NOP
64E6  F848     NOP
64E8  F61D     NOP
64EC  F84C     NOP
64EE  F61E     NOP
315:           }
64F0  0012     RETURN 0
316:           #endif
317:           
318:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
319:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
320:           {
321:               char mode, nmode;
322:               int d, e, i, m, n, ne, p, pp, sign, t, w;
323:               long double g, h, l, ou, u;
324:           
325:               /* Record sign, get absolute value */
326:               sign = 0;
255C  0E00     MOVLW 0x0
255E  0106     MOVLB 0x6
2560  6F54     MOVWF 0x54, BANKED
2562  0E00     MOVLW 0x0
2564  6F53     MOVWF 0x53, BANKED
327:               g = f;
2568  F8BC     NOP
256A  F665     NOP
256E  F8C0     NOP
2570  F666     NOP
2574  F8C4     NOP
2576  F667     NOP
257A  F8C8     NOP
257C  F668     NOP
328:               if (g < 0.0) {
257E  BF68     BTFSC PMD8, 7, BANKED
2580  EFC6     GOTO 0x258C
2582  F012     NOP
2584  EFC4     GOTO 0x2588
2586  F012     NOP
2588  EFE4     GOTO 0x25C8
258A  F012     NOP
329:                   sign = 1;
258C  0E00     MOVLW 0x0
258E  6F54     MOVWF 0x54, BANKED
2590  0E01     MOVLW 0x1
2592  6F53     MOVWF 0x53, BANKED
330:                   g = -g;
2596  F994     NOP
2598  F600     NOP
259C  F998     NOP
259E  F601     NOP
25A2  F99C     NOP
25A4  F602     NOP
25A8  F9A0     NOP
25AA  F603     NOP
25AC  EC3D     CALL 0x827A, 0
25AE  F041     NOP
25B2  F800     NOP
25B4  F665     NOP
25B8  F804     NOP
25BA  F666     NOP
25BE  F808     NOP
25C0  F667     NOP
25C4  F80C     NOP
25C6  F668     NOP
331:               }
332:           
333:               /* Print sign */
334:               n = 0;
25C8  0E00     MOVLW 0x0
25CA  0106     MOVLB 0x6
25CC  6F6C     MOVWF MD1SRC, BANKED
25CE  0E00     MOVLW 0x0
25D0  6F6B     MOVWF MD1CON1, BANKED
335:               w = width;
25D4  FAC4     NOP
25D6  F658     NOP
25DA  FAC8     NOP
25DC  F659     NOP
336:               if (sign || (flags & PLUS_FLAG)) {
25DE  5153     MOVF 0x53, W, BANKED
25E0  1154     IORWF 0x54, W, BANKED
25E2  A4D8     BTFSS 0xFD8, 2, ACCESS
25E4  EFF6     GOTO 0x25EC
25E6  F012     NOP
25E8  EFF8     GOTO 0x25F0
25EA  F012     NOP
25EC  EFFF     GOTO 0x25FE
25EE  F012     NOP
25F0  A5B5     BTFSS SCANPR, 2, BANKED
25F2  EFFD     GOTO 0x25FA
25F4  F012     NOP
25F6  EFFF     GOTO 0x25FE
25F8  F012     NOP
25FA  EF1A     GOTO 0x2634
25FC  F013     NOP
337:                   dbuf[n] = sign ? '-' : '+';
25FE  5153     MOVF 0x53, W, BANKED
2600  1154     IORWF 0x54, W, BANKED
2602  A4D8     BTFSS 0xFD8, 2, ACCESS
2604  EF06     GOTO 0x260C
2606  F013     NOP
2608  EF08     GOTO 0x2610
260A  F013     NOP
260C  EF0E     GOTO 0x261C
260E  F013     NOP
2610  0E00     MOVLW 0x0
2612  6F3E     MOVWF 0x3E, BANKED
2614  0E2B     MOVLW 0x2B
2616  6F3D     MOVWF 0x3D, BANKED
2618  EF12     GOTO 0x2624
261A  F013     NOP
261C  0E00     MOVLW 0x0
261E  6F3E     MOVWF 0x3E, BANKED
2620  0E2D     MOVLW 0x2D
2622  6F3D     MOVWF 0x3D, BANKED
2626  F8F4     NOP
2628  F700     NOP
338:                   ++n;
262A  4B6B     INFSNZ MD1CON1, F, BANKED
262C  2B6C     INCF MD1SRC, F, BANKED
339:                   --w;
262E  0758     DECF 0x58, F, BANKED
2630  A0D8     BTFSS 0xFD8, 0, ACCESS
2632  0759     DECF 0x59, F, BANKED
340:               }
341:           
342:               /* Catch infinities, NaNs here */
343:               if (isinf(g)) {
2636  F994     NOP
2638  F600     NOP
263C  F998     NOP
263E  F601     NOP
2642  F99C     NOP
2644  F602     NOP
2648  F9A0     NOP
264A  F603     NOP
264C  ECD7     CALL 0x71AE, 0
264E  F038     NOP
2650  0106     MOVLB 0x6
2652  0500     DECF txData, W, BANKED
2654  1101     IORWF 0x1, W, BANKED
2656  A4D8     BTFSS 0xFD8, 2, ACCESS
2658  EF30     GOTO 0x2660
265A  F013     NOP
265C  EF32     GOTO 0x2664
265E  F013     NOP
2660  EF8E     GOTO 0x271C
2662  F013     NOP
344:                   if (isupper((int)c)) {
2664  0EBF     MOVLW 0xBF
2666  6F34     MOVWF 0x34, BANKED
2668  0EFF     MOVLW 0xFF
266A  6F35     MOVWF 0x35, BANKED
266C  5133     MOVF 0x33, W, BANKED
266E  6F36     MOVWF 0x36, BANKED
2670  6B37     CLRF 0x37, BANKED
2672  5134     MOVF 0x34, W, BANKED
2674  2736     ADDWF 0x36, F, BANKED
2676  5135     MOVF 0x35, W, BANKED
2678  2337     ADDWFC 0x37, F, BANKED
267A  5137     MOVF 0x37, W, BANKED
267C  E10A     BNZ 0x2692
267E  0E1A     MOVLW 0x1A
2680  5D36     SUBWF 0x36, W, BANKED
2682  A0D8     BTFSS 0xFD8, 0, ACCESS
2684  EF46     GOTO 0x268C
2686  F013     NOP
2688  EF49     GOTO 0x2692
268A  F013     NOP
268C  0E01     MOVLW 0x1
268E  EF4A     GOTO 0x2694
2690  F013     NOP
2692  0E00     MOVLW 0x0
2694  6F3F     MOVWF 0x3F, BANKED
2696  6B40     CLRF NVMCON0, BANKED
2698  513F     MOVF 0x3F, W, BANKED
269A  1140     IORWF NVMCON0, W, BANKED
269C  B4D8     BTFSC 0xFD8, 2, ACCESS
269E  EF53     GOTO 0x26A6
26A0  F013     NOP
26A2  EF55     GOTO 0x26AA
26A4  F013     NOP
26A6  EF63     GOTO 0x26C6
26A8  F013     NOP
345:                       strcpy(&dbuf[n], "INF");
26AA  0E00     MOVLW 0x0
26AC  256B     ADDWF MD1CON1, W, BANKED
26AE  6F00     MOVWF txData, BANKED
26B0  0E07     MOVLW 0x7
26B2  216C     ADDWFC MD1SRC, W, BANKED
26B4  6F01     MOVWF 0x1, BANKED
26B6  0E47     MOVLW 0x47
26B8  6F02     MOVWF 0x2, BANKED
26BA  0E25     MOVLW 0x25
26BC  6F03     MOVWF 0x3, BANKED
26BE  ECC7     CALL 0x7F8E, 0
26C0  F03F     NOP
346:                   } else {
26C2  EF6F     GOTO 0x26DE
26C4  F013     NOP
347:                       strcpy(&dbuf[n], "inf");
26C6  0E00     MOVLW 0x0
26C8  256B     ADDWF MD1CON1, W, BANKED
26CA  6F00     MOVWF txData, BANKED
26CC  0E07     MOVLW 0x7
26CE  216C     ADDWFC MD1SRC, W, BANKED
26D0  6F01     MOVWF 0x1, BANKED
26D2  0E4F     MOVLW 0x4F
26D4  6F02     MOVWF 0x2, BANKED
26D6  0E25     MOVLW 0x25
26D8  6F03     MOVWF 0x3, BANKED
26DA  ECC7     CALL 0x7F8E, 0
26DC  F03F     NOP
348:                   }
349:                   w -= CSTRLEN("inf");
26DE  0106     MOVLB 0x6
26E0  0EFD     MOVLW 0xFD
26E2  2758     ADDWF 0x58, F, BANKED
26E4  0EFF     MOVLW 0xFF
26E6  2359     ADDWFC 0x59, F, BANKED
350:                   return pad(fp, &dbuf[0], w);
26EA  F8B4     NOP
26EC  F612     NOP
26F0  F8B8     NOP
26F2  F613     NOP
26F4  0E00     MOVLW 0x0
26F6  6F14     MOVWF 0x14, BANKED
26F8  0E07     MOVLW 0x7
26FA  6F15     MOVWF 0x15, BANKED
26FE  F960     NOP
2700  F616     NOP
2704  F964     NOP
2706  F617     NOP
2708  EC82     CALL 0x7704, 0
270A  F03B     NOP
270E  F848     NOP
2710  F62D     NOP
2714  F84C     NOP
2716  F62E     NOP
2718  EFA9     GOTO 0x3352
271A  F019     NOP
351:               }
352:               if (isnan(g)) {
271E  F994     NOP
2720  F600     NOP
2724  F998     NOP
2726  F601     NOP
272A  F99C     NOP
272C  F602     NOP
2730  F9A0     NOP
2732  F603     NOP
2734  ECD7     CALL 0x71AE, 0
2736  F038     NOP
2738  0106     MOVLB 0x6
273A  5100     MOVF txData, W, BANKED
273C  1101     IORWF 0x1, W, BANKED
273E  A4D8     BTFSS 0xFD8, 2, ACCESS
2740  EFA4     GOTO 0x2748
2742  F013     NOP
2744  EFA6     GOTO 0x274C
2746  F013     NOP
2748  EF02     GOTO 0x2804
274A  F014     NOP
353:                   if (isupper((int)c)) {
274C  0EBF     MOVLW 0xBF
274E  6F34     MOVWF 0x34, BANKED
2750  0EFF     MOVLW 0xFF
2752  6F35     MOVWF 0x35, BANKED
2754  5133     MOVF 0x33, W, BANKED
2756  6F36     MOVWF 0x36, BANKED
2758  6B37     CLRF 0x37, BANKED
275A  5134     MOVF 0x34, W, BANKED
275C  2736     ADDWF 0x36, F, BANKED
275E  5135     MOVF 0x35, W, BANKED
2760  2337     ADDWFC 0x37, F, BANKED
2762  5137     MOVF 0x37, W, BANKED
2764  E10A     BNZ 0x277A
2766  0E1A     MOVLW 0x1A
2768  5D36     SUBWF 0x36, W, BANKED
276A  A0D8     BTFSS 0xFD8, 0, ACCESS
276C  EFBA     GOTO 0x2774
276E  F013     NOP
2770  EFBD     GOTO 0x277A
2772  F013     NOP
2774  0E01     MOVLW 0x1
2776  EFBE     GOTO 0x277C
2778  F013     NOP
277A  0E00     MOVLW 0x0
277C  6F41     MOVWF NVMCON1, BANKED
277E  6B42     CLRF NVMLOCK, BANKED
2780  5141     MOVF NVMCON1, W, BANKED
2782  1142     IORWF NVMLOCK, W, BANKED
2784  B4D8     BTFSC 0xFD8, 2, ACCESS
2786  EFC7     GOTO 0x278E
2788  F013     NOP
278A  EFC9     GOTO 0x2792
278C  F013     NOP
278E  EFD7     GOTO 0x27AE
2790  F013     NOP
354:                       strcpy(&dbuf[n], "NAN");
2792  0E00     MOVLW 0x0
2794  256B     ADDWF MD1CON1, W, BANKED
2796  6F00     MOVWF txData, BANKED
2798  0E07     MOVLW 0x7
279A  216C     ADDWFC MD1SRC, W, BANKED
279C  6F01     MOVWF 0x1, BANKED
279E  0E4B     MOVLW 0x4B
27A0  6F02     MOVWF 0x2, BANKED
27A2  0E25     MOVLW 0x25
27A4  6F03     MOVWF 0x3, BANKED
27A6  ECC7     CALL 0x7F8E, 0
27A8  F03F     NOP
355:                   } else {
27AA  EFE3     GOTO 0x27C6
27AC  F013     NOP
356:                       strcpy(&dbuf[n], "nan");
27AE  0E00     MOVLW 0x0
27B0  256B     ADDWF MD1CON1, W, BANKED
27B2  6F00     MOVWF txData, BANKED
27B4  0E07     MOVLW 0x7
27B6  216C     ADDWFC MD1SRC, W, BANKED
27B8  6F01     MOVWF 0x1, BANKED
27BA  0E53     MOVLW 0x53
27BC  6F02     MOVWF 0x2, BANKED
27BE  0E25     MOVLW 0x25
27C0  6F03     MOVWF 0x3, BANKED
27C2  ECC7     CALL 0x7F8E, 0
27C4  F03F     NOP
357:                   }
358:                   w -= CSTRLEN("inf");
27C6  0106     MOVLB 0x6
27C8  0EFD     MOVLW 0xFD
27CA  2758     ADDWF 0x58, F, BANKED
27CC  0EFF     MOVLW 0xFF
27CE  2359     ADDWFC 0x59, F, BANKED
359:                   return pad(fp, &dbuf[0], w);
27D2  F8B4     NOP
27D4  F612     NOP
27D8  F8B8     NOP
27DA  F613     NOP
27DC  0E00     MOVLW 0x0
27DE  6F14     MOVWF 0x14, BANKED
27E0  0E07     MOVLW 0x7
27E2  6F15     MOVWF 0x15, BANKED
27E6  F960     NOP
27E8  F616     NOP
27EC  F964     NOP
27EE  F617     NOP
27F0  EC82     CALL 0x7704, 0
27F2  F03B     NOP
27F6  F848     NOP
27F8  F62D     NOP
27FC  F84C     NOP
27FE  F62E     NOP
2800  EFA9     GOTO 0x3352
2802  F019     NOP
360:               }
361:           
362:               /* First find the largest power of 10 not larger than number to print */
363:               u = 1.0;
2804  0E00     MOVLW 0x0
2806  6F6D     MOVWF MD1CARL, BANKED
2808  0E00     MOVLW 0x0
280A  6F6E     MOVWF MD1CARH, BANKED
280C  0E80     MOVLW 0x80
280E  6F6F     MOVWF CMOUT, BANKED
2810  0E3F     MOVLW 0x3F
2812  6F70     MOVWF CM1CON0, BANKED
364:               e = 0;
2814  0E00     MOVLW 0x0
2816  6F6A     MOVWF MD1CON0, BANKED
2818  0E00     MOVLW 0x0
281A  6F69     MOVWF 0x69, BANKED
365:               if (!(g == 0.0)) {
281E  F994     NOP
2820  F600     NOP
2824  F998     NOP
2826  F601     NOP
282A  F99C     NOP
282C  F602     NOP
2830  F9A0     NOP
2832  F603     NOP
2834  0E00     MOVLW 0x0
2836  6F04     MOVWF 0x4, BANKED
2838  0E00     MOVLW 0x0
283A  6F05     MOVWF 0x5, BANKED
283C  0E00     MOVLW 0x0
283E  6F06     MOVWF 0x6, BANKED
2840  0E00     MOVLW 0x0
2842  6F07     MOVWF 0x7, BANKED
2844  ECB5     CALL 0x796A, 0
2846  F03C     NOP
2848  0106     MOVLB 0x6
284A  B0D8     BTFSC 0xFD8, 0, ACCESS
284C  EF2A     GOTO 0x2854
284E  F014     NOP
2850  EF2C     GOTO 0x2858
2852  F014     NOP
2854  EFD5     GOTO 0x29AA
2856  F014     NOP
2858  EF53     GOTO 0x28A6
285A  F014     NOP
366:                   while (!(g < (u*10.0))) {
28A8  F994     NOP
28AA  F619     NOP
28AE  F998     NOP
28B0  F61A     NOP
28B4  F99C     NOP
28B6  F61B     NOP
28BA  F9A0     NOP
28BC  F61C     NOP
28BE  0E00     MOVLW 0x0
28C0  6F04     MOVWF 0x4, BANKED
28C2  0E00     MOVLW 0x0
28C4  6F05     MOVWF 0x5, BANKED
28C6  0E20     MOVLW 0x20
28C8  6F06     MOVWF 0x6, BANKED
28CA  0E41     MOVLW 0x41
28CC  6F07     MOVWF 0x7, BANKED
28D0  F9B4     NOP
28D2  F600     NOP
28D6  F9B8     NOP
28D8  F601     NOP
28DC  F9BC     NOP
28DE  F602     NOP
28E2  F9C0     NOP
28E4  F603     NOP
28E6  EC88     CALL 0x5110, 0
28E8  F028     NOP
28EC  F800     NOP
28EE  F61D     NOP
28F2  F804     NOP
28F4  F61E     NOP
28F8  F808     NOP
28FA  F61F     NOP
28FE  F80C     NOP
2900  F620     NOP
2902  EC7D     CALL 0x74FA, 0
2904  F03A     NOP
2906  0106     MOVLB 0x6
2908  B0D8     BTFSC 0xFD8, 0, ACCESS
290A  EF89     GOTO 0x2912
290C  F014     NOP
290E  EF8B     GOTO 0x2916
2910  F014     NOP
2912  EF2E     GOTO 0x285C
2914  F014     NOP
2916  EFB3     GOTO 0x2966
2918  F014     NOP
367:                       u = u*10.0;
285E  F9B4     NOP
2860  F600     NOP
2864  F9B8     NOP
2866  F601     NOP
286A  F9BC     NOP
286C  F602     NOP
2870  F9C0     NOP
2872  F603     NOP
2874  0E00     MOVLW 0x0
2876  6F04     MOVWF 0x4, BANKED
2878  0E00     MOVLW 0x0
287A  6F05     MOVWF 0x5, BANKED
287C  0E20     MOVLW 0x20
287E  6F06     MOVWF 0x6, BANKED
2880  0E41     MOVLW 0x41
2882  6F07     MOVWF 0x7, BANKED
2884  EC88     CALL 0x5110, 0
2886  F028     NOP
288A  F800     NOP
288C  F66D     NOP
2890  F804     NOP
2892  F66E     NOP
2896  F808     NOP
2898  F66F     NOP
289C  F80C     NOP
289E  F670     NOP
368:                       ++e;
28A0  0106     MOVLB 0x6
28A2  4B69     INFSNZ 0x69, F, BANKED
28A4  2B6A     INCF MD1CON0, F, BANKED
369:                   }
370:                   while (g < u) {
2968  F994     NOP
296A  F619     NOP
296E  F998     NOP
2970  F61A     NOP
2974  F99C     NOP
2976  F61B     NOP
297A  F9A0     NOP
297C  F61C     NOP
2980  F9B4     NOP
2982  F61D     NOP
2986  F9B8     NOP
2988  F61E     NOP
298C  F9BC     NOP
298E  F61F     NOP
2992  F9C0     NOP
2994  F620     NOP
2996  EC7D     CALL 0x74FA, 0
2998  F03A     NOP
299A  0106     MOVLB 0x6
299C  A0D8     BTFSS 0xFD8, 0, ACCESS
299E  EFD3     GOTO 0x29A6
29A0  F014     NOP
29A2  EFD5     GOTO 0x29AA
29A4  F014     NOP
29A6  EF8D     GOTO 0x291A
29A8  F014     NOP
371:                       u = u/10.0;
291C  F9B4     NOP
291E  F600     NOP
2922  F9B8     NOP
2924  F601     NOP
2928  F9BC     NOP
292A  F602     NOP
292E  F9C0     NOP
2930  F603     NOP
2932  0E00     MOVLW 0x0
2934  6F04     MOVWF 0x4, BANKED
2936  0E00     MOVLW 0x0
2938  6F05     MOVWF 0x5, BANKED
293A  0E20     MOVLW 0x20
293C  6F06     MOVWF 0x6, BANKED
293E  0E41     MOVLW 0x41
2940  6F07     MOVWF 0x7, BANKED
2942  EC13     CALL 0x5A26, 0
2944  F02D     NOP
2948  F800     NOP
294A  F66D     NOP
294E  F804     NOP
2950  F66E     NOP
2954  F808     NOP
2956  F66F     NOP
295A  F80C     NOP
295C  F670     NOP
372:                       --e;
295E  0106     MOVLB 0x6
2960  0769     DECF 0x69, F, BANKED
2962  A0D8     BTFSS 0xFD8, 0, ACCESS
2964  076A     DECF MD1CON0, F, BANKED
373:                   }
374:               }
375:           
376:               /* Get mode, precision */
377:               mode = tolower((int)c);
29AC  F8CC     NOP
29AE  F606     NOP
29B0  6B07     CLRF 0x7, BANKED
29B2  ECFF     CALL 0x7FFE, 0
29B4  F03F     NOP
29B6  0106     MOVLB 0x6
29B8  5106     MOVF 0x6, W, BANKED
29BA  6F5A     MOVWF 0x5A, BANKED
378:               nmode = mode;
29BE  F968     NOP
29C0  F657     NOP
379:               if (mode == 'g') {
29C2  0E67     MOVLW 0x67
29C4  195A     XORWF 0x5A, W, BANKED
29C6  A4D8     BTFSS 0xFD8, 2, ACCESS
29C8  EFE8     GOTO 0x29D0
29CA  F014     NOP
29CC  EFEA     GOTO 0x29D4
29CE  F014     NOP
29D0  EF12     GOTO 0x2A24
29D2  F015     NOP
380:           		if (prec == 0) {
29D4  51B3     MOVF OSCEN, W, BANKED
29D6  11B4     IORWF PRLOCK, W, BANKED
29D8  A4D8     BTFSS 0xFD8, 2, ACCESS
29DA  EFF1     GOTO 0x29E2
29DC  F014     NOP
29DE  EFF3     GOTO 0x29E6
29E0  F014     NOP
29E2  EFF7     GOTO 0x29EE
29E4  F014     NOP
381:           			prec = 1;
29E6  0E00     MOVLW 0x0
29E8  6FB4     MOVWF PRLOCK, BANKED
29EA  0E01     MOVLW 0x1
29EC  6FB3     MOVWF OSCEN, BANKED
382:           		}
383:                   p = (0 < prec) ? prec : 6;
29EE  BFB4     BTFSC PRLOCK, 7, BANKED
29F0  EF04     GOTO 0x2A08
29F2  F015     NOP
29F4  51B4     MOVF PRLOCK, W, BANKED
29F6  E106     BNZ 0x2A04
29F8  05B3     DECF OSCEN, W, BANKED
29FA  B0D8     BTFSC 0xFD8, 0, ACCESS
29FC  EF02     GOTO 0x2A04
29FE  F015     NOP
2A00  EF04     GOTO 0x2A08
2A02  F015     NOP
2A04  EF0A     GOTO 0x2A14
2A06  F015     NOP
2A08  0E00     MOVLW 0x0
2A0A  6F56     MOVWF 0x56, BANKED
2A0C  0E06     MOVLW 0x6
2A0E  6F55     MOVWF 0x55, BANKED
2A10  EF1B     GOTO 0x2A36
2A12  F015     NOP
2A16  FACC     NOP
2A18  F655     NOP
2A1C  FAD0     NOP
2A1E  F656     NOP
2A20  EF1B     GOTO 0x2A36
2A22  F015     NOP
384:               } else {
385:                   p = (prec < 0) ? 6 : prec;
2A24  BFB4     BTFSC PRLOCK, 7, BANKED
2A26  EF17     GOTO 0x2A2E
2A28  F015     NOP
2A2A  EF19     GOTO 0x2A32
2A2C  F015     NOP
2A2E  EF04     GOTO 0x2A08
2A30  F015     NOP
2A32  EF0A     GOTO 0x2A14
2A34  F015     NOP
386:               }
387:           
388:               /* Choose e or f mode from g mode */
389:               if (mode == 'g') {
2A36  0E67     MOVLW 0x67
2A38  195A     XORWF 0x5A, W, BANKED
2A3A  A4D8     BTFSS 0xFD8, 2, ACCESS
2A3C  EF22     GOTO 0x2A44
2A3E  F015     NOP
2A40  EF24     GOTO 0x2A48
2A42  F015     NOP
2A44  EF55     GOTO 0x2AAA
2A46  F015     NOP
390:                   if (!(e < -4) && !((p - 1) < e)) {
2A48  AF6A     BTFSS MD1CON0, 7, BANKED
2A4A  EF32     GOTO 0x2A64
2A4C  F015     NOP
2A4E  0EFC     MOVLW 0xFC
2A50  5D69     SUBWF 0x69, W, BANKED
2A52  0EFF     MOVLW 0xFF
2A54  596A     SUBWFB MD1CON0, W, BANKED
2A56  A0D8     BTFSS 0xFD8, 0, ACCESS
2A58  EF30     GOTO 0x2A60
2A5A  F015     NOP
2A5C  EF32     GOTO 0x2A64
2A5E  F015     NOP
2A60  EF53     GOTO 0x2AA6
2A62  F015     NOP
2A64  0EFF     MOVLW 0xFF
2A66  6F34     MOVWF 0x34, BANKED
2A68  0EFF     MOVLW 0xFF
2A6A  6F35     MOVWF 0x35, BANKED
2A6E  F954     NOP
2A70  F636     NOP
2A74  F958     NOP
2A76  F637     NOP
2A78  5134     MOVF 0x34, W, BANKED
2A7A  2736     ADDWF 0x36, F, BANKED
2A7C  5135     MOVF 0x35, W, BANKED
2A7E  2337     ADDWFC 0x37, F, BANKED
2A80  5169     MOVF 0x69, W, BANKED
2A82  5D36     SUBWF 0x36, W, BANKED
2A84  5137     MOVF 0x37, W, BANKED
2A86  0A80     XORLW 0x80
2A88  6F38     MOVWF 0x38, BANKED
2A8A  516A     MOVF MD1CON0, W, BANKED
2A8C  0A80     XORLW 0x80
2A8E  5938     SUBWFB 0x38, W, BANKED
2A90  A0D8     BTFSS 0xFD8, 0, ACCESS
2A92  EF4D     GOTO 0x2A9A
2A94  F015     NOP
2A96  EF4F     GOTO 0x2A9E
2A98  F015     NOP
2A9A  EF53     GOTO 0x2AA6
2A9C  F015     NOP
391:                       nmode = 'f';
2A9E  0E66     MOVLW 0x66
2AA0  6F57     MOVWF 0x57, BANKED
392:                   } else {
2AA2  EF55     GOTO 0x2AAA
2AA4  F015     NOP
393:                       nmode = 'e';
2AA6  0E65     MOVLW 0x65
2AA8  6F57     MOVWF 0x57, BANKED
394:                   }
395:               }
396:           
397:               /* Decimal places or significant digits */
398:               m = p;
2AAC  F954     NOP
2AAE  F64D     NOP
2AB2  F958     NOP
2AB4  F64E     NOP
399:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
2AB6  0E67     MOVLW 0x67
2AB8  195A     XORWF 0x5A, W, BANKED
2ABA  A4D8     BTFSS 0xFD8, 2, ACCESS
2ABC  EF62     GOTO 0x2AC4
2ABE  F015     NOP
2AC0  EF64     GOTO 0x2AC8
2AC2  F015     NOP
2AC4  EF74     GOTO 0x2AE8
2AC6  F015     NOP
2AC8  0E66     MOVLW 0x66
2ACA  1957     XORWF 0x57, W, BANKED
2ACC  A4D8     BTFSS 0xFD8, 2, ACCESS
2ACE  EF6B     GOTO 0x2AD6
2AD0  F015     NOP
2AD2  EF6D     GOTO 0x2ADA
2AD4  F015     NOP
2AD6  EF76     GOTO 0x2AEC
2AD8  F015     NOP
2ADA  BF6A     BTFSC MD1CON0, 7, BANKED
2ADC  EF74     GOTO 0x2AE8
2ADE  F015     NOP
2AE0  EF72     GOTO 0x2AE4
2AE2  F015     NOP
2AE4  EF76     GOTO 0x2AEC
2AE6  F015     NOP
400:                   ++m;
2AE8  4B4D     INFSNZ 0x4D, F, BANKED
2AEA  2B4E     INCF 0x4E, F, BANKED
401:               }
402:           
403:               /* Adjust starting exponent, string length for 'f' conversions */
404:               if (nmode == 'f') {
2AEC  0E66     MOVLW 0x66
2AEE  1957     XORWF 0x57, W, BANKED
2AF0  A4D8     BTFSS 0xFD8, 2, ACCESS
2AF2  EF7D     GOTO 0x2AFA
2AF4  F015     NOP
2AF6  EF7F     GOTO 0x2AFE
2AF8  F015     NOP
2AFA  EF9F     GOTO 0x2B3E
2AFC  F015     NOP
405:                   if (e < 0) {
2AFE  BF6A     BTFSC MD1CON0, 7, BANKED
2B00  EF86     GOTO 0x2B0C
2B02  F015     NOP
2B04  EF84     GOTO 0x2B08
2B06  F015     NOP
2B08  EF92     GOTO 0x2B24
2B0A  F015     NOP
406:                       u = 1.0;
2B0C  0E00     MOVLW 0x0
2B0E  6F6D     MOVWF MD1CARL, BANKED
2B10  0E00     MOVLW 0x0
2B12  6F6E     MOVWF MD1CARH, BANKED
2B14  0E80     MOVLW 0x80
2B16  6F6F     MOVWF CMOUT, BANKED
2B18  0E3F     MOVLW 0x3F
2B1A  6F70     MOVWF CM1CON0, BANKED
407:                       e = 0;
2B1C  0E00     MOVLW 0x0
2B1E  6F6A     MOVWF MD1CON0, BANKED
2B20  0E00     MOVLW 0x0
2B22  6F69     MOVWF 0x69, BANKED
408:                   }
409:                   if (!(mode == 'g')) {
2B24  0E67     MOVLW 0x67
2B26  195A     XORWF 0x5A, W, BANKED
2B28  B4D8     BTFSC 0xFD8, 2, ACCESS
2B2A  EF99     GOTO 0x2B32
2B2C  F015     NOP
2B2E  EF9B     GOTO 0x2B36
2B30  F015     NOP
2B32  EF9F     GOTO 0x2B3E
2B34  F015     NOP
410:                       m += e;
2B36  5169     MOVF 0x69, W, BANKED
2B38  274D     ADDWF 0x4D, F, BANKED
2B3A  516A     MOVF MD1CON0, W, BANKED
2B3C  234E     ADDWFC 0x4E, F, BANKED
411:                   }
412:               }
413:           
414:               /* Go through the conversion once to get to the rounding step */
415:               i = 0;
2B3E  0E00     MOVLW 0x0
2B40  6F64     MOVWF PMD4, BANKED
2B42  0E00     MOVLW 0x0
2B44  6F63     MOVWF PMD3, BANKED
416:               h = g;
2B48  F994     NOP
2B4A  F65B     NOP
2B4E  F998     NOP
2B50  F65C     NOP
2B54  F99C     NOP
2B56  F65D     NOP
2B5A  F9A0     NOP
2B5C  F65E     NOP
417:               ou = u;
2B60  F9B4     NOP
2B62  F639     NOP
2B66  F9B8     NOP
2B68  F63A     NOP
2B6C  F9BC     NOP
2B6E  F63B     NOP
2B72  F9C0     NOP
2B74  F63C     NOP
418:               while (i < m) {
2B76  EF6B     GOTO 0x2CD6
2B78  F016     NOP
2CD6  514D     MOVF 0x4D, W, BANKED
2CD8  5D63     SUBWF PMD3, W, BANKED
2CDA  5164     MOVF PMD4, W, BANKED
2CDC  0A80     XORLW 0x80
2CDE  6F34     MOVWF 0x34, BANKED
2CE0  514E     MOVF 0x4E, W, BANKED
2CE2  0A80     XORLW 0x80
2CE4  5934     SUBWFB 0x34, W, BANKED
2CE6  A0D8     BTFSS 0xFD8, 0, ACCESS
2CE8  EF78     GOTO 0x2CF0
2CEA  F016     NOP
2CEC  EF7A     GOTO 0x2CF4
2CEE  F016     NOP
2CF0  EFBD     GOTO 0x2B7A
2CF2  F015     NOP
419:                   l = floor(h/u);
2B7C  F96C     NOP
2B7E  F600     NOP
2B82  F970     NOP
2B84  F601     NOP
2B88  F974     NOP
2B8A  F602     NOP
2B8E  F978     NOP
2B90  F603     NOP
2B94  F9B4     NOP
2B96  F604     NOP
2B9A  F9B8     NOP
2B9C  F605     NOP
2BA0  F9BC     NOP
2BA2  F606     NOP
2BA6  F9C0     NOP
2BA8  F607     NOP
2BAA  EC13     CALL 0x5A26, 0
2BAC  F02D     NOP
2BB0  F800     NOP
2BB2  F619     NOP
2BB6  F804     NOP
2BB8  F61A     NOP
2BBC  F808     NOP
2BBE  F61B     NOP
2BC2  F80C     NOP
2BC4  F61C     NOP
2BC6  EC79     CALL 0x64F2, 0
2BC8  F032     NOP
2BCC  F864     NOP
2BCE  F65F     NOP
2BD2  F868     NOP
2BD4  F660     NOP
2BD8  F86C     NOP
2BDA  F661     NOP
2BDE  F870     NOP
2BE0  F662     NOP
420:                   d = (int)l;
2BE4  F97C     NOP
2BE6  F600     NOP
2BEA  F980     NOP
2BEC  F601     NOP
2BF0  F984     NOP
2BF2  F602     NOP
2BF6  F988     NOP
2BF8  F603     NOP
2BFA  EC67     CALL 0x72CE, 0
2BFC  F039     NOP
2C00  F800     NOP
2C02  F651     NOP
2C06  F804     NOP
2C08  F652     NOP
421:                   h -= l*u;
2C0C  F96C     NOP
2C0E  F619     NOP
2C12  F970     NOP
2C14  F61A     NOP
2C18  F974     NOP
2C1A  F61B     NOP
2C1E  F978     NOP
2C20  F61C     NOP
2C24  F9B4     NOP
2C26  F604     NOP
2C2A  F9B8     NOP
2C2C  F605     NOP
2C30  F9BC     NOP
2C32  F606     NOP
2C36  F9C0     NOP
2C38  F607     NOP
2C3C  F97C     NOP
2C3E  F600     NOP
2C42  F980     NOP
2C44  F601     NOP
2C48  F984     NOP
2C4A  F602     NOP
2C4E  F988     NOP
2C50  F603     NOP
2C52  EC88     CALL 0x5110, 0
2C54  F028     NOP
2C58  F800     NOP
2C5A  F61D     NOP
2C5E  F804     NOP
2C60  F61E     NOP
2C64  F808     NOP
2C66  F61F     NOP
2C6A  F80C     NOP
2C6C  F620     NOP
2C6E  EC34     CALL 0x8068, 0
2C70  F040     NOP
2C74  F864     NOP
2C76  F65B     NOP
2C7A  F868     NOP
2C7C  F65C     NOP
2C80  F86C     NOP
2C82  F65D     NOP
2C86  F870     NOP
2C88  F65E     NOP
422:                   u = u/10.0;
2C8C  F9B4     NOP
2C8E  F600     NOP
2C92  F9B8     NOP
2C94  F601     NOP
2C98  F9BC     NOP
2C9A  F602     NOP
2C9E  F9C0     NOP
2CA0  F603     NOP
2CA2  0E00     MOVLW 0x0
2CA4  0106     MOVLB 0x6
2CA6  6F04     MOVWF 0x4, BANKED
2CA8  0E00     MOVLW 0x0
2CAA  6F05     MOVWF 0x5, BANKED
2CAC  0E20     MOVLW 0x20
2CAE  6F06     MOVWF 0x6, BANKED
2CB0  0E41     MOVLW 0x41
2CB2  6F07     MOVWF 0x7, BANKED
2CB4  EC13     CALL 0x5A26, 0
2CB6  F02D     NOP
2CBA  F800     NOP
2CBC  F66D     NOP
2CC0  F804     NOP
2CC2  F66E     NOP
2CC6  F808     NOP
2CC8  F66F     NOP
2CCC  F80C     NOP
2CCE  F670     NOP
423:                   ++i;
2CD0  0106     MOVLB 0x6
2CD2  4B63     INFSNZ PMD3, F, BANKED
2CD4  2B64     INCF PMD4, F, BANKED
424:               }
425:               
426:               /* Remainder >= halfway ? */
427:               l = u*5.0;
2CF6  F9B4     NOP
2CF8  F600     NOP
2CFC  F9B8     NOP
2CFE  F601     NOP
2D02  F9BC     NOP
2D04  F602     NOP
2D08  F9C0     NOP
2D0A  F603     NOP
2D0C  0E00     MOVLW 0x0
2D0E  6F04     MOVWF 0x4, BANKED
2D10  0E00     MOVLW 0x0
2D12  6F05     MOVWF 0x5, BANKED
2D14  0EA0     MOVLW 0xA0
2D16  6F06     MOVWF 0x6, BANKED
2D18  0E40     MOVLW 0x40
2D1A  6F07     MOVWF 0x7, BANKED
2D1C  EC88     CALL 0x5110, 0
2D1E  F028     NOP
2D22  F800     NOP
2D24  F65F     NOP
2D28  F804     NOP
2D2A  F660     NOP
2D2E  F808     NOP
2D30  F661     NOP
2D34  F80C     NOP
2D36  F662     NOP
428:               if (h < l) {
2D3A  F96C     NOP
2D3C  F619     NOP
2D40  F970     NOP
2D42  F61A     NOP
2D46  F974     NOP
2D48  F61B     NOP
2D4C  F978     NOP
2D4E  F61C     NOP
2D52  F97C     NOP
2D54  F61D     NOP
2D58  F980     NOP
2D5A  F61E     NOP
2D5E  F984     NOP
2D60  F61F     NOP
2D64  F988     NOP
2D66  F620     NOP
2D68  EC7D     CALL 0x74FA, 0
2D6A  F03A     NOP
2D6C  0106     MOVLB 0x6
2D6E  B0D8     BTFSC 0xFD8, 0, ACCESS
2D70  EFBC     GOTO 0x2D78
2D72  F016     NOP
2D74  EFBE     GOTO 0x2D7C
2D76  F016     NOP
2D78  EFC8     GOTO 0x2D90
2D7A  F016     NOP
429:                   l = 0.0;
2D7C  0E00     MOVLW 0x0
2D7E  6F5F     MOVWF 0x5F, BANKED
2D80  0E00     MOVLW 0x0
2D82  6F60     MOVWF PMD0, BANKED
2D84  0E00     MOVLW 0x0
2D86  6F61     MOVWF PMD1, BANKED
2D88  0E00     MOVLW 0x0
2D8A  6F62     MOVWF 0x62, BANKED
430:               } else {
2D8C  EFF9     GOTO 0x2DF2
2D8E  F016     NOP
431:                   /* On tie choose even number */
432:                   if ((h == l) && !(d % 2)) {
2D92  F96C     NOP
2D94  F600     NOP
2D98  F970     NOP
2D9A  F601     NOP
2D9E  F974     NOP
2DA0  F602     NOP
2DA4  F978     NOP
2DA6  F603     NOP
2DAA  F97C     NOP
2DAC  F604     NOP
2DB0  F980     NOP
2DB2  F605     NOP
2DB6  F984     NOP
2DB8  F606     NOP
2DBC  F988     NOP
2DBE  F607     NOP
2DC0  ECB5     CALL 0x796A, 0
2DC2  F03C     NOP
2DC4  0106     MOVLB 0x6
2DC6  A0D8     BTFSS 0xFD8, 0, ACCESS
2DC8  EFE8     GOTO 0x2DD0
2DCA  F016     NOP
2DCC  EFEA     GOTO 0x2DD4
2DCE  F016     NOP
2DD0  EFF9     GOTO 0x2DF2
2DD2  F016     NOP
2DD4  B151     BTFSC 0x51, 0, BANKED
2DD6  EFEF     GOTO 0x2DDE
2DD8  F016     NOP
2DDA  EFF1     GOTO 0x2DE2
2DDC  F016     NOP
2DDE  EFF9     GOTO 0x2DF2
2DE0  F016     NOP
433:                       l = 0.0;
2DE2  0E00     MOVLW 0x0
2DE4  6F5F     MOVWF 0x5F, BANKED
2DE6  0E00     MOVLW 0x0
2DE8  6F60     MOVWF PMD0, BANKED
2DEA  0E00     MOVLW 0x0
2DEC  6F61     MOVWF PMD1, BANKED
2DEE  0E00     MOVLW 0x0
2DF0  6F62     MOVWF 0x62, BANKED
434:                   }
435:               }
436:           
437:               /* Round */
438:               h = g + l;
2DF4  F994     NOP
2DF6  F600     NOP
2DFA  F998     NOP
2DFC  F601     NOP
2E00  F99C     NOP
2E02  F602     NOP
2E06  F9A0     NOP
2E08  F603     NOP
2E0C  F97C     NOP
2E0E  F604     NOP
2E12  F980     NOP
2E14  F605     NOP
2E18  F984     NOP
2E1A  F606     NOP
2E1E  F988     NOP
2E20  F607     NOP
2E22  EC8B     CALL 0x4716, 0
2E24  F023     NOP
2E28  F800     NOP
2E2A  F65B     NOP
2E2E  F804     NOP
2E30  F65C     NOP
2E34  F808     NOP
2E36  F65D     NOP
2E3A  F80C     NOP
2E3C  F65E     NOP
439:               
440:               /* Convert again, after rounding */
441:               u = ou;
2E40  F8E4     NOP
2E42  F66D     NOP
2E46  F8E8     NOP
2E48  F66E     NOP
2E4C  F8EC     NOP
2E4E  F66F     NOP
2E52  F8F0     NOP
2E54  F670     NOP
442:               ne = (nmode == 'e') ? 0 : e;
2E56  0E65     MOVLW 0x65
2E58  0106     MOVLB 0x6
2E5A  1957     XORWF 0x57, W, BANKED
2E5C  B4D8     BTFSC 0xFD8, 2, ACCESS
2E5E  EF33     GOTO 0x2E66
2E60  F017     NOP
2E62  EF35     GOTO 0x2E6A
2E64  F017     NOP
2E66  EF3D     GOTO 0x2E7A
2E68  F017     NOP
2E6C  F9A4     NOP
2E6E  F64F     NOP
2E72  F9A8     NOP
2E74  F650     NOP
2E76  EF41     GOTO 0x2E82
2E78  F017     NOP
2E7A  0E00     MOVLW 0x0
2E7C  6F50     MOVWF 0x50, BANKED
2E7E  0E00     MOVLW 0x0
2E80  6F4F     MOVWF 0x4F, BANKED
443:               pp = 0;
2E82  0E00     MOVLW 0x0
2E84  6F4C     MOVWF ZCDCON, BANKED
2E86  0E00     MOVLW 0x0
2E88  6F4B     MOVWF HLVDCON1, BANKED
444:               t = 0;
2E8A  0E00     MOVLW 0x0
2E8C  6F4A     MOVWF HLVDCON0, BANKED
2E8E  0E00     MOVLW 0x0
2E90  6F49     MOVWF BORCON, BANKED
445:               i = 0;
2E92  0E00     MOVLW 0x0
2E94  6F64     MOVWF PMD4, BANKED
2E96  0E00     MOVLW 0x0
2E98  6F63     MOVWF PMD3, BANKED
446:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
2E9A  EF6F     GOTO 0x30DE
2E9C  F018     NOP
30DE  514D     MOVF 0x4D, W, BANKED
30E0  5D63     SUBWF PMD3, W, BANKED
30E2  5164     MOVF PMD4, W, BANKED
30E4  0A80     XORLW 0x80
30E6  6F34     MOVWF 0x34, BANKED
30E8  514E     MOVF 0x4E, W, BANKED
30EA  0A80     XORLW 0x80
30EC  5934     SUBWFB 0x34, W, BANKED
30EE  B0D8     BTFSC 0xFD8, 0, ACCESS
30F0  EF7C     GOTO 0x30F8
30F2  F018     NOP
30F4  EF7E     GOTO 0x30FC
30F6  F018     NOP
30F8  EF8C     GOTO 0x3118
30FA  F018     NOP
30FC  BF6C     BTFSC MD1SRC, 7, BANKED
30FE  EF8A     GOTO 0x3114
3100  F018     NOP
3102  516C     MOVF MD1SRC, W, BANKED
3104  E109     BNZ 0x3118
3106  0E4B     MOVLW 0x4B
3108  5D6B     SUBWF MD1CON1, W, BANKED
310A  A0D8     BTFSS 0xFD8, 0, ACCESS
310C  EF8A     GOTO 0x3114
310E  F018     NOP
3110  EF8C     GOTO 0x3118
3112  F018     NOP
3114  EF4F     GOTO 0x2E9E
3116  F017     NOP
447:                   l = floor(h/u);
2EA0  F96C     NOP
2EA2  F600     NOP
2EA6  F970     NOP
2EA8  F601     NOP
2EAC  F974     NOP
2EAE  F602     NOP
2EB2  F978     NOP
2EB4  F603     NOP
2EB8  F9B4     NOP
2EBA  F604     NOP
2EBE  F9B8     NOP
2EC0  F605     NOP
2EC4  F9BC     NOP
2EC6  F606     NOP
2ECA  F9C0     NOP
2ECC  F607     NOP
2ECE  EC13     CALL 0x5A26, 0
2ED0  F02D     NOP
2ED4  F800     NOP
2ED6  F619     NOP
2EDA  F804     NOP
2EDC  F61A     NOP
2EE0  F808     NOP
2EE2  F61B     NOP
2EE6  F80C     NOP
2EE8  F61C     NOP
2EEA  EC79     CALL 0x64F2, 0
2EEC  F032     NOP
2EF0  F864     NOP
2EF2  F65F     NOP
2EF6  F868     NOP
2EF8  F660     NOP
2EFC  F86C     NOP
2EFE  F661     NOP
2F02  F870     NOP
2F04  F662     NOP
448:                   d = (int)l;
2F08  F97C     NOP
2F0A  F600     NOP
2F0E  F980     NOP
2F10  F601     NOP
2F14  F984     NOP
2F16  F602     NOP
2F1A  F988     NOP
2F1C  F603     NOP
2F1E  EC67     CALL 0x72CE, 0
2F20  F039     NOP
2F24  F800     NOP
2F26  F651     NOP
2F2A  F804     NOP
2F2C  F652     NOP
449:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
2F2E  0106     MOVLB 0x6
2F30  B9B5     BTFSC SCANPR, 4, BANKED
2F32  EF9D     GOTO 0x2F3A
2F34  F017     NOP
2F36  EF9F     GOTO 0x2F3E
2F38  F017     NOP
2F3A  EFBC     GOTO 0x2F78
2F3C  F017     NOP
2F3E  5151     MOVF 0x51, W, BANKED
2F40  1152     IORWF 0x52, W, BANKED
2F42  A4D8     BTFSS 0xFD8, 2, ACCESS
2F44  EFA6     GOTO 0x2F4C
2F46  F017     NOP
2F48  EFA8     GOTO 0x2F50
2F4A  F017     NOP
2F4C  EFBC     GOTO 0x2F78
2F4E  F017     NOP
2F50  0E67     MOVLW 0x67
2F52  195A     XORWF 0x5A, W, BANKED
2F54  A4D8     BTFSS 0xFD8, 2, ACCESS
2F56  EFAF     GOTO 0x2F5E
2F58  F017     NOP
2F5A  EFB1     GOTO 0x2F62
2F5C  F017     NOP
2F5E  EFBC     GOTO 0x2F78
2F60  F017     NOP
2F62  BF50     BTFSC 0x50, 7, BANKED
2F64  EFB8     GOTO 0x2F70
2F66  F017     NOP
2F68  EFB6     GOTO 0x2F6C
2F6A  F017     NOP
2F6C  EFBC     GOTO 0x2F78
2F6E  F017     NOP
450:                       ++t;
2F70  4B49     INFSNZ BORCON, F, BANKED
2F72  2B4A     INCF HLVDCON0, F, BANKED
451:                   } else {
2F74  EF06     GOTO 0x300C
2F76  F018     NOP
452:                       if (!pp && (ne < 0)) {
2F78  514B     MOVF HLVDCON1, W, BANKED
2F7A  114C     IORWF ZCDCON, W, BANKED
2F7C  A4D8     BTFSS 0xFD8, 2, ACCESS
2F7E  EFC3     GOTO 0x2F86
2F80  F017     NOP
2F82  EFC5     GOTO 0x2F8A
2F84  F017     NOP
2F86  EFEF     GOTO 0x2FDE
2F88  F017     NOP
2F8A  BF50     BTFSC 0x50, 7, BANKED
2F8C  EFCC     GOTO 0x2F98
2F8E  F017     NOP
2F90  EFCA     GOTO 0x2F94
2F92  F017     NOP
2F94  EFEF     GOTO 0x2FDE
2F96  F017     NOP
453:                           dbuf[n++] = '.';
2F98  0E00     MOVLW 0x0
2F9A  256B     ADDWF MD1CON1, W, BANKED
2F9C  6ED9     MOVWF 0xFD9, ACCESS
2F9E  0E07     MOVLW 0x7
2FA0  216C     ADDWFC MD1SRC, W, BANKED
2FA2  6EDA     MOVWF 0xFDA, ACCESS
2FA4  0E2E     MOVLW 0x2E
2FA6  6EDF     MOVWF 0xFDF, ACCESS
2FA8  4B6B     INFSNZ MD1CON1, F, BANKED
2FAA  2B6C     INCF MD1SRC, F, BANKED
454:                           --w;
2FAC  0758     DECF 0x58, F, BANKED
2FAE  A0D8     BTFSS 0xFD8, 0, ACCESS
2FB0  0759     DECF 0x59, F, BANKED
455:                           pp = 1;
2FB2  0E00     MOVLW 0x0
2FB4  6F4C     MOVWF ZCDCON, BANKED
2FB6  0E01     MOVLW 0x1
2FB8  6F4B     MOVWF HLVDCON1, BANKED
2FBA  EFEF     GOTO 0x2FDE
2FBC  F017     NOP
456:                       }
457:                       while (t) {
2FDE  5149     MOVF BORCON, W, BANKED
2FE0  114A     IORWF HLVDCON0, W, BANKED
2FE2  A4D8     BTFSS 0xFD8, 2, ACCESS
2FE4  EFF6     GOTO 0x2FEC
2FE6  F017     NOP
2FE8  EFF8     GOTO 0x2FF0
2FEA  F017     NOP
2FEC  EFDF     GOTO 0x2FBE
2FEE  F017     NOP
458:                           dbuf[n++] = '0';
2FBE  0E00     MOVLW 0x0
2FC0  256B     ADDWF MD1CON1, W, BANKED
2FC2  6ED9     MOVWF 0xFD9, ACCESS
2FC4  0E07     MOVLW 0x7
2FC6  216C     ADDWFC MD1SRC, W, BANKED
2FC8  6EDA     MOVWF 0xFDA, ACCESS
2FCA  0E30     MOVLW 0x30
2FCC  6EDF     MOVWF 0xFDF, ACCESS
2FCE  4B6B     INFSNZ MD1CON1, F, BANKED
2FD0  2B6C     INCF MD1SRC, F, BANKED
459:                           --w;
2FD2  0758     DECF 0x58, F, BANKED
2FD4  A0D8     BTFSS 0xFD8, 0, ACCESS
2FD6  0759     DECF 0x59, F, BANKED
460:                           --t;
2FD8  0749     DECF BORCON, F, BANKED
2FDA  A0D8     BTFSS 0xFD8, 0, ACCESS
2FDC  074A     DECF HLVDCON0, F, BANKED
461:                       }
462:                       dbuf[n++] = '0' + d;
2FF0  0E00     MOVLW 0x0
2FF2  256B     ADDWF MD1CON1, W, BANKED
2FF4  6ED9     MOVWF 0xFD9, ACCESS
2FF6  0E07     MOVLW 0x7
2FF8  216C     ADDWFC MD1SRC, W, BANKED
2FFA  6EDA     MOVWF 0xFDA, ACCESS
2FFC  5151     MOVF 0x51, W, BANKED
2FFE  0F30     ADDLW 0x30
3000  6EDF     MOVWF 0xFDF, ACCESS
3002  4B6B     INFSNZ MD1CON1, F, BANKED
3004  2B6C     INCF MD1SRC, F, BANKED
463:                       --w;
3006  0758     DECF 0x58, F, BANKED
3008  A0D8     BTFSS 0xFD8, 0, ACCESS
300A  0759     DECF 0x59, F, BANKED
464:                   }
465:                   h -= l*u;
300E  F96C     NOP
3010  F619     NOP
3014  F970     NOP
3016  F61A     NOP
301A  F974     NOP
301C  F61B     NOP
3020  F978     NOP
3022  F61C     NOP
3026  F9B4     NOP
3028  F604     NOP
302C  F9B8     NOP
302E  F605     NOP
3032  F9BC     NOP
3034  F606     NOP
3038  F9C0     NOP
303A  F607     NOP
303E  F97C     NOP
3040  F600     NOP
3044  F980     NOP
3046  F601     NOP
304A  F984     NOP
304C  F602     NOP
3050  F988     NOP
3052  F603     NOP
3054  EC88     CALL 0x5110, 0
3056  F028     NOP
305A  F800     NOP
305C  F61D     NOP
3060  F804     NOP
3062  F61E     NOP
3066  F808     NOP
3068  F61F     NOP
306C  F80C     NOP
306E  F620     NOP
3070  EC34     CALL 0x8068, 0
3072  F040     NOP
3076  F864     NOP
3078  F65B     NOP
307C  F868     NOP
307E  F65C     NOP
3082  F86C     NOP
3084  F65D     NOP
3088  F870     NOP
308A  F65E     NOP
466:                   u = u/10.0;
308E  F9B4     NOP
3090  F600     NOP
3094  F9B8     NOP
3096  F601     NOP
309A  F9BC     NOP
309C  F602     NOP
30A0  F9C0     NOP
30A2  F603     NOP
30A4  0E00     MOVLW 0x0
30A6  0106     MOVLB 0x6
30A8  6F04     MOVWF 0x4, BANKED
30AA  0E00     MOVLW 0x0
30AC  6F05     MOVWF 0x5, BANKED
30AE  0E20     MOVLW 0x20
30B0  6F06     MOVWF 0x6, BANKED
30B2  0E41     MOVLW 0x41
30B4  6F07     MOVWF 0x7, BANKED
30B6  EC13     CALL 0x5A26, 0
30B8  F02D     NOP
30BC  F800     NOP
30BE  F66D     NOP
30C2  F804     NOP
30C4  F66E     NOP
30C8  F808     NOP
30CA  F66F     NOP
30CE  F80C     NOP
30D0  F670     NOP
467:                   --ne;
30D2  0106     MOVLB 0x6
30D4  074F     DECF 0x4F, F, BANKED
30D6  A0D8     BTFSS 0xFD8, 0, ACCESS
30D8  0750     DECF 0x50, F, BANKED
468:                   ++i;
30DA  4B63     INFSNZ PMD3, F, BANKED
30DC  2B64     INCF PMD4, F, BANKED
469:               }
470:               if (!pp && (flags & POUND_FLAG)) {
3118  514B     MOVF HLVDCON1, W, BANKED
311A  114C     IORWF ZCDCON, W, BANKED
311C  A4D8     BTFSS 0xFD8, 2, ACCESS
311E  EF93     GOTO 0x3126
3120  F018     NOP
3122  EF95     GOTO 0x312A
3124  F018     NOP
3126  EFA6     GOTO 0x314C
3128  F018     NOP
312A  A9B5     BTFSS SCANPR, 4, BANKED
312C  EF9A     GOTO 0x3134
312E  F018     NOP
3130  EF9C     GOTO 0x3138
3132  F018     NOP
3134  EFA6     GOTO 0x314C
3136  F018     NOP
471:                   dbuf[n++] = '.';
3138  0E00     MOVLW 0x0
313A  256B     ADDWF MD1CON1, W, BANKED
313C  6ED9     MOVWF 0xFD9, ACCESS
313E  0E07     MOVLW 0x7
3140  216C     ADDWFC MD1SRC, W, BANKED
3142  6EDA     MOVWF 0xFDA, ACCESS
3144  0E2E     MOVLW 0x2E
3146  6EDF     MOVWF 0xFDF, ACCESS
3148  4B6B     INFSNZ MD1CON1, F, BANKED
314A  2B6C     INCF MD1SRC, F, BANKED
472:               }
473:               dbuf[n] = '\0';
314C  0E00     MOVLW 0x0
314E  256B     ADDWF MD1CON1, W, BANKED
3150  6ED9     MOVWF 0xFD9, ACCESS
3152  0E07     MOVLW 0x7
3154  216C     ADDWFC MD1SRC, W, BANKED
3156  6EDA     MOVWF 0xFDA, ACCESS
3158  0E00     MOVLW 0x0
315A  6EDF     MOVWF 0xFDF, ACCESS
474:           
475:               /* Convert exponent */
476:               if (nmode == 'e') {
315C  0E65     MOVLW 0x65
315E  1957     XORWF 0x57, W, BANKED
3160  A4D8     BTFSS 0xFD8, 2, ACCESS
3162  EFB5     GOTO 0x316A
3164  F018     NOP
3166  EFB7     GOTO 0x316E
3168  F018     NOP
316A  EF90     GOTO 0x3320
316C  F019     NOP
477:                   i = sizeof(dbuf) - 1;
316E  0E00     MOVLW 0x0
3170  6F64     MOVWF PMD4, BANKED
3172  0E4F     MOVLW 0x4F
3174  6F63     MOVWF PMD3, BANKED
478:                   dbuf[i] = '\0';
3176  0E00     MOVLW 0x0
3178  2563     ADDWF PMD3, W, BANKED
317A  6ED9     MOVWF 0xFD9, ACCESS
317C  0E07     MOVLW 0x7
317E  2164     ADDWFC PMD4, W, BANKED
3180  6EDA     MOVWF 0xFDA, ACCESS
3182  0E00     MOVLW 0x0
3184  6EDF     MOVWF 0xFDF, ACCESS
479:                   sign = 0;
3186  0E00     MOVLW 0x0
3188  6F54     MOVWF 0x54, BANKED
318A  0E00     MOVLW 0x0
318C  6F53     MOVWF 0x53, BANKED
480:                   if (e < 0) {
318E  BF6A     BTFSC MD1CON0, 7, BANKED
3190  EFCE     GOTO 0x319C
3192  F018     NOP
3194  EFCC     GOTO 0x3198
3196  F018     NOP
3198  EFD6     GOTO 0x31AC
319A  F018     NOP
481:                       sign = 1;
319C  0E00     MOVLW 0x0
319E  6F54     MOVWF 0x54, BANKED
31A0  0E01     MOVLW 0x1
31A2  6F53     MOVWF 0x53, BANKED
482:                       e = -e;
31A4  6D69     NEGF 0x69, BANKED
31A6  1F6A     COMF MD1CON0, F, BANKED
31A8  B0D8     BTFSC 0xFD8, 0, ACCESS
31AA  2B6A     INCF MD1CON0, F, BANKED
483:                   }
484:                   p = 2;
31AC  0E00     MOVLW 0x0
31AE  6F56     MOVWF 0x56, BANKED
31B0  0E02     MOVLW 0x2
31B2  6F55     MOVWF 0x55, BANKED
485:                   while (e || (0 < p)) {
31B4  EF0E     GOTO 0x321C
31B6  F019     NOP
321C  5169     MOVF 0x69, W, BANKED
321E  116A     IORWF MD1CON0, W, BANKED
3220  A4D8     BTFSS 0xFD8, 2, ACCESS
3222  EF15     GOTO 0x322A
3224  F019     NOP
3226  EF17     GOTO 0x322E
3228  F019     NOP
322A  EFDC     GOTO 0x31B8
322C  F018     NOP
322E  BF56     BTFSC 0x56, 7, BANKED
3230  EF24     GOTO 0x3248
3232  F019     NOP
3234  5156     MOVF 0x56, W, BANKED
3236  E106     BNZ 0x3244
3238  0555     DECF 0x55, W, BANKED
323A  B0D8     BTFSC 0xFD8, 0, ACCESS
323C  EF22     GOTO 0x3244
323E  F019     NOP
3240  EF24     GOTO 0x3248
3242  F019     NOP
3244  EFDC     GOTO 0x31B8
3246  F018     NOP
486:                       --i;
31B8  0763     DECF PMD3, F, BANKED
31BA  A0D8     BTFSS 0xFD8, 0, ACCESS
31BC  0764     DECF PMD4, F, BANKED
487:                       dbuf[i] = '0' + (e % 10);
31BE  0E00     MOVLW 0x0
31C0  2563     ADDWF PMD3, W, BANKED
31C2  6ED9     MOVWF 0xFD9, ACCESS
31C4  0E07     MOVLW 0x7
31C6  2164     ADDWFC PMD4, W, BANKED
31C8  6EDA     MOVWF 0xFDA, ACCESS
31CC  F9A4     NOP
31CE  F600     NOP
31D2  F9A8     NOP
31D4  F601     NOP
31D6  0E00     MOVLW 0x0
31D8  6F03     MOVWF 0x3, BANKED
31DA  0E0A     MOVLW 0xA
31DC  6F02     MOVWF 0x2, BANKED
31DE  EC5A     CALL 0x78B4, 0
31E0  F03C     NOP
31E2  0106     MOVLB 0x6
31E4  5100     MOVF txData, W, BANKED
31E6  0F30     ADDLW 0x30
31E8  6EDF     MOVWF 0xFDF, ACCESS
488:                       e = e / 10;
31EC  F9A4     NOP
31EE  F600     NOP
31F2  F9A8     NOP
31F4  F601     NOP
31F6  0E00     MOVLW 0x0
31F8  6F03     MOVWF 0x3, BANKED
31FA  0E0A     MOVLW 0xA
31FC  6F02     MOVWF 0x2, BANKED
31FE  ECF5     CALL 0x77EA, 0
3200  F03B     NOP
3204  F800     NOP
3206  F669     NOP
320A  F804     NOP
320C  F66A     NOP
489:                       --p;
320E  0106     MOVLB 0x6
3210  0755     DECF 0x55, F, BANKED
3212  A0D8     BTFSS 0xFD8, 0, ACCESS
3214  0756     DECF 0x56, F, BANKED
490:                       --w;
3216  0758     DECF 0x58, F, BANKED
3218  A0D8     BTFSS 0xFD8, 0, ACCESS
321A  0759     DECF 0x59, F, BANKED
491:                   }
492:                   --i;
3248  0763     DECF PMD3, F, BANKED
324A  A0D8     BTFSS 0xFD8, 0, ACCESS
324C  0764     DECF PMD4, F, BANKED
493:                   dbuf[i] = sign ? '-' : '+';
324E  5153     MOVF 0x53, W, BANKED
3250  1154     IORWF 0x54, W, BANKED
3252  A4D8     BTFSS 0xFD8, 2, ACCESS
3254  EF2E     GOTO 0x325C
3256  F019     NOP
3258  EF30     GOTO 0x3260
325A  F019     NOP
325C  EF36     GOTO 0x326C
325E  F019     NOP
3260  0E00     MOVLW 0x0
3262  6F44     MOVWF NVMADRH, BANKED
3264  0E2B     MOVLW 0x2B
3266  6F43     MOVWF NVMADR, BANKED
3268  EF3A     GOTO 0x3274
326A  F019     NOP
326C  0E00     MOVLW 0x0
326E  6F44     MOVWF NVMADRH, BANKED
3270  0E2D     MOVLW 0x2D
3272  6F43     MOVWF NVMADR, BANKED
3274  0E00     MOVLW 0x0
3276  2563     ADDWF PMD3, W, BANKED
3278  6ED9     MOVWF 0xFD9, ACCESS
327A  0E07     MOVLW 0x7
327C  2164     ADDWFC PMD4, W, BANKED
327E  6EDA     MOVWF 0xFDA, ACCESS
3282  F90C     NOP
3284  F4DF     NOP
494:                   --w;
3286  0758     DECF 0x58, F, BANKED
3288  A0D8     BTFSS 0xFD8, 0, ACCESS
328A  0759     DECF 0x59, F, BANKED
495:                   --i;
328C  0763     DECF PMD3, F, BANKED
328E  A0D8     BTFSS 0xFD8, 0, ACCESS
3290  0764     DECF PMD4, F, BANKED
496:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
3292  0EBF     MOVLW 0xBF
3294  6F34     MOVWF 0x34, BANKED
3296  0EFF     MOVLW 0xFF
3298  6F35     MOVWF 0x35, BANKED
329A  5133     MOVF 0x33, W, BANKED
329C  6F36     MOVWF 0x36, BANKED
329E  6B37     CLRF 0x37, BANKED
32A0  5134     MOVF 0x34, W, BANKED
32A2  2736     ADDWF 0x36, F, BANKED
32A4  5135     MOVF 0x35, W, BANKED
32A6  2337     ADDWFC 0x37, F, BANKED
32A8  5137     MOVF 0x37, W, BANKED
32AA  E10A     BNZ 0x32C0
32AC  0E1A     MOVLW 0x1A
32AE  5D36     SUBWF 0x36, W, BANKED
32B0  A0D8     BTFSS 0xFD8, 0, ACCESS
32B2  EF5D     GOTO 0x32BA
32B4  F019     NOP
32B6  EF60     GOTO 0x32C0
32B8  F019     NOP
32BA  0E01     MOVLW 0x1
32BC  EF61     GOTO 0x32C2
32BE  F019     NOP
32C0  0E00     MOVLW 0x0
32C2  6F47     MOVWF NVMDATH, BANKED
32C4  6B48     CLRF VREGCON, BANKED
32C6  5147     MOVF NVMDATH, W, BANKED
32C8  1148     IORWF VREGCON, W, BANKED
32CA  A4D8     BTFSS 0xFD8, 2, ACCESS
32CC  EF6A     GOTO 0x32D4
32CE  F019     NOP
32D0  EF6C     GOTO 0x32D8
32D2  F019     NOP
32D4  EF72     GOTO 0x32E4
32D6  F019     NOP
32D8  0E00     MOVLW 0x0
32DA  6F46     MOVWF NVMDAT, BANKED
32DC  0E65     MOVLW 0x65
32DE  6F45     MOVWF NVMADRU, BANKED
32E0  EF76     GOTO 0x32EC
32E2  F019     NOP
32E4  0E00     MOVLW 0x0
32E6  6F46     MOVWF NVMDAT, BANKED
32E8  0E45     MOVLW 0x45
32EA  6F45     MOVWF NVMADRU, BANKED
32EC  0E00     MOVLW 0x0
32EE  2563     ADDWF PMD3, W, BANKED
32F0  6ED9     MOVWF 0xFD9, ACCESS
32F2  0E07     MOVLW 0x7
32F4  2164     ADDWFC PMD4, W, BANKED
32F6  6EDA     MOVWF 0xFDA, ACCESS
32FA  F914     NOP
32FC  F4DF     NOP
497:                   --w;
32FE  0758     DECF 0x58, F, BANKED
3300  A0D8     BTFSS 0xFD8, 0, ACCESS
3302  0759     DECF 0x59, F, BANKED
498:                   strcpy(&dbuf[n], &dbuf[i]);
3304  0E00     MOVLW 0x0
3306  256B     ADDWF MD1CON1, W, BANKED
3308  6F00     MOVWF txData, BANKED
330A  0E07     MOVLW 0x7
330C  216C     ADDWFC MD1SRC, W, BANKED
330E  6F01     MOVWF 0x1, BANKED
3310  0E00     MOVLW 0x0
3312  2563     ADDWF PMD3, W, BANKED
3314  6F02     MOVWF 0x2, BANKED
3316  0E07     MOVLW 0x7
3318  2164     ADDWFC PMD4, W, BANKED
331A  6F03     MOVWF 0x3, BANKED
331C  ECC7     CALL 0x7F8E, 0
331E  F03F     NOP
499:               }
500:           
501:               /* Put out padded string */
502:               return pad(fp, &dbuf[0], w);
3322  F8B4     NOP
3324  F612     NOP
3328  F8B8     NOP
332A  F613     NOP
332C  0E00     MOVLW 0x0
332E  0106     MOVLB 0x6
3330  6F14     MOVWF 0x14, BANKED
3332  0E07     MOVLW 0x7
3334  6F15     MOVWF 0x15, BANKED
3338  F960     NOP
333A  F616     NOP
333E  F964     NOP
3340  F617     NOP
3342  EC82     CALL 0x7704, 0
3344  F03B     NOP
3348  F848     NOP
334A  F62D     NOP
334E  F84C     NOP
3350  F62E     NOP
503:           }
3352  0012     RETURN 0
504:           #endif
505:           
506:           #ifdef _VFPF_O
507:           static _INLINE int otoa(FILE *fp, unsigned long long d)
508:           {
509:               int i, p, t, w;
510:               unsigned long long n;
511:           
512:               /* Adjust flags, precision, width */
513:               if (!(prec < 0)) {
514:                   flags &= ~ZERO_FLAG;
515:               }
516:               p = (0 < prec) ? prec : 1;
517:               w = width;
518:           
519:               /* Convert to octal, possibly filling on the left with zeroes */
520:               n = d;
521:               i = sizeof(dbuf) - 1;
522:               dbuf[i] = '\0';
523:               t = 0;
524:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
525:                   --i;
526:                   t = n & 07;
527:                   dbuf[i] = '0' + t;
528:                   --p;
529:                   --w;
530:                   n = n >> 3;
531:               }
532:           
533:               /* Display prefix if required */
534:               if ((flags & POUND_FLAG) && t) {
535:                   --i;
536:                   dbuf[i] = '0';
537:                   --w;
538:               }
539:           
540:               /* Put out padded string */
541:               return pad(fp, &dbuf[i], w);
542:           }
543:           #endif
544:           
545:           #ifdef _VFPF_S
546:           static _INLINE int stoa(FILE *fp, char *s)
547:           {
548:               char *cp, nuls[] = "(null)";
549:               int i, l, p, w;
550:           
551:               /* Check for null string */
552:               cp = s;
553:               if (!cp) {
554:                   cp = nuls;
555:               }
556:           
557:               /* Get length, precision, width */
558:               l = strlen(cp);
559:               p = prec;
560:               l = (!(p < 0) && (p < l)) ? p : l;
561:               p = l;
562:               w = width;
563:           
564:               /* Right justify, pad on left ? */
565:               if (!(flags & MINUS_FLAG)) {
566:                   while (l < w) {
567:                       fputc(' ', fp);
568:                       ++l;
569:                   }
570:               }
571:           
572:               /* Put out string */
573:               i = 0;
574:               while (i < p) {
575:                   fputc(*cp, fp);
576:                   ++cp;
577:                   ++i;
578:               }
579:           
580:               /* Left justify, pad on right ? */
581:               if (flags & MINUS_FLAG) {
582:                   while (l < w) {
583:                       fputc(' ', fp);
584:                       ++l;
585:                   }
586:               }
587:           
588:               return l;
589:           }
590:           #endif
591:           
592:           #ifdef _VFPF_U
593:           static _INLINE int utoa(FILE *fp, unsigned long long d)
594:           {
595:               int i, p, w;
596:               unsigned long long n;
597:           
598:               /* Adjust flags, precision, width */
599:               if (!(prec < 0)) {
600:                   flags &= ~ZERO_FLAG;
601:               }
602:               p = (0 < prec) ? prec : 1;
603:               w = width;
604:           
605:               /* Convert to decimal, possibly filling on the left with zeroes */
606:               n = d;
607:               i = sizeof(dbuf) - 1;
608:               dbuf[i] = '\0';
609:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
610:                   --i;
611:                   dbuf[i] = '0' + (n % 10);
612:                   --p;
613:                   --w;
614:                   n = n / 10;
615:               }
616:           
617:               /* Put out padded string */
618:               return pad(fp, &dbuf[i], w);
619:           }
620:           #endif
621:           
622:           #if defined(_VFPF_X) || defined(_VFPF_P)
623:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
624:           {
625:               int c, i, p, w;
626:               unsigned long long n;
627:           
628:               /* Adjust, flags, precision, width */
629:               if (!(prec < 0)) {
630:                   flags &= ~ZERO_FLAG;
631:               }
632:               p = (0 < prec) ? prec : 1;
633:               w = width;
634:               if (flags & POUND_FLAG) {
635:                   w -= 2;
636:               }
637:           
638:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
639:               n = d;
640:               i = sizeof(dbuf) - 1;
641:               dbuf[i] = '\0';
642:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
643:                   --i;
644:                   c = n & 0x0f;
645:                   c = (c < 10) ? '0' + c : 'a' + (c - 10);
646:                   if (isupper((int)x) && isalpha(c)) {
647:                       c = toupper(c);
648:                   }
649:                   dbuf[i] = (char)c;
650:                   --p;
651:                   --w;
652:                   n = n >> 4;
653:               }
654:           
655:               /* Display prefix if required */
656:               if (flags & POUND_FLAG) {
657:                   --i;
658:                   dbuf[i] = x;
659:                   --i;
660:                   dbuf[i] = '0';
661:               }
662:           
663:               /* Put out padded string */
664:               return pad(fp, &dbuf[i], w);
665:           }
666:           #endif
667:           
668:           /* Consume and convert the next part of the format string */
669:           #ifdef _VFPF_CONVERT
670:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
671:           {
672:               char c, *cp, ct[3];
673:               int done, i;
674:               long long ll;
675:               unsigned long long llu;
676:               long double f;
677:               void *vp;
678:           
679:               /* Conversion ? */
680:               if ((*fmt)[0] == '%') {
3F28  F9CC     NOP
3F2A  F4D9     NOP
3F2E  F9D0     NOP
3F30  F4DA     NOP
3F32  C4DE     MOVFF POSTINC2, TBLPTR
3F34  F4F6     NOP
3F36  C4DD     MOVFF POSTDEC2, TBLPTRH
3F38  F4F7     NOP
3F3A  0E00     MOVLW 0x0
3F3C  6EF8     MOVWF 0xFF8, ACCESS
3F3E  0008     TBLRD*
3F40  50F5     MOVF 0xFF5, W, ACCESS
3F42  0A25     XORLW 0x25
3F44  A4D8     BTFSS 0xFD8, 2, ACCESS
3F46  EFA7     GOTO 0x3F4E
3F48  F01F     NOP
3F4A  EFA9     GOTO 0x3F52
3F4C  F01F     NOP
3F4E  EF66     GOTO 0x46CC
3F50  F023     NOP
681:                   ++*fmt;
3F54  F9CC     NOP
3F56  F4D9     NOP
3F5A  F9D0     NOP
3F5C  F4DA     NOP
3F5E  2ADE     INCF 0xFDE, F, ACCESS
3F60  0E00     MOVLW 0x0
3F62  22DD     ADDWFC 0xFDD, F, ACCESS
682:           
683:                   flags = width = 0;
3F64  0E00     MOVLW 0x0
3F66  0106     MOVLB 0x6
3F68  6FB2     MOVWF OSCSTAT, BANKED
3F6A  0E00     MOVLW 0x0
3F6C  6FB1     MOVWF OSCFRQ, BANKED
3F6E  C6B1     MOVFF width, flags
3F70  F6B5     NOP
3F72  C6B2     MOVFF 0x6B2, 0x6B6
3F74  F6B6     NOP
684:                   prec = -1;
3F76  69B3     SETF OSCEN, BANKED
3F78  69B4     SETF PRLOCK, BANKED
685:           
686:           #ifdef _VFPF_FLAGS
687:                   /* Get flags */
688:                   done = 0;
689:                   while (!done) {
690:                       switch ((*fmt)[0]) {
691:                           case '-' :
692:                               flags |= MINUS_FLAG;
693:                               ++*fmt;
694:                               break;
695:                           case '0' :
696:                               flags |= ZERO_FLAG;
697:                               ++*fmt;
698:                               break;
699:                           case '+' :
700:                               flags |= PLUS_FLAG;
701:                               ++*fmt;
702:                               break;
703:                           case ' ' :
704:                               flags |= SPACE_FLAG;
705:                               ++*fmt;
706:                               break;
707:                           case '#' :
708:                               flags |= POUND_FLAG;
709:                               ++*fmt;
710:                               break;
711:                           default:
712:                               done = 1;
713:                               break;
714:                       }
715:                   }
716:                   if (flags & MINUS_FLAG) {
717:                       flags &= ~ZERO_FLAG;
718:                   }
719:           #endif
720:           
721:           #ifdef _VFPF_WIDTH
722:                   /* Get field width */
723:                   if ((*fmt)[0] == '*') {
3F7C  F9CC     NOP
3F7E  F4D9     NOP
3F82  F9D0     NOP
3F84  F4DA     NOP
3F86  C4DE     MOVFF POSTINC2, TBLPTR
3F88  F4F6     NOP
3F8A  C4DD     MOVFF POSTDEC2, TBLPTRH
3F8C  F4F7     NOP
3F8E  0E00     MOVLW 0x0
3F90  6EF8     MOVWF 0xFF8, ACCESS
3F92  0008     TBLRD*
3F94  50F5     MOVF 0xFF5, W, ACCESS
3F96  0A2A     XORLW 0x2A
3F98  A4D8     BTFSS 0xFD8, 2, ACCESS
3F9A  EFD1     GOTO 0x3FA2
3F9C  F01F     NOP
3F9E  EFD3     GOTO 0x3FA6
3FA0  F01F     NOP
3FA2  EF06     GOTO 0x400C
3FA4  F020     NOP
724:                       ++*fmt;
3FA8  F9CC     NOP
3FAA  F4D9     NOP
3FAE  F9D0     NOP
3FB0  F4DA     NOP
3FB2  2ADE     INCF 0xFDE, F, ACCESS
3FB4  0E00     MOVLW 0x0
3FB6  22DD     ADDWFC 0xFDD, F, ACCESS
725:                       width = va_arg(ap, int);
3FBA  F9D4     NOP
3FBC  F4D9     NOP
3FC0  F9D8     NOP
3FC2  F4DA     NOP
3FC6  F37C     NOP
3FC8  F677     NOP
3FCA  0E02     MOVLW 0x2
3FCC  26DE     ADDWF 0xFDE, F, ACCESS
3FD0  F37C     NOP
3FD2  F678     NOP
3FD4  0E00     MOVLW 0x0
3FD6  22DD     ADDWFC 0xFDD, F, ACCESS
3FDA  F9DC     NOP
3FDC  F4D9     NOP
3FE0  F9E0     NOP
3FE2  F4DA     NOP
3FE6  F378     NOP
3FE8  F6B1     NOP
3FEC  F374     NOP
3FEE  F6B2     NOP
726:                       if (width < 0) {
3FF0  BFB2     BTFSC OSCSTAT, 7, BANKED
3FF2  EFFF     GOTO 0x3FFE
3FF4  F01F     NOP
3FF6  EFFD     GOTO 0x3FFA
3FF8  F01F     NOP
3FFA  EF56     GOTO 0x40AC
3FFC  F020     NOP
727:                           flags |= MINUS_FLAG;
3FFE  81B5     BSF SCANPR, 0, BANKED
728:                           width = -width;
4000  6DB1     NEGF OSCFRQ, BANKED
4002  1FB2     COMF OSCSTAT, F, BANKED
4004  B0D8     BTFSC 0xFD8, 0, ACCESS
4006  2BB2     INCF OSCSTAT, F, BANKED
4008  EF56     GOTO 0x40AC
400A  F020     NOP
729:                       }
730:                   } else {
731:                       width = atoi(*fmt);
400E  F9CC     NOP
4010  F4D9     NOP
4014  F9D0     NOP
4016  F4DA     NOP
401A  F378     NOP
401C  F607     NOP
4020  F374     NOP
4022  F608     NOP
4024  ECB9     CALL 0x6B72, 0
4026  F035     NOP
402A  F81C     NOP
402C  F6B1     NOP
4030  F820     NOP
4032  F6B2     NOP
732:                       while (isdigit((*fmt)[0])) {
4034  EF25     GOTO 0x404A
4036  F020     NOP
404A  0ED0     MOVLW 0xD0
404C  0106     MOVLB 0x6
404E  6F77     MOVWF CM2PCH, BANKED
4050  0EFF     MOVLW 0xFF
4052  6F78     MOVWF WDTCON0, BANKED
4056  F9CC     NOP
4058  F4D9     NOP
405C  F9D0     NOP
405E  F4DA     NOP
4060  C4DE     MOVFF POSTINC2, TBLPTR
4062  F4F6     NOP
4064  C4DD     MOVFF POSTDEC2, TBLPTRH
4066  F4F7     NOP
4068  0E00     MOVLW 0x0
406A  6EF8     MOVWF 0xFF8, ACCESS
406C  0008     TBLRD*
406E  50F5     MOVF 0xFF5, W, ACCESS
4070  6F79     MOVWF WDTCON1, BANKED
4072  6B7A     CLRF WDTPS, BANKED
4074  5177     MOVF CM2PCH, W, BANKED
4076  2779     ADDWF WDTCON1, F, BANKED
4078  5178     MOVF WDTCON0, W, BANKED
407A  237A     ADDWFC WDTPS, F, BANKED
407C  517A     MOVF WDTPS, W, BANKED
407E  E10A     BNZ 0x4094
4080  0E0A     MOVLW 0xA
4082  5D79     SUBWF WDTCON1, W, BANKED
4084  A0D8     BTFSS 0xFD8, 0, ACCESS
4086  EF47     GOTO 0x408E
4088  F020     NOP
408A  EF4A     GOTO 0x4094
408C  F020     NOP
408E  0E01     MOVLW 0x1
4090  EF4B     GOTO 0x4096
4092  F020     NOP
4094  0E00     MOVLW 0x0
4096  6F83     MOVWF SPI1TCNTH, BANKED
4098  6B84     CLRF SPI1CON0, BANKED
409A  5183     MOVF SPI1TCNTH, W, BANKED
409C  1184     IORWF SPI1CON0, W, BANKED
409E  A4D8     BTFSS 0xFD8, 2, ACCESS
40A0  EF54     GOTO 0x40A8
40A2  F020     NOP
40A4  EF56     GOTO 0x40AC
40A6  F020     NOP
40A8  EF1C     GOTO 0x4038
40AA  F020     NOP
733:                           ++*fmt;
403A  F9CC     NOP
403C  F4D9     NOP
4040  F9D0     NOP
4042  F4DA     NOP
4044  2ADE     INCF 0xFDE, F, ACCESS
4046  0E00     MOVLW 0x0
4048  22DD     ADDWFC 0xFDD, F, ACCESS
734:                       }
735:                   }
736:           #endif
737:           
738:           #ifdef _VFPF_PRECISION
739:                   /* Get precision */
740:                   if ((*fmt)[0] == '.') {
40AE  F9CC     NOP
40B0  F4D9     NOP
40B4  F9D0     NOP
40B6  F4DA     NOP
40B8  C4DE     MOVFF POSTINC2, TBLPTR
40BA  F4F6     NOP
40BC  C4DD     MOVFF POSTDEC2, TBLPTRH
40BE  F4F7     NOP
40C0  0E00     MOVLW 0x0
40C2  6EF8     MOVWF 0xFF8, ACCESS
40C4  0008     TBLRD*
40C6  50F5     MOVF 0xFF5, W, ACCESS
40C8  0A2E     XORLW 0x2E
40CA  A4D8     BTFSS 0xFD8, 2, ACCESS
40CC  EF6A     GOTO 0x40D4
40CE  F020     NOP
40D0  EF6C     GOTO 0x40D8
40D2  F020     NOP
40D4  EF06     GOTO 0x420C
40D6  F021     NOP
741:                       prec = 0;
40D8  0E00     MOVLW 0x0
40DA  6FB4     MOVWF PRLOCK, BANKED
40DC  0E00     MOVLW 0x0
40DE  6FB3     MOVWF OSCEN, BANKED
742:                       ++*fmt;
40E2  F9CC     NOP
40E4  F4D9     NOP
40E8  F9D0     NOP
40EA  F4DA     NOP
40EC  2ADE     INCF 0xFDE, F, ACCESS
40EE  0E00     MOVLW 0x0
40F0  22DD     ADDWFC 0xFDD, F, ACCESS
743:                       if ((*fmt)[0] == '*') {
40F4  F9CC     NOP
40F6  F4D9     NOP
40FA  F9D0     NOP
40FC  F4DA     NOP
40FE  C4DE     MOVFF POSTINC2, TBLPTR
4100  F4F6     NOP
4102  C4DD     MOVFF POSTDEC2, TBLPTRH
4104  F4F7     NOP
4106  0E00     MOVLW 0x0
4108  6EF8     MOVWF 0xFF8, ACCESS
410A  0008     TBLRD*
410C  50F5     MOVF 0xFF5, W, ACCESS
410E  0A2A     XORLW 0x2A
4110  A4D8     BTFSS 0xFD8, 2, ACCESS
4112  EF8D     GOTO 0x411A
4114  F020     NOP
4116  EF8F     GOTO 0x411E
4118  F020     NOP
411A  EFB6     GOTO 0x416C
411C  F020     NOP
744:                           ++*fmt;
4120  F9CC     NOP
4122  F4D9     NOP
4126  F9D0     NOP
4128  F4DA     NOP
412A  2ADE     INCF 0xFDE, F, ACCESS
412C  0E00     MOVLW 0x0
412E  22DD     ADDWFC 0xFDD, F, ACCESS
745:                           prec = va_arg(ap, int);
4132  F9D4     NOP
4134  F4D9     NOP
4138  F9D8     NOP
413A  F4DA     NOP
413E  F37C     NOP
4140  F677     NOP
4142  0E02     MOVLW 0x2
4144  26DE     ADDWF 0xFDE, F, ACCESS
4148  F37C     NOP
414A  F678     NOP
414C  0E00     MOVLW 0x0
414E  22DD     ADDWFC 0xFDD, F, ACCESS
4152  F9DC     NOP
4154  F4D9     NOP
4158  F9E0     NOP
415A  F4DA     NOP
415E  F378     NOP
4160  F6B3     NOP
4164  F374     NOP
4166  F6B4     NOP
746:                       } else {
4168  EF06     GOTO 0x420C
416A  F021     NOP
747:                           prec = atoi(*fmt);
416E  F9CC     NOP
4170  F4D9     NOP
4174  F9D0     NOP
4176  F4DA     NOP
417A  F378     NOP
417C  F607     NOP
4180  F374     NOP
4182  F608     NOP
4184  ECB9     CALL 0x6B72, 0
4186  F035     NOP
418A  F81C     NOP
418C  F6B3     NOP
4190  F820     NOP
4192  F6B4     NOP
748:                           while (isdigit((*fmt)[0])) {
4194  EFD5     GOTO 0x41AA
4196  F020     NOP
41AA  0ED0     MOVLW 0xD0
41AC  0106     MOVLB 0x6
41AE  6F77     MOVWF CM2PCH, BANKED
41B0  0EFF     MOVLW 0xFF
41B2  6F78     MOVWF WDTCON0, BANKED
41B6  F9CC     NOP
41B8  F4D9     NOP
41BC  F9D0     NOP
41BE  F4DA     NOP
41C0  C4DE     MOVFF POSTINC2, TBLPTR
41C2  F4F6     NOP
41C4  C4DD     MOVFF POSTDEC2, TBLPTRH
41C6  F4F7     NOP
41C8  0E00     MOVLW 0x0
41CA  6EF8     MOVWF 0xFF8, ACCESS
41CC  0008     TBLRD*
41CE  50F5     MOVF 0xFF5, W, ACCESS
41D0  6F79     MOVWF WDTCON1, BANKED
41D2  6B7A     CLRF WDTPS, BANKED
41D4  5177     MOVF CM2PCH, W, BANKED
41D6  2779     ADDWF WDTCON1, F, BANKED
41D8  5178     MOVF WDTCON0, W, BANKED
41DA  237A     ADDWFC WDTPS, F, BANKED
41DC  517A     MOVF WDTPS, W, BANKED
41DE  E10A     BNZ 0x41F4
41E0  0E0A     MOVLW 0xA
41E2  5D79     SUBWF WDTCON1, W, BANKED
41E4  A0D8     BTFSS 0xFD8, 0, ACCESS
41E6  EFF7     GOTO 0x41EE
41E8  F020     NOP
41EA  EFFA     GOTO 0x41F4
41EC  F020     NOP
41EE  0E01     MOVLW 0x1
41F0  EFFB     GOTO 0x41F6
41F2  F020     NOP
41F4  0E00     MOVLW 0x0
41F6  6F85     MOVWF SPI1CON1, BANKED
41F8  6B86     CLRF SPI1CON2, BANKED
41FA  5185     MOVF SPI1CON1, W, BANKED
41FC  1186     IORWF SPI1CON2, W, BANKED
41FE  A4D8     BTFSS 0xFD8, 2, ACCESS
4200  EF04     GOTO 0x4208
4202  F021     NOP
4204  EF06     GOTO 0x420C
4206  F021     NOP
4208  EFCC     GOTO 0x4198
420A  F020     NOP
749:                               ++*fmt;
419A  F9CC     NOP
419C  F4D9     NOP
41A0  F9D0     NOP
41A2  F4DA     NOP
41A4  2ADE     INCF 0xFDE, F, ACCESS
41A6  0E00     MOVLW 0x0
41A8  22DD     ADDWFC 0xFDD, F, ACCESS
750:                           }
751:                       }
752:                   }
753:           #endif
754:           
755:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
756:                   /* Case-folded conversion types */
757:                   ct[0] = tolower((int)(*fmt)[0]);
420E  F9CC     NOP
4210  F4D9     NOP
4214  F9D0     NOP
4216  F4DA     NOP
4218  C4DE     MOVFF POSTINC2, TBLPTR
421A  F4F6     NOP
421C  C4DD     MOVFF POSTDEC2, TBLPTRH
421E  F4F7     NOP
4220  0E00     MOVLW 0x0
4222  6EF8     MOVWF 0xFF8, ACCESS
4224  0008     TBLRD*
4226  50F5     MOVF 0xFF5, W, ACCESS
4228  6F06     MOVWF 0x6, BANKED
422A  6B07     CLRF 0x7, BANKED
422C  ECFF     CALL 0x7FFE, 0
422E  F03F     NOP
4230  0106     MOVLB 0x6
4232  5106     MOVF 0x6, W, BANKED
4234  6F8D     MOVWF SPI2RXB, BANKED
758:                   if (ct[0]) {
4236  518D     MOVF SPI2RXB, W, BANKED
4238  B4D8     BTFSC 0xFD8, 2, ACCESS
423A  EF21     GOTO 0x4242
423C  F021     NOP
423E  EF23     GOTO 0x4246
4240  F021     NOP
4242  EF6D     GOTO 0x42DA
4244  F021     NOP
759:                       ct[1] = tolower((int)(*fmt)[1]);
4248  F9CC     NOP
424A  F4D9     NOP
424E  F9D0     NOP
4250  F4DA     NOP
4254  F378     NOP
4256  F677     NOP
425A  F374     NOP
425C  F678     NOP
425E  0E01     MOVLW 0x1
4260  2777     ADDWF CM2PCH, F, BANKED
4262  0E00     MOVLW 0x0
4264  2378     ADDWFC WDTCON0, F, BANKED
4268  F9DC     NOP
426A  F4F6     NOP
426E  F9E0     NOP
4270  F4F7     NOP
4272  0E00     MOVLW 0x0
4274  6EF8     MOVWF 0xFF8, ACCESS
4276  0008     TBLRD*
4278  50F5     MOVF 0xFF5, W, ACCESS
427A  6F06     MOVWF 0x6, BANKED
427C  6B07     CLRF 0x7, BANKED
427E  ECFF     CALL 0x7FFE, 0
4280  F03F     NOP
4282  0106     MOVLB 0x6
4284  5106     MOVF 0x6, W, BANKED
4286  6F8E     MOVWF SPI2TXB, BANKED
760:                       if (ct[1]) {
4288  518E     MOVF SPI2TXB, W, BANKED
428A  B4D8     BTFSC 0xFD8, 2, ACCESS
428C  EF4A     GOTO 0x4294
428E  F021     NOP
4290  EF4C     GOTO 0x4298
4292  F021     NOP
4294  EF6D     GOTO 0x42DA
4296  F021     NOP
761:                           ct[2] = tolower((int)(*fmt)[2]);
429A  F9CC     NOP
429C  F4D9     NOP
42A0  F9D0     NOP
42A2  F4DA     NOP
42A6  F378     NOP
42A8  F677     NOP
42AC  F374     NOP
42AE  F678     NOP
42B0  0E02     MOVLW 0x2
42B2  2777     ADDWF CM2PCH, F, BANKED
42B4  0E00     MOVLW 0x0
42B6  2378     ADDWFC WDTCON0, F, BANKED
42BA  F9DC     NOP
42BC  F4F6     NOP
42C0  F9E0     NOP
42C2  F4F7     NOP
42C4  0E00     MOVLW 0x0
42C6  6EF8     MOVWF 0xFF8, ACCESS
42C8  0008     TBLRD*
42CA  50F5     MOVF 0xFF5, W, ACCESS
42CC  6F06     MOVWF 0x6, BANKED
42CE  6B07     CLRF 0x7, BANKED
42D0  ECFF     CALL 0x7FFE, 0
42D2  F03F     NOP
42D4  0106     MOVLB 0x6
42D6  5106     MOVF 0x6, W, BANKED
42D8  6F8F     MOVWF SPI2TCNT, BANKED
762:                       }
763:                   }
764:           #endif
765:           
766:           #ifdef _VFPF_A
767:                   /* 'a' style (hex) floating point */
768:                   if (ct[0] == 'a') {
769:           
770:                       c = (*fmt)[0];
771:                       ++*fmt;
772:                       f = (long double)va_arg(ap, double);
773:                                   
774:                       return atoa(fp, f, c);
775:                   }
776:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
777:           
778:                       c = (*fmt)[1];
779:                       if (isupper((int)(*fmt)[0])) {
780:                           f = va_arg(ap, long double);
781:                       } else {
782:                           f = (long double)va_arg(ap, double);
783:                       }
784:                       *fmt += CSTRLEN("la");
785:                                   
786:                       return atoa(fp, f, c);
787:                   }
788:           #endif
789:           
790:           #ifdef _VFPF_C
791:                   /* Character */
792:                   if (*fmt[0] == 'c') {
793:                       ++*fmt;
794:                       c = (unsigned char)va_arg(ap, int);
795:                       return ctoa(fp, c);
796:                   }
797:           #endif
798:           
799:           #ifdef _VFPF_D
800:           #ifdef _VFPF_HH
801:                   /* Character decimal integer */
802:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
803:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
804:           
805:                       *fmt += CSTRLEN("hhd");
806:                       ll = (long long)(signed char)va_arg(ap, int);
807:                                   
808:                       return dtoa(fp, ll);
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_H
813:                   /* Short decimal integer */
814:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
815:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
816:           
817:                       *fmt += CSTRLEN("hd");
818:                       ll = (long long)(short)va_arg(ap, int);
819:                                   
820:                       return dtoa(fp, ll);
821:                   }
822:           #endif
823:           
824:                   /* Decimal integer */
825:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
42DC  F9CC     NOP
42DE  F4D9     NOP
42E2  F9D0     NOP
42E4  F4DA     NOP
42E6  C4DE     MOVFF POSTINC2, TBLPTR
42E8  F4F6     NOP
42EA  C4DD     MOVFF POSTDEC2, TBLPTRH
42EC  F4F7     NOP
42EE  0E00     MOVLW 0x0
42F0  6EF8     MOVWF 0xFF8, ACCESS
42F2  0008     TBLRD*
42F4  50F5     MOVF 0xFF5, W, ACCESS
42F6  0A64     XORLW 0x64
42F8  B4D8     BTFSC 0xFD8, 2, ACCESS
42FA  EF81     GOTO 0x4302
42FC  F021     NOP
42FE  EF83     GOTO 0x4306
4300  F021     NOP
4302  EF99     GOTO 0x4332
4304  F021     NOP
4308  F9CC     NOP
430A  F4D9     NOP
430E  F9D0     NOP
4310  F4DA     NOP
4312  C4DE     MOVFF POSTINC2, TBLPTR
4314  F4F6     NOP
4316  C4DD     MOVFF POSTDEC2, TBLPTRH
4318  F4F7     NOP
431A  0E00     MOVLW 0x0
431C  6EF8     MOVWF 0xFF8, ACCESS
431E  0008     TBLRD*
4320  50F5     MOVF 0xFF5, W, ACCESS
4322  0A69     XORLW 0x69
4324  A4D8     BTFSS 0xFD8, 2, ACCESS
4326  EF97     GOTO 0x432E
4328  F021     NOP
432A  EF99     GOTO 0x4332
432C  F021     NOP
432E  EFEF     GOTO 0x43DE
4330  F021     NOP
826:           
827:                       ++*fmt;
4334  F9CC     NOP
4336  F4D9     NOP
433A  F9D0     NOP
433C  F4DA     NOP
433E  2ADE     INCF 0xFDE, F, ACCESS
4340  0E00     MOVLW 0x0
4342  22DD     ADDWFC 0xFDD, F, ACCESS
828:                       ll = (long long)va_arg(ap, int);
4346  F9D4     NOP
4348  F4D9     NOP
434C  F9D8     NOP
434E  F4DA     NOP
4352  F37C     NOP
4354  F677     NOP
4356  0E02     MOVLW 0x2
4358  26DE     ADDWF 0xFDE, F, ACCESS
435C  F37C     NOP
435E  F678     NOP
4360  0E00     MOVLW 0x0
4362  22DD     ADDWFC 0xFDD, F, ACCESS
4366  F9DC     NOP
4368  F4D9     NOP
436C  F9E0     NOP
436E  F4DA     NOP
4372  F378     NOP
4374  F67B     NOP
4378  F374     NOP
437A  F67C     NOP
437C  0E00     MOVLW 0x0
437E  BF7C     BTFSC WDTTMR, 7, BANKED
4380  0EFF     MOVLW 0xFF
4382  6F7D     MOVWF DAC1DAT, BANKED
4384  6F7E     MOVWF 0x7E, BANKED
4386  6F7F     MOVWF DAC1CON, BANKED
4388  6F80     MOVWF SPI1RXB, BANKED
438A  6F81     MOVWF SPI1TXB, BANKED
438C  6F82     MOVWF SPI1TCNT, BANKED
829:                                   
830:                       return dtoa(fp, ll);
4390  F9C4     NOP
4392  F61D     NOP
4396  F9C8     NOP
4398  F61E     NOP
439C  F9EC     NOP
439E  F61F     NOP
43A2  F9F0     NOP
43A4  F620     NOP
43A8  F9F4     NOP
43AA  F621     NOP
43AE  F9F8     NOP
43B0  F622     NOP
43B4  F9FC     NOP
43B6  F623     NOP
43BA  FA00     NOP
43BC  F624     NOP
43C0  FA04     NOP
43C2  F625     NOP
43C6  FA08     NOP
43C8  F626     NOP
43CA  ECD2     CALL 0x61A4, 0
43CC  F030     NOP
43D0  F874     NOP
43D2  F671     NOP
43D6  F878     NOP
43D8  F672     NOP
43DA  EF8A     GOTO 0x4714
43DC  F023     NOP
831:                   }
832:           
833:           #ifdef _VFPF_L
834:                   /* Long decimal integer */
835:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
836:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
837:           
838:                       *fmt += CSTRLEN("ld");
839:                       ll = (long long)va_arg(ap, long);
840:                                   
841:                       return dtoa(fp, ll);
842:                   }
843:           #endif
844:           
845:           #ifdef _VFPF_LL
846:                   /* Long long decimal integer */
847:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
848:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
849:           
850:                       *fmt += CSTRLEN("lld");
851:                       ll = va_arg(ap, long long);
852:                                   
853:                       return dtoa(fp, ll);
854:                   }
855:           #endif
856:           
857:           #ifdef _VFPF_J
858:                   /* intmax_t decimal integer */
859:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
860:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
861:           
862:                       *fmt += CSTRLEN("jd");
863:                       ll = (long long)va_arg(ap, intmax_t);
864:                                   
865:                       return dtoa(fp, ll);
866:                   }
867:           #endif
868:           
869:           #ifdef _VFPF_T
870:                   /* ptrdiff_t decimal integer */
871:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
872:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
873:           
874:                       *fmt += CSTRLEN("td");
875:                       ll = (long long)va_arg(ap, ptrdiff_t);
876:                                   
877:                       return dtoa(fp, ll);
878:                   }
879:           #endif
880:           
881:           #ifdef _VFPF_Z
882:                   /* size_t decimal integer */
883:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
884:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
885:           
886:                       *fmt += CSTRLEN("zd");
887:                       ll = (long long)va_arg(ap, size_t);
888:                                   
889:                       return dtoa(fp, ll);
890:                   }
891:           #endif
892:           #endif
893:           
894:           #ifdef _VFPF_E
895:                   /* 'e' style floating point */
896:                   if (ct[0] == 'e') {
897:           
898:                       c = (*fmt)[0];
899:                       ++*fmt;
900:                       f = (long double)va_arg(ap, double);
901:                                   
902:                       return efgtoa(fp, f, c);
903:                   }
904:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
905:           
906:                       c = (*fmt)[1];
907:                       if (isupper((int)(*fmt)[0])) {
908:                           f = va_arg(ap, long double);
909:                       } else {
910:                           f = (long double)va_arg(ap, double);
911:                       }
912:                       *fmt += CSTRLEN("lf");
913:                                   
914:                       return efgtoa(fp, f, c);
915:                   }
916:           #endif
917:           
918:           #ifdef _VFPF_F
919:                   /* 'f' style floating point */
920:                   if (ct[0] == 'f') {
43DE  0E66     MOVLW 0x66
43E0  198D     XORWF SPI2RXB, W, BANKED
43E2  A4D8     BTFSS 0xFD8, 2, ACCESS
43E4  EFF6     GOTO 0x43EC
43E6  F021     NOP
43E8  EFF8     GOTO 0x43F0
43EA  F021     NOP
43EC  EF52     GOTO 0x44A4
43EE  F022     NOP
921:           
922:                       c = (*fmt)[0];
43F2  F9CC     NOP
43F4  F4D9     NOP
43F8  F9D0     NOP
43FA  F4DA     NOP
43FC  C4DE     MOVFF POSTINC2, TBLPTR
43FE  F4F6     NOP
4400  C4DD     MOVFF POSTDEC2, TBLPTRH
4402  F4F7     NOP
4404  0E00     MOVLW 0x0
4406  6EF8     MOVWF 0xFF8, ACCESS
4408  0008     TBLRD*
440C  F3D4     NOP
440E  F690     NOP
923:                       ++*fmt;
4412  F9CC     NOP
4414  F4D9     NOP
4418  F9D0     NOP
441A  F4DA     NOP
441C  2ADE     INCF 0xFDE, F, ACCESS
441E  0E00     MOVLW 0x0
4420  22DD     ADDWFC 0xFDD, F, ACCESS
924:                       f = (long double)va_arg(ap, double);
4424  F9D4     NOP
4426  F4D9     NOP
442A  F9D8     NOP
442C  F4DA     NOP
4430  F37C     NOP
4432  F677     NOP
4434  0E04     MOVLW 0x4
4436  26DE     ADDWF 0xFDE, F, ACCESS
443A  F37C     NOP
443C  F678     NOP
443E  0E00     MOVLW 0x0
4440  22DD     ADDWFC 0xFDD, F, ACCESS
4444  F9DC     NOP
4446  F4D9     NOP
444A  F9E0     NOP
444C  F4DA     NOP
4450  F378     NOP
4452  F689     NOP
4456  F378     NOP
4458  F68A     NOP
445C  F378     NOP
445E  F68B     NOP
4462  F378     NOP
4464  F68C     NOP
925:                                   
926:                       return efgtoa(fp, f, c);
4468  F9C4     NOP
446A  F62D     NOP
446E  F9C8     NOP
4470  F62E     NOP
4474  FA24     NOP
4476  F62F     NOP
447A  FA28     NOP
447C  F630     NOP
4480  FA2C     NOP
4482  F631     NOP
4486  FA30     NOP
4488  F632     NOP
448C  FA40     NOP
448E  F633     NOP
4490  ECAE     CALL 0x255C, 0
4492  F012     NOP
4496  F8B4     NOP
4498  F671     NOP
449C  F8B8     NOP
449E  F672     NOP
44A0  EF8A     GOTO 0x4714
44A2  F023     NOP
927:                   }
928:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
44A4  0E8D     MOVLW 0x8D
44A6  6F00     MOVWF txData, BANKED
44A8  0E06     MOVLW 0x6
44AA  6F01     MOVWF 0x1, BANKED
44AC  0E57     MOVLW 0x57
44AE  6F02     MOVWF 0x2, BANKED
44B0  0E25     MOVLW 0x25
44B2  6F03     MOVWF 0x3, BANKED
44B4  0E00     MOVLW 0x0
44B6  6F05     MOVWF 0x5, BANKED
44B8  0E02     MOVLW 0x2
44BA  6F04     MOVWF 0x4, BANKED
44BC  EC00     CALL 0x7600, 0
44BE  F03B     NOP
44C0  0106     MOVLB 0x6
44C2  5100     MOVF txData, W, BANKED
44C4  1101     IORWF 0x1, W, BANKED
44C6  A4D8     BTFSS 0xFD8, 2, ACCESS
44C8  EF68     GOTO 0x44D0
44CA  F022     NOP
44CC  EF6A     GOTO 0x44D4
44CE  F022     NOP
44D0  EF25     GOTO 0x464A
44D2  F023     NOP
929:           
930:                       c = (*fmt)[1];
44D6  F9CC     NOP
44D8  F4D9     NOP
44DC  F9D0     NOP
44DE  F4DA     NOP
44E2  F378     NOP
44E4  F677     NOP
44E8  F374     NOP
44EA  F678     NOP
44EC  0E01     MOVLW 0x1
44EE  2777     ADDWF CM2PCH, F, BANKED
44F0  0E00     MOVLW 0x0
44F2  2378     ADDWFC WDTCON0, F, BANKED
44F6  F9DC     NOP
44F8  F4F6     NOP
44FC  F9E0     NOP
44FE  F4F7     NOP
4500  0E00     MOVLW 0x0
4502  6EF8     MOVWF 0xFF8, ACCESS
4504  0008     TBLRD*
4508  F3D4     NOP
450A  F690     NOP
931:                       if (isupper((int)(*fmt)[0])) {
450C  0EBF     MOVLW 0xBF
450E  6F77     MOVWF CM2PCH, BANKED
4510  0EFF     MOVLW 0xFF
4512  6F78     MOVWF WDTCON0, BANKED
4516  F9CC     NOP
4518  F4D9     NOP
451C  F9D0     NOP
451E  F4DA     NOP
4520  C4DE     MOVFF POSTINC2, TBLPTR
4522  F4F6     NOP
4524  C4DD     MOVFF POSTDEC2, TBLPTRH
4526  F4F7     NOP
4528  0E00     MOVLW 0x0
452A  6EF8     MOVWF 0xFF8, ACCESS
452C  0008     TBLRD*
452E  50F5     MOVF 0xFF5, W, ACCESS
4530  6F79     MOVWF WDTCON1, BANKED
4532  6B7A     CLRF WDTPS, BANKED
4534  5177     MOVF CM2PCH, W, BANKED
4536  2779     ADDWF WDTCON1, F, BANKED
4538  5178     MOVF WDTCON0, W, BANKED
453A  237A     ADDWFC WDTPS, F, BANKED
453C  517A     MOVF WDTPS, W, BANKED
453E  E10A     BNZ 0x4554
4540  0E1A     MOVLW 0x1A
4542  5D79     SUBWF WDTCON1, W, BANKED
4544  A0D8     BTFSS 0xFD8, 0, ACCESS
4546  EFA7     GOTO 0x454E
4548  F022     NOP
454A  EFAA     GOTO 0x4554
454C  F022     NOP
454E  0E01     MOVLW 0x1
4550  EFAB     GOTO 0x4556
4552  F022     NOP
4554  0E00     MOVLW 0x0
4556  6F87     MOVWF SPI1STATUS, BANKED
4558  6B88     CLRF SPI1TWIDTH, BANKED
455A  5187     MOVF SPI1STATUS, W, BANKED
455C  1188     IORWF SPI1TWIDTH, W, BANKED
455E  B4D8     BTFSC 0xFD8, 2, ACCESS
4560  EFB4     GOTO 0x4568
4562  F022     NOP
4564  EFB6     GOTO 0x456C
4566  F022     NOP
4568  EFDA     GOTO 0x45B4
456A  F022     NOP
932:                           f = va_arg(ap, long double);
456E  F9D4     NOP
4570  F4D9     NOP
4574  F9D8     NOP
4576  F4DA     NOP
457A  F37C     NOP
457C  F677     NOP
457E  0E04     MOVLW 0x4
4580  26DE     ADDWF 0xFDE, F, ACCESS
4584  F37C     NOP
4586  F678     NOP
4588  0E00     MOVLW 0x0
458A  22DD     ADDWFC 0xFDD, F, ACCESS
458E  F9DC     NOP
4590  F4D9     NOP
4594  F9E0     NOP
4596  F4DA     NOP
459A  F378     NOP
459C  F689     NOP
45A0  F378     NOP
45A2  F68A     NOP
45A6  F378     NOP
45A8  F68B     NOP
45AC  F378     NOP
45AE  F68C     NOP
933:                       } else {
45B0  EFFC     GOTO 0x45F8
45B2  F022     NOP
934:                           f = (long double)va_arg(ap, double);
45B6  F9D4     NOP
45B8  F4D9     NOP
45BC  F9D8     NOP
45BE  F4DA     NOP
45C2  F37C     NOP
45C4  F677     NOP
45C6  0E04     MOVLW 0x4
45C8  26DE     ADDWF 0xFDE, F, ACCESS
45CC  F37C     NOP
45CE  F678     NOP
45D0  0E00     MOVLW 0x0
45D2  22DD     ADDWFC 0xFDD, F, ACCESS
45D6  F9DC     NOP
45D8  F4D9     NOP
45DC  F9E0     NOP
45DE  F4DA     NOP
45E2  F378     NOP
45E4  F689     NOP
45E8  F378     NOP
45EA  F68A     NOP
45EE  F378     NOP
45F0  F68B     NOP
45F4  F378     NOP
45F6  F68C     NOP
935:                       }
936:                       *fmt += CSTRLEN("lf");
45F8  0E02     MOVLW 0x2
45FC  F9CC     NOP
45FE  F4D9     NOP
4602  F9D0     NOP
4604  F4DA     NOP
4606  26DE     ADDWF 0xFDE, F, ACCESS
4608  0E00     MOVLW 0x0
460A  22DD     ADDWFC 0xFDD, F, ACCESS
937:                                   
938:                       return efgtoa(fp, f, c);
460E  F9C4     NOP
4610  F62D     NOP
4614  F9C8     NOP
4616  F62E     NOP
461A  FA24     NOP
461C  F62F     NOP
4620  FA28     NOP
4622  F630     NOP
4626  FA2C     NOP
4628  F631     NOP
462C  FA30     NOP
462E  F632     NOP
4632  FA40     NOP
4634  F633     NOP
4636  ECAE     CALL 0x255C, 0
4638  F012     NOP
463C  F8B4     NOP
463E  F671     NOP
4642  F8B8     NOP
4644  F672     NOP
4646  EF8A     GOTO 0x4714
4648  F023     NOP
939:                   }
940:           #endif
941:           
942:           #ifdef _VFPF_G
943:                   /* 'g' style floating point */
944:                   if (ct[0] == 'g') {
945:           
946:                       c = (*fmt)[0];
947:                       ++*fmt;
948:                       f = (long double)va_arg(ap, double);
949:                                   
950:                       return efgtoa(fp, f, c);
951:                   }
952:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
953:           
954:                       c = (*fmt)[1];
955:                       if (isupper((int)(*fmt)[0])) {
956:                           f = va_arg(ap, long double);
957:                       } else {
958:                           f = (long double)va_arg(ap, double);
959:                       }
960:                       *fmt += CSTRLEN("lg");
961:                                   
962:                       return efgtoa(fp, f, c);
963:                   }
964:           #endif
965:           
966:           #ifdef _VFPF_O
967:           #ifdef _VFPF_HH
968:                   /* Character octal integer */
969:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
970:           
971:                       *fmt += CSTRLEN("hho");
972:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
973:                                   
974:                       return otoa(fp, llu);
975:                   }
976:           #endif
977:           
978:           #ifdef _VFPF_H
979:                   /* Short octal integer */
980:                   if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
981:           
982:                       *fmt += CSTRLEN("ho");
983:                       llu = (unsigned long long)(unsigned short)va_arg(ap, int);
984:                                   
985:                       return otoa(fp, llu);
986:                   }
987:           #endif
988:           
989:                   /* Octal integer */
990:                   if (*fmt[0] == 'o') {
991:           
992:                       ++*fmt;
993:                       llu = (unsigned long long)va_arg(ap, unsigned int);
994:                                   
995:                       return otoa(fp, llu);
996:                   }
997:           
998:           #ifdef _VFPF_L
999:                   /* Long octal integer */
1000:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1001:          
1002:                      *fmt += CSTRLEN("lo");
1003:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1004:                                  
1005:                      return otoa(fp, llu);
1006:                  }
1007:          #endif
1008:          
1009:          #ifdef _VFPF_LL
1010:                  /* Long long octal integer */
1011:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1012:          
1013:                      *fmt += CSTRLEN("llo");
1014:                      llu = va_arg(ap, unsigned long long);
1015:                                  
1016:                      return otoa(fp, llu);
1017:                  }
1018:          #endif
1019:          
1020:          #ifdef _VFPF_J
1021:                  /* uintmax_t octal integer */
1022:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1023:          
1024:                      *fmt += CSTRLEN("jo");
1025:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_T
1032:                  /* ptrdiff_t octal integer */
1033:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1034:          
1035:                      *fmt += CSTRLEN("to");
1036:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_Z
1043:                  /* size_t octal integer */
1044:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
1045:          
1046:                      *fmt += CSTRLEN("zo");
1047:                      llu = (unsigned long long)va_arg(ap, size_t);
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          #endif
1053:          
1054:                  /* Character count */
1055:          #ifdef _VFPF_N
1056:          
1057:          #ifdef _VFPF_HH
1058:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
1059:          
1060:                      *fmt += CSTRLEN("hhn");
1061:                      vp = (void *)va_arg(ap, char *);
1062:                      *(char *)vp = (char)nout;
1063:                      return 0;
1064:                  }
1065:          #endif
1066:          
1067:          #ifdef _VFPF_H
1068:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
1069:          
1070:                      *fmt += CSTRLEN("hn");
1071:                      vp = (void *)va_arg(ap, short *);
1072:                      *(short *)vp = (short)nout;
1073:                      return 0;
1074:                  }
1075:          #endif
1076:          
1077:                  if (*fmt[0] == 'n') {
1078:                      ++*fmt;
1079:                      vp = (void *)va_arg(ap, int *);
1080:                      *(int *)vp = nout;
1081:                      return 0;
1082:                  }
1083:          
1084:          #ifdef _VFPF_L
1085:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1086:          
1087:                      *fmt += CSTRLEN("ln");
1088:                      vp = (void *)va_arg(ap, long *);
1089:                      *(long *)vp = (long)nout;
1090:                      return 0;
1091:                  }
1092:          #endif
1093:          
1094:          #ifdef _VFPF_LL
1095:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1096:          
1097:                      *fmt += CSTRLEN("lln");
1098:                      vp = (void *)va_arg(ap, long long *);
1099:                      *(long long *)vp = (long long)nout;
1100:                      return 0;
1101:                  }
1102:          #endif
1103:          
1104:          #ifdef _VFPF_J
1105:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1106:          
1107:                      *fmt += CSTRLEN("jn");
1108:                      vp = (void *)va_arg(ap, uintmax_t *);
1109:                      *(uintmax_t *)vp = (uintmax_t)nout;
1110:                      return 0;
1111:                  }
1112:          #endif
1113:          
1114:          #ifdef _VFPF_T
1115:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1116:          
1117:                      *fmt += CSTRLEN("tn");
1118:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1119:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1120:                      return 0;
1121:                  }
1122:          #endif
1123:          
1124:          #ifdef _VFPF_Z
1125:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
1126:          
1127:                      *fmt += CSTRLEN("zn");
1128:                      vp = (void *)va_arg(ap, size_t *);
1129:                      *(size_t *)vp = (size_t)nout;
1130:                      return 0;
1131:                  }
1132:          #endif
1133:          
1134:          #endif
1135:          
1136:          #ifdef _VFPF_P
1137:                  /* Pointer */
1138:                  if (*fmt[0] == 'p') {
1139:          
1140:                      ++*fmt;
1141:                      llu = (unsigned long long)(size_t)va_arg(ap, void *);
1142:                                  
1143:                      return xtoa(fp, llu, 'x');
1144:                  }
1145:          #endif
1146:          
1147:          #ifdef _VFPF_S
1148:                  /* String */
1149:                  if (*fmt[0] == 's') {
1150:          
1151:                      ++*fmt;
1152:                      cp = va_arg(ap, char *);
1153:          
1154:                      return stoa(fp, cp);
1155:                  }
1156:          #endif
1157:          
1158:          #ifdef _VFPF_U
1159:          #ifdef _VFPF_HH
1160:                  /* Unsigned character decimal integer */
1161:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1162:          
1163:                      *fmt += CSTRLEN("hhu");
1164:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1165:                                  
1166:                      return utoa(fp, llu);
1167:                  }
1168:          #endif
1169:          
1170:          #ifdef _VFPF_H
1171:                  /* Unsigned short decimal integer */
1172:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1173:          
1174:                      *fmt += CSTRLEN("hu");
1175:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1176:                                  
1177:                      return utoa(fp, llu);
1178:                  }
1179:          #endif
1180:          
1181:                  /* Unsigned decimal integer */
1182:                  if (*fmt[0] == 'u') {
1183:          
1184:                      ++*fmt;
1185:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1186:                                  
1187:                      return utoa(fp, llu);
1188:                  }
1189:          
1190:          #ifdef _VFPF_L
1191:                  /* Unsigned long decimal integer */
1192:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
1193:          
1194:                      *fmt += CSTRLEN("lu");
1195:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1196:                                  
1197:                      return utoa(fp, llu);
1198:                  }
1199:          #endif
1200:          
1201:          #ifdef _VFPF_LL
1202:                  /* Unsigned long long decimal integer */
1203:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1204:          
1205:                      *fmt += CSTRLEN("llu");
1206:                      llu = va_arg(ap, unsigned long long);
1207:                                  
1208:                      return utoa(fp, llu);
1209:                  }
1210:          #endif
1211:          
1212:          #ifdef _VFPF_J
1213:                  /* uintmax_t decimal integer */
1214:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1215:          
1216:                      *fmt += CSTRLEN("ju");
1217:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_T
1224:                  /* ptrdiff_t decimal integer */
1225:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1226:          
1227:                      *fmt += CSTRLEN("tu");
1228:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_Z
1235:                  /* size_t decimal integer */
1236:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1237:          
1238:                      *fmt += CSTRLEN("zu");
1239:                      llu = (unsigned long long)va_arg(ap, size_t);
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          #endif
1245:          
1246:          #ifdef _VFPF_X
1247:          #ifdef _VFPF_HH
1248:                  /* Character hexadecimal integer */
1249:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
1250:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1251:          
1252:                      c = (*fmt)[2];
1253:                      *fmt += CSTRLEN("hhx");
1254:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1255:                                  
1256:                      return xtoa(fp, llu, c);
1257:                  }
1258:          #endif
1259:          
1260:          #ifdef _VFPF_H
1261:                  /* Short hexadecimal integer */
1262:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1263:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1264:          
1265:                      c = (*fmt)[1];
1266:                      *fmt += CSTRLEN("hx");
1267:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1268:                                  
1269:                      return xtoa(fp, llu, c);
1270:                  }
1271:          #endif
1272:          
1273:                  /* Hexadecimal integer */
1274:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
1275:          
1276:                      c = (*fmt)[0];
1277:                      ++*fmt;
1278:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1279:                                  
1280:                      return xtoa(fp, llu, c);
1281:                  }
1282:          
1283:          #ifdef _VFPF_L
1284:                  /* Long hexadecimal integer */
1285:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1286:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1287:          
1288:                      c = (*fmt)[1];
1289:                      *fmt += CSTRLEN("lx");
1290:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1291:                                  
1292:                      return xtoa(fp, llu, c);
1293:                  }
1294:          #endif
1295:          
1296:          #ifdef _VFPF_LL
1297:                  /* Long long hexadecimal integer */
1298:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1299:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1300:          
1301:                      c = (*fmt)[2];
1302:                      *fmt += CSTRLEN("llx");
1303:                      llu = va_arg(ap, unsigned long long);
1304:                                  
1305:                      return xtoa(fp, llu, c);
1306:                  }
1307:          #endif
1308:          
1309:          #ifdef _VFPF_J
1310:                  /* uintmax_t hexadecimal integer */
1311:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1312:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1313:          
1314:                      c = (*fmt)[1];
1315:                      *fmt += CSTRLEN("jx");
1316:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1317:                                  
1318:                      return xtoa(fp, llu, c);
1319:                  }
1320:          #endif
1321:          
1322:          #ifdef _VFPF_T
1323:                  /* ptrdiff_t hexadecimal integer */
1324:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1325:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1326:          
1327:                      c = (*fmt)[1];
1328:                      *fmt += CSTRLEN("tx");
1329:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1330:                                  
1331:                      return xtoa(fp, llu, c);
1332:                  }
1333:          #endif
1334:          
1335:          #ifdef _VFPF_Z
1336:                  /* size_t hexadecimal integer */
1337:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1338:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1339:          
1340:                      c = (*fmt)[1];
1341:                      *fmt += CSTRLEN("zx");
1342:                      llu = (unsigned long long)va_arg(ap, size_t);
1343:                                  
1344:                      return xtoa(fp, llu, c);
1345:                  }
1346:          #endif
1347:          #endif
1348:          
1349:                  /* 'Escaped' '%' character */
1350:                  if ((*fmt)[0] == '%') {
464C  F9CC     NOP
464E  F4D9     NOP
4652  F9D0     NOP
4654  F4DA     NOP
4656  C4DE     MOVFF POSTINC2, TBLPTR
4658  F4F6     NOP
465A  C4DD     MOVFF POSTDEC2, TBLPTRH
465C  F4F7     NOP
465E  0E00     MOVLW 0x0
4660  6EF8     MOVWF 0xFF8, ACCESS
4662  0008     TBLRD*
4664  50F5     MOVF 0xFF5, W, ACCESS
4666  0A25     XORLW 0x25
4668  A4D8     BTFSS 0xFD8, 2, ACCESS
466A  EF39     GOTO 0x4672
466C  F023     NOP
466E  EF3B     GOTO 0x4676
4670  F023     NOP
4672  EF57     GOTO 0x46AE
4674  F023     NOP
1351:                      ++*fmt;
4678  F9CC     NOP
467A  F4D9     NOP
467E  F9D0     NOP
4680  F4DA     NOP
4682  2ADE     INCF 0xFDE, F, ACCESS
4684  0E00     MOVLW 0x0
4686  22DD     ADDWFC 0xFDD, F, ACCESS
1352:                      fputc((int)'%', fp);
4688  0E00     MOVLW 0x0
468A  6F03     MOVWF 0x3, BANKED
468C  0E25     MOVLW 0x25
468E  6F02     MOVWF 0x2, BANKED
4692  F9C4     NOP
4694  F604     NOP
4698  F9C8     NOP
469A  F605     NOP
469C  EC5F     CALL 0x7ABE, 0
469E  F03D     NOP
1353:                      return 1;
46A0  0E00     MOVLW 0x0
46A2  0106     MOVLB 0x6
46A4  6F72     MOVWF CM1NCH, BANKED
46A6  0E01     MOVLW 0x1
46A8  6F71     MOVWF CM1CON1, BANKED
46AA  EF8A     GOTO 0x4714
46AC  F023     NOP
1354:                  }
1355:          
1356:                  /* Unrecognized conversion */
1357:                  ++*fmt;
46B0  F9CC     NOP
46B2  F4D9     NOP
46B6  F9D0     NOP
46B8  F4DA     NOP
46BA  2ADE     INCF 0xFDE, F, ACCESS
46BC  0E00     MOVLW 0x0
46BE  22DD     ADDWFC 0xFDD, F, ACCESS
1358:                  return 0;
46C0  0E00     MOVLW 0x0
46C2  6F72     MOVWF CM1NCH, BANKED
46C4  0E00     MOVLW 0x0
46C6  6F71     MOVWF CM1CON1, BANKED
46C8  EF8A     GOTO 0x4714
46CA  F023     NOP
1359:              }
1360:          
1361:              /* No conversion, just intervening text */
1362:              fputc((int)(*fmt)[0], fp);
46CE  F9CC     NOP
46D0  F4D9     NOP
46D4  F9D0     NOP
46D6  F4DA     NOP
46D8  C4DE     MOVFF POSTINC2, TBLPTR
46DA  F4F6     NOP
46DC  C4DD     MOVFF POSTDEC2, TBLPTRH
46DE  F4F7     NOP
46E0  0E00     MOVLW 0x0
46E2  6EF8     MOVWF 0xFF8, ACCESS
46E4  0008     TBLRD*
46E6  50F5     MOVF 0xFF5, W, ACCESS
46E8  0106     MOVLB 0x6
46EA  6F02     MOVWF 0x2, BANKED
46EC  6B03     CLRF 0x3, BANKED
46F0  F9C4     NOP
46F2  F604     NOP
46F6  F9C8     NOP
46F8  F605     NOP
46FA  EC5F     CALL 0x7ABE, 0
46FC  F03D     NOP
1363:              ++*fmt;
4700  F9CC     NOP
4702  F4D9     NOP
4706  F9D0     NOP
4708  F4DA     NOP
470A  2ADE     INCF 0xFDE, F, ACCESS
470C  0E00     MOVLW 0x0
470E  22DD     ADDWFC 0xFDD, F, ACCESS
4710  EF50     GOTO 0x46A0
4712  F023     NOP
1364:              return 1;
1365:          }
4714  0012     RETURN 0
1366:          #endif
1367:          
1368:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
1369:          {
1370:          #ifdef _VFPF_CONVERT
1371:              char *cfmt;
1372:          
1373:              cfmt = (char *)fmt;
7EA0  FA4C     NOP
7EA2  F697     NOP
7EA6  FA50     NOP
7EA8  F698     NOP
1374:              nout = 0;
7EAA  0E00     MOVLW 0x0
7EAC  0106     MOVLB 0x6
7EAE  6FB0     MOVWF OSCTUNE, BANKED
7EB0  0E00     MOVLW 0x0
7EB2  6FAF     MOVWF OSCCON3, BANKED
1375:              while (*cfmt) {
7EB4  EF73     GOTO 0x7EE6
7EB6  F03F     NOP
7EE8  FA5C     NOP
7EEA  F4F6     NOP
7EEE  FA60     NOP
7EF0  F4F7     NOP
7EF2  0E00     MOVLW 0x0
7EF4  6EF8     MOVWF 0xFF8, ACCESS
7EF6  0008     TBLRD*
7EF8  50F5     MOVF 0xFF5, W, ACCESS
7EFA  0900     IORLW 0x0
7EFC  A4D8     BTFSS 0xFD8, 2, ACCESS
7EFE  EF83     GOTO 0x7F06
7F00  F03F     NOP
7F02  EF85     GOTO 0x7F0A
7F04  F03F     NOP
7F06  EF5C     GOTO 0x7EB8
7F08  F03F     NOP
1376:                  nout += vfpfcnvrt(fp, &cfmt, ap);
7EBA  FA44     NOP
7EBC  F671     NOP
7EC0  FA48     NOP
7EC2  F672     NOP
7EC4  0E97     MOVLW 0x97
7EC6  6F73     MOVWF CM1PCH, BANKED
7EC8  0E06     MOVLW 0x6
7ECA  6F74     MOVWF CM2CON0, BANKED
7ECE  FA54     NOP
7ED0  F675     NOP
7ED4  FA58     NOP
7ED6  F676     NOP
7ED8  EC93     CALL 0x3F26, 0
7EDA  F01F     NOP
7EDC  0106     MOVLB 0x6
7EDE  5171     MOVF CM1CON1, W, BANKED
7EE0  27AF     ADDWF OSCCON3, F, BANKED
7EE2  5172     MOVF CM1NCH, W, BANKED
7EE4  23B0     ADDWFC OSCTUNE, F, BANKED
1377:              }
1378:              return nout;
7F0C  FABC     NOP
7F0E  F691     NOP
7F12  FAC0     NOP
7F14  F692     NOP
1379:          #else
1380:              return fputs(fmt, fp);
1381:          #endif
1382:          }
7F16  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/awmod.c  -------------------------
1:             // integer signed unsigned modulus
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awmod(signed int divisor, signed int dividend)
6:             #else
7:             __awmod(signed int dividend, signed int divisor)
8:             #endif
9:             {
10:            	unsigned char	counter, sign;
11:            
12:            	sign = 0;
78B4  0E00     MOVLW 0x0
78B6  0106     MOVLB 0x6
78B8  6F05     MOVWF 0x5, BANKED
13:            	if(dividend < 0) {
78BA  BF01     BTFSC 0x1, 7, BANKED
78BC  EF64     GOTO 0x78C8
78BE  F03C     NOP
78C0  EF62     GOTO 0x78C4
78C2  F03C     NOP
78C4  EF6A     GOTO 0x78D4
78C6  F03C     NOP
14:            		dividend = -dividend;
78C8  6D00     NEGF txData, BANKED
78CA  1F01     COMF 0x1, F, BANKED
78CC  B0D8     BTFSC 0xFD8, 0, ACCESS
78CE  2B01     INCF 0x1, F, BANKED
15:            		sign = 1;
78D0  0E01     MOVLW 0x1
78D2  6F05     MOVWF 0x5, BANKED
16:            	}
17:            	if(divisor < 0)
78D4  BF03     BTFSC 0x3, 7, BANKED
78D6  EF71     GOTO 0x78E2
78D8  F03C     NOP
78DA  EF6F     GOTO 0x78DE
78DC  F03C     NOP
78DE  EF75     GOTO 0x78EA
78E0  F03C     NOP
18:            		divisor = -divisor;
78E2  6D02     NEGF 0x2, BANKED
78E4  1F03     COMF 0x3, F, BANKED
78E6  B0D8     BTFSC 0xFD8, 0, ACCESS
78E8  2B03     INCF 0x3, F, BANKED
19:            	if(divisor != 0) {
78EA  5102     MOVF 0x2, W, BANKED
78EC  1103     IORWF 0x3, W, BANKED
78EE  B4D8     BTFSC 0xFD8, 2, ACCESS
78F0  EF7C     GOTO 0x78F8
78F2  F03C     NOP
78F4  EF7E     GOTO 0x78FC
78F6  F03C     NOP
78F8  EFA2     GOTO 0x7944
78FA  F03C     NOP
20:            		counter = 1;
78FC  0E01     MOVLW 0x1
78FE  6F04     MOVWF 0x4, BANKED
21:            		while(((unsigned int)divisor & 0x8000U) == 0) {
7900  EF86     GOTO 0x790C
7902  F03C     NOP
790C  AF03     BTFSS 0x3, 7, BANKED
790E  EF8B     GOTO 0x7916
7910  F03C     NOP
7912  EF8D     GOTO 0x791A
7914  F03C     NOP
7916  EF82     GOTO 0x7904
7918  F03C     NOP
22:            			divisor <<= 1;
7904  90D8     BCF 0xFD8, 0, ACCESS
7906  3702     RLCF 0x2, F, BANKED
7908  3703     RLCF 0x3, F, BANKED
23:            			counter++;
790A  2B04     INCF 0x4, F, BANKED
24:            		}
25:            		do {
26:            			if((unsigned int)divisor <= (unsigned int)dividend)
791A  5102     MOVF 0x2, W, BANKED
791C  5D00     SUBWF txData, W, BANKED
791E  5103     MOVF 0x3, W, BANKED
7920  5901     SUBWFB 0x1, W, BANKED
7922  A0D8     BTFSS 0xFD8, 0, ACCESS
7924  EF96     GOTO 0x792C
7926  F03C     NOP
7928  EF98     GOTO 0x7930
792A  F03C     NOP
792C  EF9C     GOTO 0x7938
792E  F03C     NOP
27:            				dividend -= divisor;
7930  5102     MOVF 0x2, W, BANKED
7932  5F00     SUBWF txData, F, BANKED
7934  5103     MOVF 0x3, W, BANKED
7936  5B01     SUBWFB 0x1, F, BANKED
28:            			*(unsigned int *)&divisor >>= 1;
7938  90D8     BCF 0xFD8, 0, ACCESS
793A  3303     RRCF 0x3, F, BANKED
793C  3302     RRCF 0x2, F, BANKED
29:            		} while(--counter != 0);
793E  2F04     DECFSZ 0x4, F, BANKED
7940  EF8D     GOTO 0x791A
7942  F03C     NOP
30:            	}
31:            	if(sign)
7944  5105     MOVF 0x5, W, BANKED
7946  B4D8     BTFSC 0xFD8, 2, ACCESS
7948  EFA8     GOTO 0x7950
794A  F03C     NOP
794C  EFAA     GOTO 0x7954
794E  F03C     NOP
7950  EFAE     GOTO 0x795C
7952  F03C     NOP
32:            		dividend = -dividend;
7954  6D00     NEGF txData, BANKED
7956  1F01     COMF 0x1, F, BANKED
7958  B0D8     BTFSC 0xFD8, 0, ACCESS
795A  2B01     INCF 0x1, F, BANKED
33:            	return dividend;
795E  F800     NOP
7960  F600     NOP
7964  F804     NOP
7966  F601     NOP
34:            }
7968  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/awdiv.c  -------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awdiv(signed int divisor, signed int dividend)
6:             #else
7:             __awdiv(signed int dividend, signed int divisor)
8:             #endif
9:             {
10:            	signed int	quotient;
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
77EA  0E00     MOVLW 0x0
77EC  0106     MOVLB 0x6
77EE  6F05     MOVWF 0x5, BANKED
14:            	if(divisor < 0) {
77F0  BF03     BTFSC 0x3, 7, BANKED
77F2  EFFF     GOTO 0x77FE
77F4  F03B     NOP
77F6  EFFD     GOTO 0x77FA
77F8  F03B     NOP
77FA  EF05     GOTO 0x780A
77FC  F03C     NOP
15:            		divisor = -divisor;
77FE  6D02     NEGF 0x2, BANKED
7800  1F03     COMF 0x3, F, BANKED
7802  B0D8     BTFSC 0xFD8, 0, ACCESS
7804  2B03     INCF 0x3, F, BANKED
16:            		sign = 1;
7806  0E01     MOVLW 0x1
7808  6F05     MOVWF 0x5, BANKED
17:            	}
18:            	if(dividend < 0) {
780A  BF01     BTFSC 0x1, 7, BANKED
780C  EF0C     GOTO 0x7818
780E  F03C     NOP
7810  EF0A     GOTO 0x7814
7812  F03C     NOP
7814  EF12     GOTO 0x7824
7816  F03C     NOP
19:            		dividend = -dividend;
7818  6D00     NEGF txData, BANKED
781A  1F01     COMF 0x1, F, BANKED
781C  B0D8     BTFSC 0xFD8, 0, ACCESS
781E  2B01     INCF 0x1, F, BANKED
20:            		sign ^= 1;
7820  0E01     MOVLW 0x1
7822  1B05     XORWF 0x5, F, BANKED
21:            	}
22:            	quotient = 0;
7824  0E00     MOVLW 0x0
7826  6F07     MOVWF 0x7, BANKED
7828  0E00     MOVLW 0x0
782A  6F06     MOVWF 0x6, BANKED
23:            	if(divisor != 0) {
782C  5102     MOVF 0x2, W, BANKED
782E  1103     IORWF 0x3, W, BANKED
7830  B4D8     BTFSC 0xFD8, 2, ACCESS
7832  EF1D     GOTO 0x783A
7834  F03C     NOP
7836  EF1F     GOTO 0x783E
7838  F03C     NOP
783A  EF47     GOTO 0x788E
783C  F03C     NOP
24:            		counter = 1;
783E  0E01     MOVLW 0x1
7840  6F04     MOVWF 0x4, BANKED
25:            		while((divisor & 0x8000U) == 0) {
7842  EF27     GOTO 0x784E
7844  F03C     NOP
784E  AF03     BTFSS 0x3, 7, BANKED
7850  EF2C     GOTO 0x7858
7852  F03C     NOP
7854  EF2E     GOTO 0x785C
7856  F03C     NOP
7858  EF23     GOTO 0x7846
785A  F03C     NOP
26:            			divisor <<= 1;
7846  90D8     BCF 0xFD8, 0, ACCESS
7848  3702     RLCF 0x2, F, BANKED
784A  3703     RLCF 0x3, F, BANKED
27:            			counter++;
784C  2B04     INCF 0x4, F, BANKED
28:            		}
29:            		do {
30:            			quotient <<= 1;
785C  90D8     BCF 0xFD8, 0, ACCESS
785E  3706     RLCF 0x6, F, BANKED
7860  3707     RLCF 0x7, F, BANKED
31:            			if((unsigned int)divisor <= (unsigned int)dividend) {
7862  5102     MOVF 0x2, W, BANKED
7864  5D00     SUBWF txData, W, BANKED
7866  5103     MOVF 0x3, W, BANKED
7868  5901     SUBWFB 0x1, W, BANKED
786A  A0D8     BTFSS 0xFD8, 0, ACCESS
786C  EF3A     GOTO 0x7874
786E  F03C     NOP
7870  EF3C     GOTO 0x7878
7872  F03C     NOP
7874  EF41     GOTO 0x7882
7876  F03C     NOP
32:            				dividend -= divisor;
7878  5102     MOVF 0x2, W, BANKED
787A  5F00     SUBWF txData, F, BANKED
787C  5103     MOVF 0x3, W, BANKED
787E  5B01     SUBWFB 0x1, F, BANKED
33:            				quotient |= 1;
7880  8106     BSF 0x6, 0, BANKED
34:            			}
35:            			*(unsigned int *)&divisor >>= 1;
7882  90D8     BCF 0xFD8, 0, ACCESS
7884  3303     RRCF 0x3, F, BANKED
7886  3302     RRCF 0x2, F, BANKED
36:            		} while(--counter != 0);
7888  2F04     DECFSZ 0x4, F, BANKED
788A  EF2E     GOTO 0x785C
788C  F03C     NOP
37:            	}
38:            	if(sign)
788E  5105     MOVF 0x5, W, BANKED
7890  B4D8     BTFSC 0xFD8, 2, ACCESS
7892  EF4D     GOTO 0x789A
7894  F03C     NOP
7896  EF4F     GOTO 0x789E
7898  F03C     NOP
789A  EF53     GOTO 0x78A6
789C  F03C     NOP
39:            		quotient = -quotient;
789E  6D06     NEGF 0x6, BANKED
78A0  1F07     COMF 0x7, F, BANKED
78A2  B0D8     BTFSC 0xFD8, 0, ACCESS
78A4  2B07     INCF 0x7, F, BANKED
40:            	return quotient;
78A8  F818     NOP
78AA  F600     NOP
78AE  F81C     NOP
78B0  F601     NOP
41:            }
78B2  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/atoi.c  --------------------------
1:             #include <stdlib.h>
2:             #include <ctype.h>
3:             
4:             int atoi(const char *s)
5:             {
6:             	int n=0, neg=0;
6B72  0E00     MOVLW 0x0
6B74  0106     MOVLB 0x6
6B76  6F15     MOVWF 0x15, BANKED
6B78  0E00     MOVLW 0x0
6B7A  6F14     MOVWF 0x14, BANKED
6B7C  0E00     MOVLW 0x0
6B7E  6F0E     MOVWF 0xE, BANKED
6B80  0E00     MOVLW 0x0
6B82  6F0D     MOVWF 0xD, BANKED
7:             	while (isspace(*s)) s++;
6B84  EFC6     GOTO 0x6B8C
6B86  F035     NOP
6B88  4B07     INFSNZ 0x7, F, BANKED
6B8A  2B08     INCF 0x8, F, BANKED
6B8C  0E01     MOVLW 0x1
6B8E  6F13     MOVWF 0x13, BANKED
6B92  F81C     NOP
6B94  F4F6     NOP
6B98  F820     NOP
6B9A  F4F7     NOP
6B9C  0E00     MOVLW 0x0
6B9E  6EF8     MOVWF 0xFF8, ACCESS
6BA0  0008     TBLRD*
6BA2  50F5     MOVF 0xFF5, W, ACCESS
6BA4  0A20     XORLW 0x20
6BA6  B4D8     BTFSC 0xFD8, 2, ACCESS
6BA8  EFD8     GOTO 0x6BB0
6BAA  F035     NOP
6BAC  EFDA     GOTO 0x6BB4
6BAE  F035     NOP
6BB0  EFFB     GOTO 0x6BF6
6BB2  F035     NOP
6BB4  0EF7     MOVLW 0xF7
6BB6  6F09     MOVWF 0x9, BANKED
6BB8  0EFF     MOVLW 0xFF
6BBA  6F0A     MOVWF 0xA, BANKED
6BBE  F81C     NOP
6BC0  F4F6     NOP
6BC4  F820     NOP
6BC6  F4F7     NOP
6BC8  0E00     MOVLW 0x0
6BCA  6EF8     MOVWF 0xFF8, ACCESS
6BCC  0008     TBLRD*
6BCE  50F5     MOVF 0xFF5, W, ACCESS
6BD0  6F0B     MOVWF 0xB, BANKED
6BD2  6B0C     CLRF 0xC, BANKED
6BD4  5109     MOVF 0x9, W, BANKED
6BD6  270B     ADDWF 0xB, F, BANKED
6BD8  510A     MOVF 0xA, W, BANKED
6BDA  230C     ADDWFC 0xC, F, BANKED
6BDC  510C     MOVF 0xC, W, BANKED
6BDE  E109     BNZ 0x6BF2
6BE0  0E05     MOVLW 0x5
6BE2  5D0B     SUBWF 0xB, W, BANKED
6BE4  A0D8     BTFSS 0xFD8, 0, ACCESS
6BE6  EFF7     GOTO 0x6BEE
6BE8  F035     NOP
6BEA  EFF9     GOTO 0x6BF2
6BEC  F035     NOP
6BEE  EFFB     GOTO 0x6BF6
6BF0  F035     NOP
6BF2  0E00     MOVLW 0x0
6BF4  6F13     MOVWF 0x13, BANKED
6BF8  F84C     NOP
6BFA  F60F     NOP
6BFC  6B10     CLRF 0x10, BANKED
6BFE  510F     MOVF 0xF, W, BANKED
6C00  1110     IORWF 0x10, W, BANKED
6C02  A4D8     BTFSS 0xFD8, 2, ACCESS
6C04  EF06     GOTO 0x6C0C
6C06  F036     NOP
6C08  EF08     GOTO 0x6C10
6C0A  F036     NOP
6C0C  EFC4     GOTO 0x6B88
6C0E  F035     NOP
6C10  EF12     GOTO 0x6C24
6C12  F036     NOP
8:             	switch (*s) {
9:             	case '-': neg=1;
6C14  0E00     MOVLW 0x0
6C16  6F0E     MOVWF 0xE, BANKED
6C18  0E01     MOVLW 0x1
6C1A  6F0D     MOVWF 0xD, BANKED
10:            	case '+': s++;
6C1C  4B07     INFSNZ 0x7, F, BANKED
6C1E  2B08     INCF 0x8, F, BANKED
11:            	}
6C20  EF52     GOTO 0x6CA4
6C22  F036     NOP
6C26  F81C     NOP
6C28  F4F6     NOP
6C2C  F820     NOP
6C2E  F4F7     NOP
6C30  0E00     MOVLW 0x0
6C32  6EF8     MOVWF 0xFF8, ACCESS
6C34  0008     TBLRD*
6C36  50F5     MOVF 0xFF5, W, ACCESS
6C38  6F09     MOVWF 0x9, BANKED
6C3A  6B0A     CLRF 0xA, BANKED
6C3C  510A     MOVF 0xA, W, BANKED
6C3E  0A00     XORLW 0x0
6C40  B4D8     BTFSC 0xFD8, 2, ACCESS
6C42  EF25     GOTO 0x6C4A
6C44  F036     NOP
6C46  EF52     GOTO 0x6CA4
6C48  F036     NOP
6C4A  5109     MOVF 0x9, W, BANKED
6C4C  0A2B     XORLW 0x2B
6C4E  B4D8     BTFSC 0xFD8, 2, ACCESS
6C50  EF0E     GOTO 0x6C1C
6C52  F036     NOP
6C54  0A06     XORLW 0x6
6C56  B4D8     BTFSC 0xFD8, 2, ACCESS
6C58  EF0A     GOTO 0x6C14
6C5A  F036     NOP
6C5C  EF52     GOTO 0x6CA4
6C5E  F036     NOP
12:            	/* Compute n as a negative number to avoid overflow on INT_MIN */
13:            	while (isdigit(*s))
6CA4  0ED0     MOVLW 0xD0
6CA6  6F09     MOVWF 0x9, BANKED
6CA8  0EFF     MOVLW 0xFF
6CAA  6F0A     MOVWF 0xA, BANKED
6CAE  F81C     NOP
6CB0  F4F6     NOP
6CB4  F820     NOP
6CB6  F4F7     NOP
6CB8  0E00     MOVLW 0x0
6CBA  6EF8     MOVWF 0xFF8, ACCESS
6CBC  0008     TBLRD*
6CBE  50F5     MOVF 0xFF5, W, ACCESS
6CC0  6F0B     MOVWF 0xB, BANKED
6CC2  6B0C     CLRF 0xC, BANKED
6CC4  5109     MOVF 0x9, W, BANKED
6CC6  270B     ADDWF 0xB, F, BANKED
6CC8  510A     MOVF 0xA, W, BANKED
6CCA  230C     ADDWFC 0xC, F, BANKED
6CCC  510C     MOVF 0xC, W, BANKED
6CCE  E10A     BNZ 0x6CE4
6CD0  0E0A     MOVLW 0xA
6CD2  5D0B     SUBWF 0xB, W, BANKED
6CD4  A0D8     BTFSS 0xFD8, 0, ACCESS
6CD6  EF6F     GOTO 0x6CDE
6CD8  F036     NOP
6CDA  EF72     GOTO 0x6CE4
6CDC  F036     NOP
6CDE  0E01     MOVLW 0x1
6CE0  EF73     GOTO 0x6CE6
6CE2  F036     NOP
6CE4  0E00     MOVLW 0x0
6CE6  6F11     MOVWF 0x11, BANKED
6CE8  6B12     CLRF 0x12, BANKED
6CEA  5111     MOVF 0x11, W, BANKED
6CEC  1112     IORWF 0x12, W, BANKED
6CEE  A4D8     BTFSS 0xFD8, 2, ACCESS
6CF0  EF7C     GOTO 0x6CF8
6CF2  F036     NOP
6CF4  EF7E     GOTO 0x6CFC
6CF6  F036     NOP
6CF8  EF30     GOTO 0x6C60
6CFA  F036     NOP
14:            		n = 10*n - (*s++ - '0');
6C62  F850     NOP
6C64  F600     NOP
6C68  F854     NOP
6C6A  F601     NOP
6C6C  0E00     MOVLW 0x0
6C6E  6F03     MOVWF 0x3, BANKED
6C70  0E0A     MOVLW 0xA
6C72  6F02     MOVWF 0x2, BANKED
6C74  EC9D     CALL 0x853A, 0
6C76  F042     NOP
6C7A  F81C     NOP
6C7C  F4F6     NOP
6C80  F820     NOP
6C82  F4F7     NOP
6C84  0E00     MOVLW 0x0
6C86  6EF8     MOVWF 0xFF8, ACCESS
6C88  0008     TBLRD*
6C8A  50F5     MOVF 0xFF5, W, ACCESS
6C8C  0106     MOVLB 0x6
6C8E  5F00     SUBWF txData, F, BANKED
6C90  0E00     MOVLW 0x0
6C92  5B01     SUBWFB 0x1, F, BANKED
6C94  0E30     MOVLW 0x30
6C96  2500     ADDWF txData, W, BANKED
6C98  6F14     MOVWF 0x14, BANKED
6C9A  0E00     MOVLW 0x0
6C9C  2101     ADDWFC 0x1, W, BANKED
6C9E  6F15     MOVWF 0x15, BANKED
6CA0  EF0E     GOTO 0x6C1C
6CA2  F036     NOP
15:            	return neg ? n : -n;
6CFC  510D     MOVF 0xD, W, BANKED
6CFE  110E     IORWF 0xE, W, BANKED
6D00  A4D8     BTFSS 0xFD8, 2, ACCESS
6D02  EF85     GOTO 0x6D0A
6D04  F036     NOP
6D06  EF87     GOTO 0x6D0E
6D08  F036     NOP
6D0A  EF99     GOTO 0x6D32
6D0C  F036     NOP
6D10  F850     NOP
6D12  F609     NOP
6D16  F854     NOP
6D18  F60A     NOP
6D1A  1F09     COMF 0x9, F, BANKED
6D1C  1F0A     COMF 0xA, F, BANKED
6D1E  4B09     INFSNZ 0x9, F, BANKED
6D20  2B0A     INCF 0xA, F, BANKED
6D24  F824     NOP
6D26  F607     NOP
6D2A  F828     NOP
6D2C  F608     NOP
6D2E  EF9F     GOTO 0x6D3E
6D30  F036     NOP
6D34  F850     NOP
6D36  F607     NOP
6D3A  F854     NOP
6D3C  F608     NOP
16:            }
6D3E  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/aomod.c  -------------------------
1:             // long long signed unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aomod(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aomod(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
6EDA  0E00     MOVLW 0x0
6EDC  0106     MOVLB 0x6
6EDE  6F11     MOVWF 0x11, BANKED
15:            	if(dividend < 0) {
6EE0  BF07     BTFSC 0x7, 7, BANKED
6EE2  EF77     GOTO 0x6EEE
6EE4  F037     NOP
6EE6  EF75     GOTO 0x6EEA
6EE8  F037     NOP
6EEA  EF89     GOTO 0x6F12
6EEC  F037     NOP
16:            		dividend = -dividend;
6EEE  1F07     COMF 0x7, F, BANKED
6EF0  1F06     COMF 0x6, F, BANKED
6EF2  1F05     COMF 0x5, F, BANKED
6EF4  1F04     COMF 0x4, F, BANKED
6EF6  1F03     COMF 0x3, F, BANKED
6EF8  1F02     COMF 0x2, F, BANKED
6EFA  1F01     COMF 0x1, F, BANKED
6EFC  6D00     NEGF txData, BANKED
6EFE  0E00     MOVLW 0x0
6F00  2301     ADDWFC 0x1, F, BANKED
6F02  2302     ADDWFC 0x2, F, BANKED
6F04  2303     ADDWFC 0x3, F, BANKED
6F06  2304     ADDWFC 0x4, F, BANKED
6F08  2305     ADDWFC 0x5, F, BANKED
6F0A  2306     ADDWFC 0x6, F, BANKED
6F0C  2307     ADDWFC 0x7, F, BANKED
17:            		sign = 1;
6F0E  0E01     MOVLW 0x1
6F10  6F11     MOVWF 0x11, BANKED
18:            	}
19:            	if(divisor < 0)
6F12  BF0F     BTFSC 0xF, 7, BANKED
6F14  EF90     GOTO 0x6F20
6F16  F037     NOP
6F18  EF8E     GOTO 0x6F1C
6F1A  F037     NOP
6F1C  EFA0     GOTO 0x6F40
6F1E  F037     NOP
20:            		divisor = -divisor;
6F20  1F0F     COMF 0xF, F, BANKED
6F22  1F0E     COMF 0xE, F, BANKED
6F24  1F0D     COMF 0xD, F, BANKED
6F26  1F0C     COMF 0xC, F, BANKED
6F28  1F0B     COMF 0xB, F, BANKED
6F2A  1F0A     COMF 0xA, F, BANKED
6F2C  1F09     COMF 0x9, F, BANKED
6F2E  6D08     NEGF 0x8, BANKED
6F30  0E00     MOVLW 0x0
6F32  2309     ADDWFC 0x9, F, BANKED
6F34  230A     ADDWFC 0xA, F, BANKED
6F36  230B     ADDWFC 0xB, F, BANKED
6F38  230C     ADDWFC 0xC, F, BANKED
6F3A  230D     ADDWFC 0xD, F, BANKED
6F3C  230E     ADDWFC 0xE, F, BANKED
6F3E  230F     ADDWFC 0xF, F, BANKED
21:            	if(divisor != 0) {
6F40  5108     MOVF 0x8, W, BANKED
6F42  1109     IORWF 0x9, W, BANKED
6F44  110A     IORWF 0xA, W, BANKED
6F46  110B     IORWF 0xB, W, BANKED
6F48  110C     IORWF 0xC, W, BANKED
6F4A  110D     IORWF 0xD, W, BANKED
6F4C  110E     IORWF 0xE, W, BANKED
6F4E  110F     IORWF 0xF, W, BANKED
6F50  B4D8     BTFSC 0xFD8, 2, ACCESS
6F52  EFAD     GOTO 0x6F5A
6F54  F037     NOP
6F56  EFAF     GOTO 0x6F5E
6F58  F037     NOP
6F5A  EFF7     GOTO 0x6FEE
6F5C  F037     NOP
22:            		counter = 1;
6F5E  0E01     MOVLW 0x1
6F60  6F10     MOVWF 0x10, BANKED
23:            		while((divisor & 0x8000000000000000ULL) == 0) {
6F62  EFBD     GOTO 0x6F7A
6F64  F037     NOP
6F7A  AF0F     BTFSS 0xF, 7, BANKED
6F7C  EFC2     GOTO 0x6F84
6F7E  F037     NOP
6F80  EFC4     GOTO 0x6F88
6F82  F037     NOP
6F84  EFB3     GOTO 0x6F66
6F86  F037     NOP
24:            			divisor <<= 1;
6F66  90D8     BCF 0xFD8, 0, ACCESS
6F68  3708     RLCF 0x8, F, BANKED
6F6A  3709     RLCF 0x9, F, BANKED
6F6C  370A     RLCF 0xA, F, BANKED
6F6E  370B     RLCF 0xB, F, BANKED
6F70  370C     RLCF 0xC, F, BANKED
6F72  370D     RLCF 0xD, F, BANKED
6F74  370E     RLCF 0xE, F, BANKED
6F76  370F     RLCF 0xF, F, BANKED
25:            			counter++;
6F78  2B10     INCF 0x10, F, BANKED
26:            		}
27:            		do {
28:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
6F88  5108     MOVF 0x8, W, BANKED
6F8A  5D00     SUBWF txData, W, BANKED
6F8C  5109     MOVF 0x9, W, BANKED
6F8E  5901     SUBWFB 0x1, W, BANKED
6F90  510A     MOVF 0xA, W, BANKED
6F92  5902     SUBWFB 0x2, W, BANKED
6F94  510B     MOVF 0xB, W, BANKED
6F96  5903     SUBWFB 0x3, W, BANKED
6F98  510C     MOVF 0xC, W, BANKED
6F9A  5904     SUBWFB 0x4, W, BANKED
6F9C  510D     MOVF 0xD, W, BANKED
6F9E  5905     SUBWFB 0x5, W, BANKED
6FA0  510E     MOVF 0xE, W, BANKED
6FA2  5906     SUBWFB 0x6, W, BANKED
6FA4  510F     MOVF 0xF, W, BANKED
6FA6  5907     SUBWFB 0x7, W, BANKED
6FA8  A0D8     BTFSS 0xFD8, 0, ACCESS
6FAA  EFD9     GOTO 0x6FB2
6FAC  F037     NOP
6FAE  EFDB     GOTO 0x6FB6
6FB0  F037     NOP
6FB2  EFEB     GOTO 0x6FD6
6FB4  F037     NOP
29:            				dividend -= divisor;
6FB6  5108     MOVF 0x8, W, BANKED
6FB8  5F00     SUBWF txData, F, BANKED
6FBA  5109     MOVF 0x9, W, BANKED
6FBC  5B01     SUBWFB 0x1, F, BANKED
6FBE  510A     MOVF 0xA, W, BANKED
6FC0  5B02     SUBWFB 0x2, F, BANKED
6FC2  510B     MOVF 0xB, W, BANKED
6FC4  5B03     SUBWFB 0x3, F, BANKED
6FC6  510C     MOVF 0xC, W, BANKED
6FC8  5B04     SUBWFB 0x4, F, BANKED
6FCA  510D     MOVF 0xD, W, BANKED
6FCC  5B05     SUBWFB 0x5, F, BANKED
6FCE  510E     MOVF 0xE, W, BANKED
6FD0  5B06     SUBWFB 0x6, F, BANKED
6FD2  510F     MOVF 0xF, W, BANKED
6FD4  5B07     SUBWFB 0x7, F, BANKED
30:            			*(unsigned long long int *)&divisor >>= 1;
6FD6  90D8     BCF 0xFD8, 0, ACCESS
6FD8  330F     RRCF 0xF, F, BANKED
6FDA  330E     RRCF 0xE, F, BANKED
6FDC  330D     RRCF 0xD, F, BANKED
6FDE  330C     RRCF 0xC, F, BANKED
6FE0  330B     RRCF 0xB, F, BANKED
6FE2  330A     RRCF 0xA, F, BANKED
6FE4  3309     RRCF 0x9, F, BANKED
6FE6  3308     RRCF 0x8, F, BANKED
31:            		} while(--counter != 0);
6FE8  2F10     DECFSZ 0x10, F, BANKED
6FEA  EFC4     GOTO 0x6F88
6FEC  F037     NOP
32:            	}
33:            	if(sign)
6FEE  5111     MOVF 0x11, W, BANKED
6FF0  B4D8     BTFSC 0xFD8, 2, ACCESS
6FF2  EFFD     GOTO 0x6FFA
6FF4  F037     NOP
6FF6  EFFF     GOTO 0x6FFE
6FF8  F037     NOP
6FFA  EF0F     GOTO 0x701E
6FFC  F038     NOP
34:            		dividend = -dividend;
6FFE  1F07     COMF 0x7, F, BANKED
7000  1F06     COMF 0x6, F, BANKED
7002  1F05     COMF 0x5, F, BANKED
7004  1F04     COMF 0x4, F, BANKED
7006  1F03     COMF 0x3, F, BANKED
7008  1F02     COMF 0x2, F, BANKED
700A  1F01     COMF 0x1, F, BANKED
700C  6D00     NEGF txData, BANKED
700E  0E00     MOVLW 0x0
7010  2301     ADDWFC 0x1, F, BANKED
7012  2302     ADDWFC 0x2, F, BANKED
7014  2303     ADDWFC 0x3, F, BANKED
7016  2304     ADDWFC 0x4, F, BANKED
7018  2305     ADDWFC 0x5, F, BANKED
701A  2306     ADDWFC 0x6, F, BANKED
701C  2307     ADDWFC 0x7, F, BANKED
35:            	return dividend;
7020  F800     NOP
7022  F600     NOP
7026  F804     NOP
7028  F601     NOP
702C  F808     NOP
702E  F602     NOP
7032  F80C     NOP
7034  F603     NOP
7038  F810     NOP
703A  F604     NOP
703E  F814     NOP
7040  F605     NOP
7044  F818     NOP
7046  F606     NOP
704A  F81C     NOP
704C  F607     NOP
36:            }
704E  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/aodiv.c  -------------------------
1:             // long long signed unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aodiv(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aodiv(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	signed long long int	quotient;
13:            	unsigned char	counter, sign;
14:            
15:            	sign = 0;
6D40  0E00     MOVLW 0x0
6D42  0106     MOVLB 0x6
6D44  6F11     MOVWF 0x11, BANKED
16:            	if(divisor < 0) {
6D46  BF0F     BTFSC 0xF, 7, BANKED
6D48  EFAA     GOTO 0x6D54
6D4A  F036     NOP
6D4C  EFA8     GOTO 0x6D50
6D4E  F036     NOP
6D50  EFBC     GOTO 0x6D78
6D52  F036     NOP
17:            		divisor = -divisor;
6D54  1F0F     COMF 0xF, F, BANKED
6D56  1F0E     COMF 0xE, F, BANKED
6D58  1F0D     COMF 0xD, F, BANKED
6D5A  1F0C     COMF 0xC, F, BANKED
6D5C  1F0B     COMF 0xB, F, BANKED
6D5E  1F0A     COMF 0xA, F, BANKED
6D60  1F09     COMF 0x9, F, BANKED
6D62  6D08     NEGF 0x8, BANKED
6D64  0E00     MOVLW 0x0
6D66  2309     ADDWFC 0x9, F, BANKED
6D68  230A     ADDWFC 0xA, F, BANKED
6D6A  230B     ADDWFC 0xB, F, BANKED
6D6C  230C     ADDWFC 0xC, F, BANKED
6D6E  230D     ADDWFC 0xD, F, BANKED
6D70  230E     ADDWFC 0xE, F, BANKED
6D72  230F     ADDWFC 0xF, F, BANKED
18:            		sign = 1;
6D74  0E01     MOVLW 0x1
6D76  6F11     MOVWF 0x11, BANKED
19:            	}
20:            	if(dividend < 0) {
6D78  BF07     BTFSC 0x7, 7, BANKED
6D7A  EFC3     GOTO 0x6D86
6D7C  F036     NOP
6D7E  EFC1     GOTO 0x6D82
6D80  F036     NOP
6D82  EFD5     GOTO 0x6DAA
6D84  F036     NOP
21:            		dividend = -dividend;
6D86  1F07     COMF 0x7, F, BANKED
6D88  1F06     COMF 0x6, F, BANKED
6D8A  1F05     COMF 0x5, F, BANKED
6D8C  1F04     COMF 0x4, F, BANKED
6D8E  1F03     COMF 0x3, F, BANKED
6D90  1F02     COMF 0x2, F, BANKED
6D92  1F01     COMF 0x1, F, BANKED
6D94  6D00     NEGF txData, BANKED
6D96  0E00     MOVLW 0x0
6D98  2301     ADDWFC 0x1, F, BANKED
6D9A  2302     ADDWFC 0x2, F, BANKED
6D9C  2303     ADDWFC 0x3, F, BANKED
6D9E  2304     ADDWFC 0x4, F, BANKED
6DA0  2305     ADDWFC 0x5, F, BANKED
6DA2  2306     ADDWFC 0x6, F, BANKED
6DA4  2307     ADDWFC 0x7, F, BANKED
22:            		sign ^= 1;
6DA6  0E01     MOVLW 0x1
6DA8  1B11     XORWF 0x11, F, BANKED
23:            	}
24:            	quotient = 0;
6DAA  EE21     LFSR 2, 0x612
6DAC  F212     NOP
6DAE  0E07     MOVLW 0x7
6DB0  6ADE     CLRF 0xFDE, ACCESS
6DB2  06E8     DECF 0xFE8, F, ACCESS
6DB4  E2FD     BC 0x6DB0
25:            	if(divisor != 0) {
6DB6  5108     MOVF 0x8, W, BANKED
6DB8  1109     IORWF 0x9, W, BANKED
6DBA  110A     IORWF 0xA, W, BANKED
6DBC  110B     IORWF 0xB, W, BANKED
6DBE  110C     IORWF 0xC, W, BANKED
6DC0  110D     IORWF 0xD, W, BANKED
6DC2  110E     IORWF 0xE, W, BANKED
6DC4  110F     IORWF 0xF, W, BANKED
6DC6  B4D8     BTFSC 0xFD8, 2, ACCESS
6DC8  EFE8     GOTO 0x6DD0
6DCA  F036     NOP
6DCC  EFEA     GOTO 0x6DD4
6DCE  F036     NOP
6DD0  EF3C     GOTO 0x6E78
6DD2  F037     NOP
26:            		counter = 1;
6DD4  0E01     MOVLW 0x1
6DD6  6F10     MOVWF 0x10, BANKED
27:            		while((divisor & 0x8000000000000000ULL) == 0) {
6DD8  EFF8     GOTO 0x6DF0
6DDA  F036     NOP
6DF0  AF0F     BTFSS 0xF, 7, BANKED
6DF2  EFFD     GOTO 0x6DFA
6DF4  F036     NOP
6DF6  EFFF     GOTO 0x6DFE
6DF8  F036     NOP
6DFA  EFEE     GOTO 0x6DDC
6DFC  F036     NOP
28:            			divisor <<= 1;
6DDC  90D8     BCF 0xFD8, 0, ACCESS
6DDE  3708     RLCF 0x8, F, BANKED
6DE0  3709     RLCF 0x9, F, BANKED
6DE2  370A     RLCF 0xA, F, BANKED
6DE4  370B     RLCF 0xB, F, BANKED
6DE6  370C     RLCF 0xC, F, BANKED
6DE8  370D     RLCF 0xD, F, BANKED
6DEA  370E     RLCF 0xE, F, BANKED
6DEC  370F     RLCF 0xF, F, BANKED
29:            			counter++;
6DEE  2B10     INCF 0x10, F, BANKED
30:            		}
31:            		do {
32:            			quotient <<= 1;
6DFE  90D8     BCF 0xFD8, 0, ACCESS
6E00  3712     RLCF 0x12, F, BANKED
6E02  3713     RLCF 0x13, F, BANKED
6E04  3714     RLCF 0x14, F, BANKED
6E06  3715     RLCF 0x15, F, BANKED
6E08  3716     RLCF 0x16, F, BANKED
6E0A  3717     RLCF 0x17, F, BANKED
6E0C  3718     RLCF 0x18, F, BANKED
6E0E  3719     RLCF 0x19, F, BANKED
33:            			if((unsigned long long)divisor <= (unsigned long long)dividend) {
6E10  5108     MOVF 0x8, W, BANKED
6E12  5D00     SUBWF txData, W, BANKED
6E14  5109     MOVF 0x9, W, BANKED
6E16  5901     SUBWFB 0x1, W, BANKED
6E18  510A     MOVF 0xA, W, BANKED
6E1A  5902     SUBWFB 0x2, W, BANKED
6E1C  510B     MOVF 0xB, W, BANKED
6E1E  5903     SUBWFB 0x3, W, BANKED
6E20  510C     MOVF 0xC, W, BANKED
6E22  5904     SUBWFB 0x4, W, BANKED
6E24  510D     MOVF 0xD, W, BANKED
6E26  5905     SUBWFB 0x5, W, BANKED
6E28  510E     MOVF 0xE, W, BANKED
6E2A  5906     SUBWFB 0x6, W, BANKED
6E2C  510F     MOVF 0xF, W, BANKED
6E2E  5907     SUBWFB 0x7, W, BANKED
6E30  A0D8     BTFSS 0xFD8, 0, ACCESS
6E32  EF1D     GOTO 0x6E3A
6E34  F037     NOP
6E36  EF1F     GOTO 0x6E3E
6E38  F037     NOP
6E3A  EF30     GOTO 0x6E60
6E3C  F037     NOP
34:            				dividend -= divisor;
6E3E  5108     MOVF 0x8, W, BANKED
6E40  5F00     SUBWF txData, F, BANKED
6E42  5109     MOVF 0x9, W, BANKED
6E44  5B01     SUBWFB 0x1, F, BANKED
6E46  510A     MOVF 0xA, W, BANKED
6E48  5B02     SUBWFB 0x2, F, BANKED
6E4A  510B     MOVF 0xB, W, BANKED
6E4C  5B03     SUBWFB 0x3, F, BANKED
6E4E  510C     MOVF 0xC, W, BANKED
6E50  5B04     SUBWFB 0x4, F, BANKED
6E52  510D     MOVF 0xD, W, BANKED
6E54  5B05     SUBWFB 0x5, F, BANKED
6E56  510E     MOVF 0xE, W, BANKED
6E58  5B06     SUBWFB 0x6, F, BANKED
6E5A  510F     MOVF 0xF, W, BANKED
6E5C  5B07     SUBWFB 0x7, F, BANKED
35:            				quotient |= 1;
6E5E  8112     BSF 0x12, 0, BANKED
36:            			}
37:            			*(unsigned long long int *)&divisor >>= 1;
6E60  90D8     BCF 0xFD8, 0, ACCESS
6E62  330F     RRCF 0xF, F, BANKED
6E64  330E     RRCF 0xE, F, BANKED
6E66  330D     RRCF 0xD, F, BANKED
6E68  330C     RRCF 0xC, F, BANKED
6E6A  330B     RRCF 0xB, F, BANKED
6E6C  330A     RRCF 0xA, F, BANKED
6E6E  3309     RRCF 0x9, F, BANKED
6E70  3308     RRCF 0x8, F, BANKED
38:            		} while(--counter != 0);
6E72  2F10     DECFSZ 0x10, F, BANKED
6E74  EFFF     GOTO 0x6DFE
6E76  F036     NOP
39:            	}
40:            	if(sign)
6E78  5111     MOVF 0x11, W, BANKED
6E7A  B4D8     BTFSC 0xFD8, 2, ACCESS
6E7C  EF42     GOTO 0x6E84
6E7E  F037     NOP
6E80  EF44     GOTO 0x6E88
6E82  F037     NOP
6E84  EF54     GOTO 0x6EA8
6E86  F037     NOP
41:            		quotient = -quotient;
6E88  1F19     COMF 0x19, F, BANKED
6E8A  1F18     COMF 0x18, F, BANKED
6E8C  1F17     COMF 0x17, F, BANKED
6E8E  1F16     COMF 0x16, F, BANKED
6E90  1F15     COMF 0x15, F, BANKED
6E92  1F14     COMF 0x14, F, BANKED
6E94  1F13     COMF 0x13, F, BANKED
6E96  6D12     NEGF 0x12, BANKED
6E98  0E00     MOVLW 0x0
6E9A  2313     ADDWFC 0x13, F, BANKED
6E9C  2314     ADDWFC 0x14, F, BANKED
6E9E  2315     ADDWFC 0x15, F, BANKED
6EA0  2316     ADDWFC 0x16, F, BANKED
6EA2  2317     ADDWFC 0x17, F, BANKED
6EA4  2318     ADDWFC 0x18, F, BANKED
6EA6  2319     ADDWFC 0x19, F, BANKED
42:            	return quotient;
6EAA  F848     NOP
6EAC  F600     NOP
6EB0  F84C     NOP
6EB2  F601     NOP
6EB6  F850     NOP
6EB8  F602     NOP
6EBC  F854     NOP
6EBE  F603     NOP
6EC2  F858     NOP
6EC4  F604     NOP
6EC8  F85C     NOP
6ECA  F605     NOP
6ECE  F860     NOP
6ED0  F606     NOP
6ED4  F864     NOP
6ED6  F607     NOP
43:            }
6ED8  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/aldiv.c  -------------------------
1:             // long signed unsigned division
2:             
3:             signed long int
4:             #ifdef __PICC__
5:             __aldiv(signed long int divisor, signed long int dividend)
6:             #else
7:             __aldiv(signed long int dividend, signed long int divisor)
8:             #endif
9:             {
10:            	signed long int	quotient;
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
73E6  0E00     MOVLW 0x0
73E8  6E0A     MOVWF 0xA, ACCESS
14:            	if(divisor < 0) {
73EA  BE08     BTFSC 0x8, 7, ACCESS
73EC  EFFC     GOTO 0x73F8
73EE  F039     NOP
73F0  EFFA     GOTO 0x73F4
73F2  F039     NOP
73F4  EF06     GOTO 0x740C
73F6  F03A     NOP
15:            		divisor = -divisor;
73F8  1E08     COMF 0x8, F, ACCESS
73FA  1E07     COMF 0x7, F, ACCESS
73FC  1E06     COMF 0x6, F, ACCESS
73FE  6C05     NEGF 0x5, ACCESS
7400  0E00     MOVLW 0x0
7402  2206     ADDWFC 0x6, F, ACCESS
7404  2207     ADDWFC 0x7, F, ACCESS
7406  2208     ADDWFC 0x8, F, ACCESS
16:            		sign = 1;
7408  0E01     MOVLW 0x1
740A  6E0A     MOVWF 0xA, ACCESS
17:            	}
18:            	if(dividend < 0) {
740C  BE04     BTFSC 0x4, 7, ACCESS
740E  EF0D     GOTO 0x741A
7410  F03A     NOP
7412  EF0B     GOTO 0x7416
7414  F03A     NOP
7416  EF17     GOTO 0x742E
7418  F03A     NOP
19:            		dividend = -dividend;
741A  1E04     COMF 0x4, F, ACCESS
741C  1E03     COMF 0x3, F, ACCESS
741E  1E02     COMF 0x2, F, ACCESS
7420  6C01     NEGF 0x1, ACCESS
7422  0E00     MOVLW 0x0
7424  2202     ADDWFC 0x2, F, ACCESS
7426  2203     ADDWFC 0x3, F, ACCESS
7428  2204     ADDWFC 0x4, F, ACCESS
20:            		sign ^= 1;
742A  0E01     MOVLW 0x1
742C  1A0A     XORWF 0xA, F, ACCESS
21:            	}
22:            	quotient = 0;
742E  0E00     MOVLW 0x0
7430  6E0B     MOVWF 0xB, ACCESS
7432  0E00     MOVLW 0x0
7434  6E0C     MOVWF 0xC, ACCESS
7436  0E00     MOVLW 0x0
7438  6E0D     MOVWF 0xD, ACCESS
743A  0E00     MOVLW 0x0
743C  6E0E     MOVWF 0xE, ACCESS
23:            	if(divisor != 0) {
743E  5005     MOVF 0x5, W, ACCESS
7440  1006     IORWF 0x6, W, ACCESS
7442  1007     IORWF 0x7, W, ACCESS
7444  1008     IORWF 0x8, W, ACCESS
7446  B4D8     BTFSC 0xFD8, 2, ACCESS
7448  EF28     GOTO 0x7450
744A  F03A     NOP
744C  EF2A     GOTO 0x7454
744E  F03A     NOP
7450  EF60     GOTO 0x74C0
7452  F03A     NOP
24:            		counter = 1;
7454  0E01     MOVLW 0x1
7456  6E09     MOVWF 0x9, ACCESS
25:            		while((divisor & 0x80000000UL) == 0) {
7458  EF34     GOTO 0x7468
745A  F03A     NOP
7468  AE08     BTFSS 0x8, 7, ACCESS
746A  EF39     GOTO 0x7472
746C  F03A     NOP
746E  EF3B     GOTO 0x7476
7470  F03A     NOP
7472  EF2E     GOTO 0x745C
7474  F03A     NOP
26:            			divisor <<= 1;
745C  90D8     BCF 0xFD8, 0, ACCESS
745E  3605     RLCF 0x5, F, ACCESS
7460  3606     RLCF 0x6, F, ACCESS
7462  3607     RLCF 0x7, F, ACCESS
7464  3608     RLCF 0x8, F, ACCESS
27:            			counter++;
7466  2A09     INCF 0x9, F, ACCESS
28:            		}
29:            		do {
30:            			quotient <<= 1;
7476  90D8     BCF 0xFD8, 0, ACCESS
7478  360B     RLCF 0xB, F, ACCESS
747A  360C     RLCF 0xC, F, ACCESS
747C  360D     RLCF 0xD, F, ACCESS
747E  360E     RLCF 0xE, F, ACCESS
31:            			if((unsigned long)divisor <= (unsigned long)dividend) {
7480  5005     MOVF 0x5, W, ACCESS
7482  5C01     SUBWF 0x1, W, ACCESS
7484  5006     MOVF 0x6, W, ACCESS
7486  5802     SUBWFB 0x2, W, ACCESS
7488  5007     MOVF 0x7, W, ACCESS
748A  5803     SUBWFB 0x3, W, ACCESS
748C  5008     MOVF 0x8, W, ACCESS
748E  5804     SUBWFB 0x4, W, ACCESS
7490  A0D8     BTFSS 0xFD8, 0, ACCESS
7492  EF4D     GOTO 0x749A
7494  F03A     NOP
7496  EF4F     GOTO 0x749E
7498  F03A     NOP
749A  EF58     GOTO 0x74B0
749C  F03A     NOP
32:            				dividend -= divisor;
749E  5005     MOVF 0x5, W, ACCESS
74A0  5E01     SUBWF 0x1, F, ACCESS
74A2  5006     MOVF 0x6, W, ACCESS
74A4  5A02     SUBWFB 0x2, F, ACCESS
74A6  5007     MOVF 0x7, W, ACCESS
74A8  5A03     SUBWFB 0x3, F, ACCESS
74AA  5008     MOVF 0x8, W, ACCESS
74AC  5A04     SUBWFB 0x4, F, ACCESS
33:            				quotient |= 1;
74AE  800B     BSF 0xB, 0, ACCESS
34:            			}
35:            			*(unsigned long int *)&divisor >>= 1;
74B0  90D8     BCF 0xFD8, 0, ACCESS
74B2  3208     RRCF 0x8, F, ACCESS
74B4  3207     RRCF 0x7, F, ACCESS
74B6  3206     RRCF 0x6, F, ACCESS
74B8  3205     RRCF 0x5, F, ACCESS
36:            		} while(--counter != 0);
74BA  2E09     DECFSZ 0x9, F, ACCESS
74BC  EF3B     GOTO 0x7476
74BE  F03A     NOP
37:            	}
38:            	if(sign)
74C0  500A     MOVF 0xA, W, ACCESS
74C2  B4D8     BTFSC 0xFD8, 2, ACCESS
74C4  EF66     GOTO 0x74CC
74C6  F03A     NOP
74C8  EF68     GOTO 0x74D0
74CA  F03A     NOP
74CC  EF70     GOTO 0x74E0
74CE  F03A     NOP
39:            		quotient = -quotient;
74D0  1E0E     COMF 0xE, F, ACCESS
74D2  1E0D     COMF 0xD, F, ACCESS
74D4  1E0C     COMF 0xC, F, ACCESS
74D6  6C0B     NEGF 0xB, ACCESS
74D8  0E00     MOVLW 0x0
74DA  220C     ADDWFC 0xC, F, ACCESS
74DC  220D     ADDWFC 0xD, F, ACCESS
74DE  220E     ADDWFC 0xE, F, ACCESS
40:            	return quotient;
74E2  F42C     NOP
74E4  F501     NOP
74E8  F430     NOP
74EA  F502     NOP
74EE  F434     NOP
74F0  F503     NOP
74F4  F438     NOP
74F6  F504     NOP
41:            }
74F8  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/abs.c  ---------------------------
1:             int abs(int a)
2:             {
3:             	return a>0 ? a : -a;
822C  0106     MOVLB 0x6
822E  BF13     BTFSC 0x13, 7, BANKED
8230  EF24     GOTO 0x8248
8232  F041     NOP
8234  5113     MOVF 0x13, W, BANKED
8236  E106     BNZ 0x8244
8238  0512     DECF 0x12, W, BANKED
823A  B0D8     BTFSC 0xFD8, 0, ACCESS
823C  EF22     GOTO 0x8244
823E  F041     NOP
8240  EF24     GOTO 0x8248
8242  F041     NOP
8244  EF36     GOTO 0x826C
8246  F041     NOP
824A  F848     NOP
824C  F614     NOP
8250  F84C     NOP
8252  F615     NOP
8254  1F14     COMF 0x14, F, BANKED
8256  1F15     COMF 0x15, F, BANKED
8258  4B14     INFSNZ 0x14, F, BANKED
825A  2B15     INCF 0x15, F, BANKED
825E  F850     NOP
8260  F612     NOP
8264  F854     NOP
8266  F613     NOP
8268  EF3C     GOTO 0x8278
826A  F041     NOP
826E  F848     NOP
8270  F612     NOP
8274  F84C     NOP
8276  F613     NOP
4:             }
8278  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/__fpclassifyf.c  -----------------
1:             #include <math.h>
2:             #include <stdint.h>
3:             
4:             int __fpclassifyf(float x)
5:             {
6:             	union {float f; uint32_t i;} u = {x};
71B0  FAAC     NOP
71B2  F60A     NOP
71B6  FAB0     NOP
71B8  F60B     NOP
71BC  FAB4     NOP
71BE  F60C     NOP
71C2  FAB8     NOP
71C4  F60D     NOP
71C8  F800     NOP
71CA  F60A     NOP
71CE  F804     NOP
71D0  F60B     NOP
71D4  F808     NOP
71D6  F60C     NOP
71DA  F80C     NOP
71DC  F60D     NOP
7:             	int e = u.i>>23 & 0xff;
71E0  F828     NOP
71E2  F604     NOP
71E6  F82C     NOP
71E8  F605     NOP
71EC  F830     NOP
71EE  F606     NOP
71F2  F834     NOP
71F4  F607     NOP
71F6  0E18     MOVLW 0x18
71F8  EF04     GOTO 0x7208
71FA  F039     NOP
71FC  0106     MOVLB 0x6
71FE  90D8     BCF 0xFD8, 0, ACCESS
7200  3307     RRCF 0x7, F, BANKED
7202  3306     RRCF 0x6, F, BANKED
7204  3305     RRCF 0x5, F, BANKED
7206  3304     RRCF 0x4, F, BANKED
7208  2EE8     DECFSZ 0xFE8, F, ACCESS
720A  EFFE     GOTO 0x71FC
720C  F038     NOP
720E  5104     MOVF 0x4, W, BANKED
7210  6F08     MOVWF 0x8, BANKED
7212  6B09     CLRF 0x9, BANKED
8:             	if (!e) return u.i<<1 ? FP_SUBNORMAL : FP_ZERO;
7214  5108     MOVF 0x8, W, BANKED
7216  1109     IORWF 0x9, W, BANKED
7218  A4D8     BTFSS 0xFD8, 2, ACCESS
721A  EF11     GOTO 0x7222
721C  F039     NOP
721E  EF13     GOTO 0x7226
7220  F039     NOP
7222  EF33     GOTO 0x7266
7224  F039     NOP
7226  90D8     BCF 0xFD8, 0, ACCESS
7228  350A     RLCF 0xA, W, BANKED
722A  6F04     MOVWF 0x4, BANKED
722C  350B     RLCF 0xB, W, BANKED
722E  6F05     MOVWF 0x5, BANKED
7230  350C     RLCF 0xC, W, BANKED
7232  6F06     MOVWF 0x6, BANKED
7234  350D     RLCF 0xD, W, BANKED
7236  6F07     MOVWF 0x7, BANKED
7238  5104     MOVF 0x4, W, BANKED
723A  1105     IORWF 0x5, W, BANKED
723C  1106     IORWF 0x6, W, BANKED
723E  1107     IORWF 0x7, W, BANKED
7240  A4D8     BTFSS 0xFD8, 2, ACCESS
7242  EF25     GOTO 0x724A
7244  F039     NOP
7246  EF27     GOTO 0x724E
7248  F039     NOP
724A  EF2D     GOTO 0x725A
724C  F039     NOP
724E  0E00     MOVLW 0x0
7250  6F01     MOVWF 0x1, BANKED
7252  0E02     MOVLW 0x2
7254  6F00     MOVWF txData, BANKED
7256  EF66     GOTO 0x72CC
7258  F039     NOP
725A  0E00     MOVLW 0x0
725C  6F01     MOVWF 0x1, BANKED
725E  0E03     MOVLW 0x3
7260  6F00     MOVWF txData, BANKED
7262  EF66     GOTO 0x72CC
7264  F039     NOP
9:             	if (e==0xff) return u.i<<9 ? FP_NAN : FP_INFINITE;
7266  2908     INCF 0x8, W, BANKED
7268  1109     IORWF 0x9, W, BANKED
726A  A4D8     BTFSS 0xFD8, 2, ACCESS
726C  EF3A     GOTO 0x7274
726E  F039     NOP
7270  EF3C     GOTO 0x7278
7272  F039     NOP
7274  EF62     GOTO 0x72C4
7276  F039     NOP
727A  F828     NOP
727C  F604     NOP
7280  F82C     NOP
7282  F605     NOP
7286  F830     NOP
7288  F606     NOP
728C  F834     NOP
728E  F607     NOP
7290  0E09     MOVLW 0x9
7292  90D8     BCF 0xFD8, 0, ACCESS
7294  3704     RLCF 0x4, F, BANKED
7296  3705     RLCF 0x5, F, BANKED
7298  3706     RLCF 0x6, F, BANKED
729A  3707     RLCF 0x7, F, BANKED
729C  2EE8     DECFSZ 0xFE8, F, ACCESS
729E  EF49     GOTO 0x7292
72A0  F039     NOP
72A2  5104     MOVF 0x4, W, BANKED
72A4  1105     IORWF 0x5, W, BANKED
72A6  1106     IORWF 0x6, W, BANKED
72A8  1107     IORWF 0x7, W, BANKED
72AA  B4D8     BTFSC 0xFD8, 2, ACCESS
72AC  EF5A     GOTO 0x72B4
72AE  F039     NOP
72B0  EF5D     GOTO 0x72BA
72B2  F039     NOP
72B4  0E01     MOVLW 0x1
72B6  EF5E     GOTO 0x72BC
72B8  F039     NOP
72BA  0E00     MOVLW 0x0
72BC  6F00     MOVWF txData, BANKED
72BE  6B01     CLRF 0x1, BANKED
72C0  EF66     GOTO 0x72CC
72C2  F039     NOP
10:            	return FP_NORMAL;
72C4  0E00     MOVLW 0x0
72C6  6F01     MOVWF 0x1, BANKED
72C8  0E04     MOVLW 0x4
72CA  6F00     MOVWF txData, BANKED
11:            }
72CC  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v2.10/pic/sources/c99/common/Umul16.c  ------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
853A  0106     MOVLB 0x6
853C  5100     MOVF txData, W, BANKED
853E  0302     MULWF 0x2, BANKED
8542  F3CC     NOP
8544  F604     NOP
8548  F3D0     NOP
854A  F605     NOP
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
854C  5100     MOVF txData, W, BANKED
854E  0303     MULWF 0x3, BANKED
8550  50F3     MOVF 0xFF3, W, ACCESS
8552  2705     ADDWF 0x5, F, BANKED
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
8554  5101     MOVF 0x1, W, BANKED
8556  0302     MULWF 0x2, BANKED
8558  50F3     MOVF 0xFF3, W, ACCESS
855A  2705     ADDWF 0x5, F, BANKED
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
46:            			product += multiplicand;
47:            		multiplicand <<= 1;
48:            		multiplier >>= 1;
49:            	} while(multiplier != 0);
50:            
51:            #endif
52:                    return product;
855E  F810     NOP
8560  F600     NOP
8564  F814     NOP
8566  F601     NOP
53:            }
8568  0012     RETURN 0
